diff -ru gcc-4.4.0-orig/config.sub gcc-4.4.0/config.sub
--- gcc-4.4.0-orig/config.sub	2023-12-23 10:48:53.509244401 +0000
+++ gcc-4.4.0/config.sub	2023-12-23 10:48:53.517244368 +0000
@@ -285,7 +285,7 @@
 	| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \
 	| sparcv8 | sparcv9 | sparcv9b | sparcv9v \
 	| spu | strongarm \
-	| tahoe | thumb | tic4x | tic80 | tron \
+	| tahoe | thumb | tic4x | tic80 | tms9900 | tron \
 	| v850 | v850e \
 	| we32k \
 	| x86 | xc16x | xscale | xscalee[bl] | xstormy16 | xtensa \
@@ -371,7 +371,7 @@
 	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | strongarm-* | sv1-* | sx?-* \
 	| tahoe-* | thumb-* \
 	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* | tile-* \
-	| tron-* \
+	| tron-* | tms9900-* \
 	| v850-* | v850e-* | vax-* \
 	| we32k-* \
 	| x86-* | x86_64-* | xc16x-* | xps100-* | xscale-* | xscalee[bl]-* \
@@ -1181,6 +1181,9 @@
 	pdp11)
 		basic_machine=pdp11-dec
 		;;
+	tms9900)
+		basic_machine=tms9900-ti
+		;;
 	we32k)
 		basic_machine=we32k-att
 		;;
@@ -1456,6 +1459,9 @@
 	pdp11-*)
 		os=-none
 		;;
+	tms9900-*)
+		os=-none
+		;;
 	*-dec | vax-*)
 		os=-ultrix4.2
 		;;
diff -ru gcc-4.4.0-orig/gcc/c-cppbuiltin.c gcc-4.4.0/gcc/c-cppbuiltin.c
--- gcc-4.4.0-orig/gcc/c-cppbuiltin.c	2023-12-09 11:24:53.953049596 +0000
+++ gcc-4.4.0/gcc/c-cppbuiltin.c	2024-01-06 17:22:05.290873797 +0000
@@ -104,12 +104,27 @@
   int decimal_dig;
 
   fmt = REAL_MODE_FORMAT (TYPE_MODE (type));
+
+/*  MGB don't assert if building for TMS9900.  We want to use radix-10
+ *  representations internally. */
+#ifndef TMS9900
   gcc_assert (fmt->b != 10);
+#endif
 
   /* The radix of the exponent representation.  */
   if (type == float_type_node)
     builtin_define_with_int_value ("__FLT_RADIX__", fmt->b);
-  log10_b = log10_2;
+
+/*  MGB if building for TMS9900 then radix may be 10.  If it isn't, then the log
+ *  value is 1 since we want no conversion of the exponent. */
+  if (fmt->b == 10)
+  {
+    log10_b = 1;
+  }
+  else
+  {
+    log10_b = log10_2;
+  }
 
   /* The number of radix digits, p, in the floating-point significand.  */
   sprintf (name, "__%s_MANT_DIG__", name_prefix);
@@ -614,6 +629,13 @@
 
   /* Misc.  */
   builtin_define_with_value ("__VERSION__", version_string, 1);
+#ifdef TMS9900
+  char major[10];
+  char *minor = strchr(revision_string, '.');
+  sprintf (major, "%d", atoi (revision_string));
+  builtin_define_with_value ("__TMS9900_PATCH_MAJOR__", major, 0);
+  builtin_define_with_value ("__TMS9900_PATCH_MINOR__", minor+1, 0);
+#endif
 
   if (flag_gnu89_inline)
     cpp_define (pfile, "__GNUC_GNU_INLINE__");
diff -ru gcc-4.4.0-orig/gcc/combine.c gcc-4.4.0/gcc/combine.c
--- gcc-4.4.0-orig/gcc/combine.c	2023-12-23 10:48:53.509244401 +0000
+++ gcc-4.4.0/gcc/combine.c	2024-02-22 15:33:34.165757860 +0000
@@ -1381,6 +1381,7 @@
           && uns1 == uns3
 	  && (mode1 == mode2 || strictly_local))
         {
+          // printf("MGB elim extend mode=%s\n", GET_MODE_NAME(mode4));
 	  /* Record that the value was promoted from mode1 to mode3,
 	     so that any sign extension at the head of the current
 	     function may be eliminated.  */
@@ -4466,6 +4467,7 @@
 		    return gen_rtx_CLOBBER (VOIDmode, const0_rtx);
 #endif
 
+
 		  new_rtx = (unique_copy && n_occurrences ? copy_rtx (to) : to);
 		  n_occurrences++;
 		}
@@ -6147,7 +6149,10 @@
 	  && GET_MODE_BITSIZE (GET_MODE (x)) <= HOST_BITS_PER_WIDE_INT
 	  && (nonzero_bits (SUBREG_REG (XEXP (x, 0)), GET_MODE (x))
 	      & ~GET_MODE_MASK (GET_MODE (XEXP (x, 0)))) == 0)
+        {
+        // printf ("MGB reduce ext(subr)\n");
 	return SUBREG_REG (XEXP (x, 0));
+        }
 
       /* (zero_extend:DI (truncate:SI foo:DI)) is just foo:DI when foo
 	 is a comparison and STORE_FLAG_VALUE permits.  This is like
@@ -9934,7 +9939,7 @@
 	 generate a paradoxical subreg instead.  That will force a reload
 	 of the original memref X.  */
       if (isize < osize)
-	return gen_rtx_SUBREG (omode, x, 0);
+        return gen_rtx_SUBREG (omode, x, 0);
 
       if (WORDS_BIG_ENDIAN)
 	offset = MAX (isize, UNITS_PER_WORD) - MAX (osize, UNITS_PER_WORD);
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/atof.c gcc-4.4.0/gcc/config/tms9900/atof.c
--- gcc-4.4.0-orig/gcc/config/tms9900/atof.c	2023-12-23 10:48:53.513244386 +0000
+++ gcc-4.4.0/gcc/config/tms9900/atof.c	2023-12-23 10:48:53.521244352 +0000
@@ -0,0 +1,142 @@
+/* atof.c
+   This method converts an ascii representation of a float to a float.
+   change log:
+   06/23/2023 mrvan initial version
+*/
+
+// #include <stdlib.h>
+// #include <ctype.h>
+// #include <string_ext.h>
+#define isdigit(s) ((s>='0')&&(s<='9'))
+
+// converts an ascii representation of a float to a float
+void tireal_atof (const char *a, unsigned char *result) {
+
+   // The TI-99/4A uses RADIX-100 for doubles. RADIX is also known as base. So the doubles are 
+   // stored in base 100. Doubles are stored as 8 bytes, where the number is in scientific notation,
+   // but again as radix 100:
+   // - The first byte is the exponent (a radix 100 exponent, not base 10 exponent).
+   // - Subsequent bytes store the mantissa. The decimal point is after the first mantissa digit.
+   // - Negative numbers are stored with the exponent and first digit negated.
+   // - Zero has an exponent and first digit set to 0 and 0, respectively.
+   // - Exponents are offset by 0x40.
+   // - Note that there are excellent explanations online, but even those have some incorrect info.
+   // - https://www.unige.ch/medecine/nouspikel/ti99/reals.htm
+   // - For instance, one example gets the matissa correct but the author inadvertantly used base
+   // - 10 for the exponent, rather than base 100.
+
+   char *s = (char *) a;
+   char * pd = (char *) result; // pointer to the return value
+
+   // staging values for final double value
+   int exp     = 0;                                            // base 100 exponent
+   int neg_pos = 1;                                            // pos = 1, neg = -1
+   int v[14]   = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // represented as base 10 later to be compbined as base 100
+   int pos     = 0;                                            // write pos in v[]
+   int dp      = 0;                                            // decimal point position relative to v[]
+
+   int b10_exp_neg_pos = 1;
+   int b10_exp = 0;
+   int b10_exp_have_digit = 0;
+
+   int n;
+   int have_pos_digit = 0;
+   int i;
+
+   // skip whitespace
+   // s = skip_whitespace (s);
+
+   // capture the negative sign if present
+   if (*s == '-') {
+      neg_pos = -1;
+      s++;
+   }
+
+   // run through the digits before any decimal point
+   while ( (*s) && (isdigit (*s)) && (pos < 14) ) {
+      n = *s;
+      n -= 48;
+      if (n >= 1) have_pos_digit = 1;
+      if (have_pos_digit) {
+         v[pos] = n;
+         pos++;
+      } 
+      s++;
+   }
+
+   // capture the decimal point position, even if implicit due to lack of one
+   if (*s == '.') {
+      s++;
+   }
+   dp = pos;
+
+   // run through the fractional digits before any exponent designation
+   while ( (*s) && (isdigit (*s)) && (pos < 14) ) {
+      n = *s;
+      n = n - '0'; 
+      if (n >= 1) have_pos_digit = 1;
+      if (have_pos_digit) {
+         v[pos] = n;
+         pos++;
+      } else {
+         dp--;
+      }
+      s++;
+   }
+
+   // handle specified exponent
+   if ( (*s == 'e') || (*s == 'E') ) {
+      s++;
+      if (*s == '-') {
+         b10_exp_neg_pos = -1;
+         s++;
+      }
+      while ( (*s) && (isdigit (*s)) ) {
+         if (b10_exp_have_digit) {
+            b10_exp *= 10;
+         }
+         n = *s;
+         b10_exp += n - '0';
+         b10_exp_have_digit = 1;
+         s++;
+      }
+      dp += b10_exp * b10_exp_neg_pos;
+   }
+   
+   // process the collected value if at least one positive digit was found, otherwise the value is zero
+   if (have_pos_digit) {
+      // calculate the exponent, which is base 100
+      exp = 0x3F + dp / 2;
+      if ( (dp > 0) && (dp % 2) ) exp++;
+   
+      // shift the base 10 digits right by one if not exp aligned for base 100
+      if (dp % 2) {
+         for (i = 13; i > 0; i--) {
+            v[i] = v[i - 1];
+         }
+         v[0] = 0;
+      }
+   }
+
+   // finally, convert the collected and processed value into a double
+
+   // generate the exponent, write and advance. Note that this is a base 100 exponent
+   if (neg_pos == -1) exp++;
+   n = exp * neg_pos;
+   *pd = n;
+   pd++;
+
+   // generate the first mantissa digit, that might need to be negated, write and advance
+   n = (v[0] * 10 + v[1]) * neg_pos; // base 100 generated by combining the v[0] and v[1] values
+   *pd = n;
+   pd++;
+   
+   // process and write the remaining base 100 digits, combining the adjacent base 10 digits
+   for (i = 2; i < 14; i += 2) {
+      n = v[i] * 10 + v[i + 1];
+      *pd = n;
+      pd++;
+   }
+
+   // return d;
+}
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/d_adj_neg_pos.c gcc-4.4.0/gcc/config/tms9900/d_adj_neg_pos.c
--- gcc-4.4.0-orig/gcc/config/tms9900/d_adj_neg_pos.c	2023-12-23 10:48:53.513244386 +0000
+++ gcc-4.4.0/gcc/config/tms9900/d_adj_neg_pos.c	2023-12-23 10:48:53.521244352 +0000
@@ -0,0 +1,18 @@
+/* d_adj_neg_pos.c
+   This method performs absolute value on the incoming double and indicates whether it was positive or negative.
+   06/23/2023 mrvan initial version
+*/
+
+#include "math_private.h"
+
+int d_adj_neg_pos (double *d) {
+   char *p = (char *) d;
+   int np = 1;
+   if (*p < 0) {
+      *p = -(*p) - 1;
+      np = -1;
+      p++;
+      *p = -(*p);
+   }
+   return np;
+}
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/d_compare.c gcc-4.4.0/gcc/config/tms9900/d_compare.c
--- gcc-4.4.0-orig/gcc/config/tms9900/d_compare.c	2023-12-23 10:48:53.513244386 +0000
+++ gcc-4.4.0/gcc/config/tms9900/d_compare.c	2023-12-23 10:48:53.521244352 +0000
@@ -0,0 +1,47 @@
+/* 06/23/2023 mrvan initial version
+*/
+#include "math_private.h"
+
+// returns a value less than zero if a is strictly less than b, 0 if equal, 1 if a is strictly greater than b
+int d_compare (double a, double b) { // , int lt_response, int gt_response, int eq_response) {
+   int npa = 1;
+   int npb = 1;           
+   char *pa, *pb;
+   int r;
+   int i;
+
+   npa = d_adj_neg_pos (&a);
+   npb = d_adj_neg_pos (&b);
+   
+   if (npa < npb) {
+      // r = lt_response;
+      r = -1;
+   } else if (npa > npb) {
+      // r = gt_response;
+      r = 1;
+   } else {
+      pa = (char *) &a;
+      pb = (char *) &b;
+      // r = eq_response;
+      r = 0;
+      for (i = 0; i < 8; i++) {
+         // first test if they are unequal and if so determine how so, otherwise move on.
+         // one comparison if equal, 1-2 if not.
+         if (!(*pa == *pb)) {
+            if (*pa < *pb) {
+               // r = lt_response;
+               r = -1;
+               break;
+            } else if (*pa > *pb) {
+               // r = gt_response;
+               r = 1;
+               break;
+            }
+         }
+         pa++;
+         pb++;
+      }
+   }
+
+   return r;
+}
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/double.c gcc-4.4.0/gcc/config/tms9900/double.c
--- gcc-4.4.0-orig/gcc/config/tms9900/double.c	2023-12-23 10:48:53.513244386 +0000
+++ gcc-4.4.0/gcc/config/tms9900/double.c	2023-12-23 10:48:53.521244352 +0000
@@ -0,0 +1,102 @@
+/* double.c
+   This file includes double math functions that the GCC compiler requires.
+   06/23/2023 mrvan initial version
+   08/14/2023 mrvan removed methods not associated with the FAC and ARG to separate files
+*/
+
+#include "math_private.h"
+
+#define FAC 0x834A
+#define ARG 0x835C;
+
+double *FADD_AUGEND       = (double *)FAC;
+double *FADD_ADDEND       = (double *)ARG;
+double *FADD_SUM          = (double *)FAC;
+
+double *FSUB_MINUEND      = (double *)ARG;
+double *FSUB_SUBTRAHEND   = (double *)FAC;
+double *FSUB_DIFFERENCE   = (double *)FAC;
+
+double *FMUL_MULTIPLICAND = (double *)ARG;
+double *FMUL_MULTIPLIER   = (double *)FAC;
+double *FMUL_PRODUCT      = (double *)FAC;
+
+double *FDIV_DIVIDEND     = (double *)FAC;
+double *FDIV_DIVISOR      = (double *)ARG;
+double *FDIV_QUOTIENT     = (double *)FAC;
+
+char *EXP                 = (char *)0x8376;
+unsigned char *SIGN       = (unsigned char *)0x8375; // >00 = positive, >FF = negative
+unsigned char *OVFL       = (unsigned char *)0x8354; // >01 if overflow
+
+// double addition -- method normally included in GCC lib
+double __adddf3 (double a, double b) {
+
+   // use the ti99's ROM method
+
+   // adds a and b
+   *FADD_AUGEND = a;
+   *FADD_ADDEND = b;
+
+  __asm__(
+    "lwpi >83E0\n\t"
+    "bl @>0D80\n\t"
+    "lwpi >83A0\n\t"
+  );
+
+  return *FADD_SUM;
+}
+
+// double subtraction -- method normally included in GCC lib
+double __subdf3 (double a, double b) {
+
+   // use the ti99's ROM method
+
+   // subtract b from a
+   *FSUB_MINUEND    = a;
+   *FSUB_SUBTRAHEND = b;
+
+  __asm__(
+    "lwpi >83E0\n\t"
+    "bl @>0D7C\n\t"
+    "lwpi >83A0\n\t"
+  );
+
+  return *FSUB_DIFFERENCE;
+}
+
+// double multiplication -- method normally included in GCC lib
+double __muldf3 (double a, double b) {
+
+   // use the ti99's ROM method
+
+   // multiply a and b
+   *FMUL_MULTIPLICAND = a;
+   *FMUL_MULTIPLIER   = b;
+
+  __asm__(
+    "lwpi >83E0\n\t"
+    "bl @>0E88\n\t"
+    "lwpi >83A0\n\t"
+  );
+
+  return *FMUL_PRODUCT;
+}
+
+// double division -- method normally included in GCC lib
+double __divdf3 (double a, double b) {
+
+   // use the ti99's ROM method
+
+   // divide b by a
+   *FDIV_DIVIDEND = b;
+   *FDIV_DIVISOR  = a;
+
+  __asm__(
+    "lwpi >83E0\n\t"
+    "bl @>0FF4\n\t"
+    "lwpi >83A0\n\t"
+  );
+
+  return *FDIV_QUOTIENT;
+}
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/eqdf2.c gcc-4.4.0/gcc/config/tms9900/eqdf2.c
--- gcc-4.4.0-orig/gcc/config/tms9900/eqdf2.c	2023-12-23 10:48:53.513244386 +0000
+++ gcc-4.4.0/gcc/config/tms9900/eqdf2.c	2023-12-09 11:15:23.961658672 +0000
@@ -0,0 +1,15 @@
+/* 06/23/2023 mrvan initial version
+*/
+// returns 0 if two double values are equal
+int __eqdf2 (double a, double b) {
+   char *ap = (char *) &a;
+   char *bp = (char *) &b;
+   int cmp = 0;
+   int i;
+   for (i = 0; i < 8; i++) {
+      cmp |= *ap != *bp;
+      ap++;
+      bp++;
+   }
+   return cmp;
+}
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/ftoa.c gcc-4.4.0/gcc/config/tms9900/ftoa.c
--- gcc-4.4.0-orig/gcc/config/tms9900/ftoa.c	2023-12-23 10:48:53.513244386 +0000
+++ gcc-4.4.0/gcc/config/tms9900/ftoa.c	2023-12-23 10:48:53.521244352 +0000
@@ -0,0 +1,55 @@
+/* ftoa.c
+   This method converts a TI float to an ascii representation of a float.  It
+   doesn't create very pretty output, but that doesn't matter, it's only for internal
+   use.
+
+   change log:
+   7-DEC-2023 MGB initial version
+*/
+
+void tireal_ftoa (unsigned char *d, char *p)
+{
+    short first = d[0] << 8 | d[1];
+    int exp;
+    int i;
+    if (first < 0)
+    {
+        *p++='-';
+        first =- first;
+    }
+
+    exp = first >> 8;
+    first &= 0xff;
+
+    if (first>9) *p++=(first/10) + '0';
+    *p++=(first%10)+'0';
+    *p++='.';
+    for (i = 2; i < 8; i++)
+    {
+        *p++=(d[i]/10)+'0';
+        *p++=(d[i]%10)+'0';
+    }
+
+    exp -= 0x40;
+    exp*=2;
+
+    if (exp != 0)
+    {
+        *p++='E';
+
+        if (exp<0)
+        {
+            *p++='-';
+            exp=-exp;
+        }
+
+        if (exp>9)
+        {
+            *p++=(exp/10)+'0';
+            exp/=10;
+        }
+        *p++=exp+'0';
+    }
+    *p=0;
+}
+
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/gedf2.c gcc-4.4.0/gcc/config/tms9900/gedf2.c
--- gcc-4.4.0-orig/gcc/config/tms9900/gedf2.c	2023-12-23 10:48:53.513244386 +0000
+++ gcc-4.4.0/gcc/config/tms9900/gedf2.c	2023-12-23 10:48:53.521244352 +0000
@@ -0,0 +1,9 @@
+/* 06/23/2023 mrvan initial version
+*/
+
+#include "math_private.h"
+
+// returns a value greater than or equal to zero if a is greater than or equal to b
+int __gedf2 (double a, double b) {
+   return d_compare (a, b); 
+}
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/gtdf2.c gcc-4.4.0/gcc/config/tms9900/gtdf2.c
--- gcc-4.4.0-orig/gcc/config/tms9900/gtdf2.c	2023-12-23 10:48:53.513244386 +0000
+++ gcc-4.4.0/gcc/config/tms9900/gtdf2.c	2023-12-09 11:16:04.565816750 +0000
@@ -0,0 +1,9 @@
+/* 06/23/2023 mrvan initial version
+*/
+
+#include "math_private.h"
+
+// returns a value greater than zero a is strictly greater than b
+int __gtdf2 (double a, double b) {
+   return d_compare (a, b);
+} 
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/ledf2.c gcc-4.4.0/gcc/config/tms9900/ledf2.c
--- gcc-4.4.0-orig/gcc/config/tms9900/ledf2.c	2023-12-23 10:48:53.513244386 +0000
+++ gcc-4.4.0/gcc/config/tms9900/ledf2.c	2023-12-23 10:48:53.521244352 +0000
@@ -0,0 +1,9 @@
+/* 06/23/2023 mrvan initial version
+*/
+
+#include "math_private.h"
+
+// returns a value less than or equal to zero if a is less than or equal to b
+int __ledf2 (double a, double b) {
+   return d_compare (a, b); 
+}  
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/lib1funcs.asm gcc-4.4.0/gcc/config/tms9900/lib1funcs.asm
--- gcc-4.4.0-orig/gcc/config/tms9900/lib1funcs.asm	2023-12-23 10:48:53.513244386 +0000
+++ gcc-4.4.0/gcc/config/tms9900/lib1funcs.asm	2024-02-25 11:51:00.286405896 +0000
@@ -0,0 +1,1058 @@
+/*
+ *  MGB 32-bit arithmetic functions never seem to be used.  The compiler emits
+ *  sequences of 16-bit ops to perform 32-bit ops.  An exception is it does look
+ *  for __ashlsi3 and __ashrsi3 when built to optimise for size (-Os) so these
+ *  have been added here.
+ */
+
+/******************************************************************************
+*                               __clzM2
+*******************************************************************************
+* Return the number of leading 0-bits in a value, starting at the most
+* significant bit position.  If the value is zero, the result is undefined.
+*
+* Inputs : r1 - Value to test
+*
+* Returns: r1 - Number of zero bits
+******************************************************************************/
+
+#ifdef L_clzqi2
+/*********************************************************/
+/*                     __clzqi2                          */
+/*********************************************************/
+  def __clzqi2
+__clzqi2:
+  mov  r2, @-2(r10)     /* Scratch reg */
+  movb r1, r2  /* Move value into position, set condition flags */
+  clr  r1      /* Set minimum bit count, flags unchanged */
+  jgt  do_clz  /* If val==0, return undefined, if val<0, MSB set, return 0*/
+  mov  @-2(r10), r2
+  b    *r11
+do_clz:
+  b    @__clz_nosave
+#endif
+
+
+#ifdef L_clzhi2
+/*********************************************************/
+/*                     __clzhi2                          */
+/*********************************************************/
+  def __clzhi2
+__clzhi2:
+  mov  r2, @-2(r10)     /* Scratch reg */
+  mov  r1, r2  /* Move value into position, set condition flags */
+  clr  r1      /* Set minimum bit count, flags unchanged */
+  jgt  do_clz  /* If val==0, return undefined, if val<0, MSB set, return 0*/
+  mov  @-2(r10), r2
+  b *r11
+do_clz:
+  b    @__clz_nosave
+#endif
+
+
+#ifdef L_clzsi2
+/*********************************************************/
+/*                     __clzsi2                          */
+/*********************************************************/
+  def __clzsi2
+__clzsi2:
+  mov  r2, @-2(r10)     /* Scratch reg */
+  mov  r1, r1   /* Test MSW for set bits */
+  jlt  ret_0    /* Upper bit of MSW set, return zero */
+  jgt  clz_msw  /* Count leading zeroes in MSW */
+
+clz_lsw:
+  li   r1, 16   /* MSW was zero, initialize count to 16 */
+  mov  r2, r2   /* Test bits in LSW */
+  jlt  ret_16   /* Upper bit of LSW set, return sisxteen */
+  jgt  do_clz   /* Count leading zeroes of LSW */
+
+ret_0:
+  clr  r1
+ret_16:
+  mov  @-2(r10), r2
+  b    *r11
+
+clz_msw:
+  mov  r1, r2  /* Move MSW into test position */
+  clr  r1      /* Initialize count to zero */
+do_clz:
+  b    @__clz_nosave
+#endif
+
+
+#ifdef L_clz
+/******************************************************************************
+*                               __clz
+*******************************************************************************
+* Return the number of leading 0-bits in a 16-bit value, starting at the most 
+* significant bit position.  If the value is zero, the result is undefined.
+*
+* Inputs : R1 - Minimum posible bit count
+*          R2 - Value to test
+*
+* Returns: R1 - Number of zero bits
+*******************************************************************************/
+  def __clz
+/*
+* We will shift left until we find a set bit
+*
+* Example 1, zero leading bits:
+*   C Val   N
+*   - ----  -
+*   . 1000  0
+*
+* Example 2, one leading bit:
+*   C Val   N
+*   - ----  -
+*   . 0100  4
+*   1 00..  2->1
+*
+* Example 3, two leading bits:
+*   C Val   N
+*   - ----  -
+*   0 0010  4
+*   0 10..  2
+*
+* If we got here, there is at least one bit set in supplied value
+*/
+__clz:
+  mov  r2, @-2(r10)     /* Scratch reg */
+__clz_nosave:
+  inct r1      /* Assume two zero bits, double count implied bit */
+  sla  r2, 2   /* Move next two bits into test position, set flags */
+  joc  bottom  /* Upper test bit set, exit */
+  jgt  __clz   /* Upper and lower test bits clear, loop */
+  
+  /* Clean up after loop */
+  inc r1       /* If we got here, negate next instruction */
+bottom:
+  dec r1       /* No cleared bits in last test set, decrement count */
+
+  /* Bit count is in R1, exit */
+  mov  @-2(r10), r2
+  b *r11
+#endif
+
+  
+/******************************************************************************
+*                               __ctzM2
+*******************************************************************************
+* Return the number of trailing 0-bits in a 16-bit value, starting at the least
+* significant bit position.  If the value is zero, the result is undefined.
+*
+* Inputs : R1 - Value to test
+*
+* Returns: R1 - Number of zero bits
+******************************************************************************/
+
+#ifdef L_ctzqi2
+/*********************************************************/
+/*                     __ctzqi2                          */
+/*********************************************************/
+  def __ctzqi2
+__ctzqi2:
+  clr  r2
+  movb r1, r2  /* Move value to R2, clearing low bits */
+  jeq  bottom  /* If all bits clear, stop now, return zero */
+  li   r1, 8   /* Max possible zero bits */
+  b    @__ctz  /* Examine provided value */
+bottom:
+  mov  @-2(r10), r2
+  b *r11
+#endif
+
+
+#ifdef L_ctzhi2
+/*********************************************************/
+/*                     __ctzhi2                          */
+/*********************************************************/
+  def __ctzhi2
+__ctzhi2:
+  mov  r2, @-2(r10)     /* Scratch reg */
+  mov r1, r2  /* Move value to R2, set condition flags */
+  jeq bottom  /* If all bits clear, stop now, return zero */
+  li  r1, 16  /* Max possible zero bits */
+  b   @__ctz_nosave  /* Examine provided value */
+bottom:
+  mov  @-2(r10), r2
+  b *r11
+#endif
+
+
+#ifdef L_ctzsi2
+/*********************************************************/
+/*                     __ctzsi2                          */
+/*********************************************************/
+  def __ctzsi2
+__ctzsi2:
+  mov  r2, @-2(r10)     /* Scratch reg */
+  mov  r2, r2     /* Check low word for set bits */
+  jeq  lsw_clear 
+
+  /* There are set bits in the low word */
+  li   r1, 16     /* Maximum number of possible zero bits */
+  b    @__ctz_nosave     /* Examine provided value */
+
+  /* All bits clear in the low word, no need to test them */
+lsw_clear:
+  mov  r1, r2     /* Move high word into test position */
+  jeq  bottom     /* If all bits clear, stop now, return zero */
+  li   r1, 32     /* Maximum number of possible zero bits */
+  b    @__ctz_nosave     /* Examine provided value */
+
+bottom:
+  mov  @-2(r10), r2
+  b *r11
+#endif
+
+
+#if L_ctz
+/******************************************************************************
+*                               __ctz
+*******************************************************************************
+* Return the number of trailing 0-bits in a 16-bit value, starting at the least 
+* significant bit position.  If the value is zero, the result is undefined.
+*
+* Inputs : R1 - Maximum posible bit count
+*          R2 - Value to test
+*
+* Returns: R1 - Number of zero bits
+******************************************************************************/
+  def __ctz
+
+/*
+* We will shift left until all leading set bits are shifted out of the value
+*
+* Exmaple 1, zero trailing bits:
+*   C Val   N
+*   - ----  -
+*   . 0001  4
+*   0 01..  2
+*   1 ....  0
+*
+* Exmaple 2, one trailing bit:
+*   C Val   N
+*   - ----  -
+*   . 0010  4
+*   0 10..  2
+*   0 ....  1
+*
+* Exmaple 3, two trailing bits:
+*   C Val   N
+*   - ----  -
+*   0 0100  4
+*   1 00..  2
+*/
+
+  /* Test loop, check two uppermost bits at a time */
+__ctz:
+  mov  r2, @-2(r10)     /* Scratch reg */
+__ctz_nosave:
+  dect r1      /* Assume both bits are set */
+  sla  r2, 2   /* Shift two bits into test position */
+  jne  __ctz_nosave   /* Still have set bits, keep looping */
+
+  /* Correct for last two test bits */
+  joc  bottom  /* If carry bit set, lower test bit was set */
+  inc  r1      /* lower test bit was clear, increment bit count */
+bottom:
+  mov  @-2(r10), r2
+  b *r11
+#endif
+
+
+/******************************************************************************
+*                               __ffsM2
+*******************************************************************************
+* Return the index of the least significant set bit in a value, or zero 
+* if the value is zero.  The least significant bit is index one.
+*
+* Inputs : R1 - Value to test
+*
+* Returns: R1 - Index to lowest set bit
+******************************************************************************/
+
+
+#ifdef L_ffsqi2
+/*********************************************************/
+/*                     __ffsqi2                          */
+/*********************************************************/
+  def __ffsqi2
+__ffsqi2:
+  dect r10
+  mov  r11,*r10
+  movb r1, r1     /* Check for zero value */
+  jeq  done       /* If so, exit now */
+  bl   @__ctzqi2  /* Count trailing zero bits */
+  inc  r1         /* Least sig. bit is in position trailing_count +1 */
+  jmp  ffsqi2_ret
+done:
+  clr  r1         /* Return zero value */
+ffsqi2_ret:
+  mov  *r10+, r11
+  b    *r11
+#endif
+
+
+#ifdef L_ffshi2
+/*********************************************************/
+/*                     __ffshi2                          */
+/*********************************************************/
+  def __ffshi2
+__ffshi2:
+  dect r10
+  mov  r11,*r10
+  mov r1, r1      /* Check for zero value */
+  jeq done        /* If so, exit now */
+  bl  @__ctzhi2   /* Count trailing zero bits */
+  inc r1          /* Least sig. bit is in position trailing_count +1 */
+done:
+  mov  *r10+, r11
+  b    *r11
+#endif
+
+
+#ifdef L_ffssi2
+/*********************************************************/
+/*                     __ffssi2                          */
+/*********************************************************/
+  def __ffssi2
+__ffssi2:
+  dect r10
+  mov  r11,*r10
+  mov r1, r0
+  soc r2, r0      /* Check for zero value */
+  jeq done        /* If so, exit now */
+  bl  @__ctzsi2   /* Count trailing zero bits */
+  inc r1          /* Least sig. bit is in position trailing_count +1 */
+done:
+  mov  *r10+, r11
+  b    *r11
+  ; def __modsi3 ; ???
+#endif
+
+
+#ifdef L_parity
+/******************************************************************************
+*                               __parityM2
+*******************************************************************************
+* Return the value zero if the number of bits set in the given value is even,
+* and the value one otherwise.
+*
+* Inputs : R1 - Value to test
+*
+* Returns: R1 - Number of zero bits
+******************************************************************************/
+
+/* Test an 8-bit value */
+  def __parityqi2
+__parityqi2:
+  dect r10
+  mov  r3,*r10  ; save r3
+  seto r3
+  jmp byte1
+
+/* Test a 16-bit value */
+  def __parityhi2
+__parityhi2:
+  dect r10
+  mov  r3,*r10  ; save r3
+  clr r3
+  jmp byte2
+
+/* Test a 32-bit value */
+  def __paritysi2
+__paritysi2:
+  dect r10
+  mov  r3,*r10  ; save r3
+  clr  r3
+  movb r2, r2
+  jop pre_byte3
+  inv r3
+pre_byte3:
+  swpb r2
+byte3:
+  movb r2, r2
+  jop byte2
+  inv r3
+byte2:
+  movb r1, r1
+  jop pre_byte1
+  inv r3
+pre_byte1:
+  swpb r1
+byte1:
+  movb r1, r1
+  jop done
+  inv r3
+done:
+  neg r3
+  mov r3, r1
+  mov  *r10+, r3
+  bl *r11
+#endif
+
+
+/******************************************************************************
+*                               __popcountM2
+*******************************************************************************
+* Return the number of set bits in a value
+*
+* Inputs : R1 - Value to test
+*
+* Returns: R1 - Number of set bits
+******************************************************************************/
+
+
+#ifdef L_popcountqi2
+/*********************************************************/
+/*                   __popcountqi2                       */
+/*********************************************************/
+  def __popcountqi2
+__popcountqi2:
+  dect r10
+  mov  r2,*r10  ; save r2
+  dect r10
+  mov  r11,*r10  ; save r11
+  clr  r2           /* Clear lower unused bits */
+  movb r1, r2       /* Move value into test position */
+  clr  r1           /* Clear bit count */
+  bl   @__popcount  /* Find set bit count */
+  mov  *r10+, r11
+  mov  *r10+, r3
+  b    *r11
+#endif
+
+
+#ifdef L_popcounthi2
+/*********************************************************/
+/*                   __popcounthi2                       */
+/*********************************************************/
+  def __popcounthi2
+__popcounthi2:
+  dect r10
+  mov  r2,*r10  ; save r2
+  dect r10
+  mov  r11,*r10  ; save r11
+  mov  r1, r2       /* Move value into test position */
+  clr  r1           /* Clear bit count */
+  bl   @__popcount  /* Find set bit count */
+  mov  *r10+, r11
+  mov  *r10+, r3
+  b    *r11
+#endif
+
+
+#ifdef L_popcountsi2
+/*********************************************************/
+/*                   __popcountsi2                       */
+/*********************************************************/
+  def __popcountsi2
+__popcountsi2:
+  dect r10
+  mov  r3,*r10  ; save r3
+  dect r10
+  mov  r11,*r10  ; save r11
+  mov  r1, r3       /* Move MSW to safe position */
+  clr  r1           /* Clear bit count */
+  bl   @__popcount  /* Find LSW set bit count */
+  mov  r3, r2       /* Move MSW into test position */
+  bl   @__popcount  /* Find MSW set bit count */
+  mov  *r10+, r11
+  mov  *r10+, r3
+  b    *r11
+#endif
+
+
+#ifdef L_popcount
+/******************************************************************************
+*                               __popcount
+*******************************************************************************
+* Return the number of set bits in a 16-bit value
+*
+* Inputs : R1 - Current bit count
+*          R2 - Value to test
+*
+* Returns: R1 - Number of set bits
+******************************************************************************/
+  def __popcount
+__popcount:
+  mov  r2,r2   /* Check for zero value */  
+  jeq  done    /* If zero, exit now */
+top:
+  inc  r1      /* Increment bit count */
+  mov  r2, r0  /* \                           */
+  neg  r0      /* | Equvilent to r2 &= (r2-1) */
+  szc  r0, r2  /* /                           */
+  jne  top     /* Keep looping until all bits counted */
+done:
+  b    *r11    /* Return to caller */
+#endif
+
+
+#ifdef L_divmodsi3
+/******************************************************************************
+*                               __divmodsi3
+*******************************************************************************
+* Calculate the signed quotient and modulus of the two values provided
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*           R5     - Address for modulus
+*
+* Returns: [R1,R2] - 32-bit quotient
+*
+* TODO - is this a library function?  Why pointer in r5?  Disabled for now
+******************************************************************************/
+  def __divmodsi3
+__divmodsi3:
+  /* Save return register and r6 */
+  dect r10
+  mov  r11,*r10
+  dect r10
+  mov  r5,*r10
+
+  bl   @__divmodstart
+
+  /* Caclulate result */
+calc:
+  bl   @__udivmod32
+
+  /* Negate modulus if needed */
+  mov  r5, r0
+  jlt  savemod
+  inv  r3
+  neg  r4
+  jnc  savemod
+  inc  r3
+  
+  /* Save modulus */
+savemod:
+  mov  *r10, r0
+  mov  r3, *r0+
+  mov  r4, *r0
+
+  /* Restore from stack */
+  mov  *r10+, r5
+  mov  *r10+, r11
+
+  /* Complete operatons */
+  b    @__divmodend
+#endif
+
+
+#ifdef L_divsi3
+/******************************************************************************
+*                               __divsi3
+*******************************************************************************
+* Calculate the signed quotient of the two values provided
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*
+* Returns: [R1,R2] - 32-bit quotient
+******************************************************************************/
+  def __divsi3
+__divsi3:
+  /* Save return register */
+  dect r10
+  mov  r11,*r10  ; save r11
+  dect r10
+  mov  r5,*r10  ; save r5
+  bl   @__divmodstart
+
+  /* Caclulate result */
+calc:
+  bl   @__udivmod32
+
+  /* Restore from stack */
+  mov  *r10+, r5
+  mov  *r10+, r11
+
+  b    @__divmodend
+#endif
+
+
+#ifdef L_modsi3
+/******************************************************************************
+*                               __modsi3
+*******************************************************************************
+* Calculate the signed modulus of the two values provided
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*
+* Returns: [R1,R2] - 32-bit modulus
+******************************************************************************/
+  def __modsi3
+__modsi3:
+  /* Save return register */
+  dect r10
+  mov  r11,*r10  ; save r11
+  dect r10
+  mov  r5,*r10  ; save r5
+  bl   @__divmodstart
+
+  /* Caclulate result */
+calc:
+  bl   @__udivmod32
+  mov  r3, r1
+  mov  r4, r2
+
+  /* Restore from stack */
+  mov  *r10+, r5
+  mov  *r10+, r11
+
+  b    @__divmodend
+#endif
+
+
+#ifdef L_divmod_common
+/******************************************************************************
+*                               __divmodstart
+*******************************************************************************
+* Common code for the start of all signed division and modulo calculations
+*
+* Inputs:  [R1,R2] - Signed 32-bit numerator
+*          [R3,R4] - Signed 32-bit denominator
+*
+* Returns: [R1,R2] - Positive 32-bit quotient
+*          [R3,R4] - Positive 32-bit denominator
+*          [R5]    - Sign of result
+******************************************************************************/
+  def __divmodstart
+__divmodstart:
+  /* Make numerator positive */
+  mov  r1, r5
+  jlt  negnum
+  jmp  testden
+negnum:
+  inv  r1
+  neg  r2
+  jnc  testden
+  inc  r1
+
+  /* Make denominator positive */
+testden:
+  xor  r3, r5
+  mov  r3, r3
+  jlt  negden
+  jmp  done
+negden:
+  inv  r3
+  neg  r4
+  jnc  done
+  inc  r3
+done:
+  b    *r11
+
+
+/******************************************************************************
+*                               __divmodend
+*******************************************************************************
+* Common code for the end of all signed division and modulo calculations
+*
+* Inputs:  [R1,R2] - Positive 32-bit quotient
+*          [R3,R4] - Positive 32-bit denominator
+*          [R5]    - Sign of result
+*          
+* Returns: [R1,R2] - Signed 32-bit result
+******************************************************************************/
+  def __divmodend
+__divmodend:
+
+  /* Do we need to negate the result? */
+  mov  r5, r0
+  jlt  makeneg  
+  b    *r11        # Nope, exit now
+
+  /* Negate result and return */
+makeneg:  
+  inv  r1
+  neg  r2
+  jnc  jmp1
+  inc  r1
+jmp1:
+  b    *r11
+#endif
+
+
+#ifdef L_udivmodsi3
+/******************************************************************************
+*                             __udivmodsi3
+*******************************************************************************
+* Calculate the unsigned quotient and remainder of the two values provided
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*           R5     - Address to place 32-bit remainder
+*
+* Returns: [R1,R2] - 32-bit quotient
+******************************************************************************/
+  def __udivmodsi3
+__udivmodsi3:
+  /* Save pointer and return address */
+  dect r10
+  mov  r11,*r10  ; save r11
+  dect r10
+  mov  r5,*r10  ; save r5
+
+  /* Do some math */
+  bl   @__udivmodsi
+  
+  /* Save remainder */
+  mov  *r10, r0
+  mov  r3, *r0+
+  mov  r4, *r0
+
+  mov  *r10+, r5
+  mov  *r10+, r11
+  b    *r11
+#endif
+
+
+#ifdef L_udivsi3
+/******************************************************************************
+*                               __udivsi3
+*******************************************************************************
+* Calculate the unsigned quotient of the two values provided
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*
+* Returns: [R1,R2] - 32-bit quotient
+******************************************************************************/
+  def __udivsi3
+__udivsi3:
+  /* Fall through to next routine */
+
+
+/******************************************************************************
+*                               __udivmod32
+*******************************************************************************
+* Calculate the unsigned quotient and remainder of the two values provided.
+* This is used by all the 32-bit division and modulus functions.
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*
+* Returns: [R1,R2] - 32-bit quotient
+*          [R3,R4] - 32-bit remainder
+******************************************************************************/
+  def __udivmod32
+__udivmod32:
+  ai   r10, -10
+  mov  r10, r0
+  mov  r5, *r0+
+  mov  r6, *r0+
+  mov  r7, *r0+
+  mov  r8, *r0+
+  mov  r12, *r0+
+
+  /* Check size of denominator */
+  mov  r3, r3      /* Is the upper word of denominator used? */
+  jne  den32       /* If so, jump to 32-bit code */
+
+  /* Handle 16-bit denominator */
+  /* Zero extend numerator */
+  clr  r0
+  mov  r1, r1
+  jeq  num16       /* If numerator is only 16 bits, skip the first DIV */
+
+  /* Perform calculation */
+  div  r4, r0
+num16:
+  div  r4, r1
+
+  /* Move results into return position */
+  mov  r2, r4      /* LSW of remainder */
+                   /* MSW of remainder still zero */
+  mov  r1, r2      /* LSW of result */
+  mov  r0, r1      /* MSW of result */
+  b    *r11
+
+den32:
+  /*
+  * Handle 32-bit denominator
+  *
+  *      A1*N + A1
+  * Q = ---------
+  *      B1*N + B2
+  *
+  * N = 0x10000
+  *
+  * Divide top and bottom by 2*B1 to make the denominator a 16-bit quantity
+  *
+  *        A1*N + A2
+  *       ---------
+  *          2*B1
+  * Q = ---------------
+  *        N     B2
+  *       --- + ---
+  *        2    2*B1
+  *
+  * This will result in some rounding error which must be corrected for.
+  * We will call the approximate value P, and the rounding error E. 
+  *
+  * Q - P = E
+  *
+  * Analysis of the error shows that E must be either 0 or -1. We will calculate
+  * the remainder to determine E and so correct P.
+  *
+  * R = (A1*N + A2) - P*(B1*N + B2)
+  *
+  * If R is negative, P is too large by one and we will apply the correction.
+  * Otherwise, P is correct and we can use the value directly.
+  */
+
+  /* Move arguments into test position */
+  mov  r1, r0      /* [r0,r12] <- [A1,A2] = numerator */
+  mov  r2, r12
+
+  mov  r3, r7      /* [r7,r8] <- [B1,B2] = deominator */
+  mov  r4, r8
+
+  /* Calculate V = (N/2 + B2/(2*B1)) */
+  clr  r1          /* [r1,r2] <- [C1,C2] = B2/2 */
+  mov  r8, r2
+  srl  r2, 1
+
+  div  r7, r1      /* r1 <- v = [C1,C2]/B1 */
+  ai   r1, 0x8000  /* v += 0x8000 */
+
+  /* Calculate U = (A1*N + A2)/(2*B1) */
+  mov  r0, r2      /* [r2,r3] <- [U1,U2] = [A1,A2] */
+  mov  r12, r3
+
+  srl  r2, 1       /* [U1,U2] = [A1,A2]/2 */
+  srl  r3, 1
+  jnc  jmp1
+  ori  r3, 0x8000
+jmp1:
+
+  clr  r4          /* [U1,U2] = [U1,U2]/B1 */
+  mov  r2, r5
+  div  r7, r4
+  mov  r3, r6
+  div  r7, r5
+  mov  r4, r2
+  mov  r5, r3
+
+  div  r1, r2      /* r2 <- P = [U1,U2]/V */
+
+  /* Calculate remainder  [m1,m2]=[a1,a2]-[b1,b2]*p */
+  mov  r7, r3      /* [r3,r4] <- [U1,U2] = B1*p */
+  mpy  r2, r3
+
+  mov  r8, r5      /* [r5,r6] <- [D1,D2] = B2*P */
+  mpy  r2, r5
+
+  a    r4, r5      /* [D1,D2] += [U2,0] */
+
+  mov  r0, r3      /* [M1,M2] = [A1,A2] */
+  mov  r12, r4
+
+  s    r5, r3      /* [M1,M2] -= [D1,D2] */
+  s    r6, r4
+  joc  jmp2
+  dec  r3
+jmp2:
+
+  /*
+  * Results now in return position, prepare for exit
+  *   [r1,r2] <- quotient
+  *   [r3,r4] <- remainder
+  */
+  clr  r1          /* Set upper word of quotient, we know it will be zero */
+  mov  r3, r3      /* if(remainder >= 0) P is correct */
+  jlt  jmp3
+  jmp  jmp4
+jmp3:
+
+  /* Correct result for rounding error */
+  dec  r2          /* P -= 1 */
+
+  /* Correct remainder for rounding error */
+  a    r7, r3      /* [M1,M2] += [B1,B2] */
+  a    r8, r4
+  jnc  jmp4
+  inc  r3
+jmp4:
+
+  /* Return value */
+  mov  *r10+, r5
+  mov  *r10+, r6
+  mov  *r10+, r7
+  mov  *r10+, r8
+  mov  *r10+, r12
+  b    *r11
+#endif
+
+
+#ifdef L_umodsi3
+/******************************************************************************
+*                               __umodsi3
+*******************************************************************************
+* Calculate the unsigned modulus of the two values provided
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*
+* Returns: [R1,R2] - 32-bit modulus
+******************************************************************************/
+  def __umodsi3
+__umodsi3:
+  dect r10
+  mov  r11,*r10  ; save r11
+  bl   @__udivmod32
+  mov  r3, r1
+  mov  r4, r2
+  mov  *r10+, r11
+  b    *r11
+#endif
+
+
+#ifdef L_ashlsi3
+/******************************************************************************
+*                               __ashlsi3
+*******************************************************************************
+* Arithmetic left shift of 32 bit value
+*
+* Inputs:  [R1,R2] - 32-bit value
+*          [R3]    - Shift count
+*
+* Returns: [R1,R2] - 32-bit result
+******************************************************************************/
+  def __ashlsi3
+__ashlsi3:
+  mov  r15, @-2(r10)     /* Scratch reg. No need to modify SP, not used and no siblings */
+
+  /* Variable shift */
+  mov  r3, r0
+  ci   r0, 16
+  jlt  ashllt16
+  jeq  ashleq16
+     
+  /* Shift count greater than 16 */
+  sla  r2, 0 
+
+  /* eq_16: Shift count equals 16 */
+ashleq16:
+  mov  r2, r1
+  clr  r2
+  jmp  ashldone
+
+  /* lt_16: Shift count less than 16 */
+ashllt16:      
+  abs  r0
+  jeq  ashldone
+  mov  r2, r15
+  sla  r1, 0
+  sla  r2, 0
+  neg  r0
+  srl  r15, 0
+  soc  r15, r1
+
+ashldone:
+  mov  @-2(r10), r15
+  b    *r11
+#endif
+
+
+#ifdef L_ashrsi3
+/******************************************************************************
+*                               __ashrsi3
+*******************************************************************************
+* Arithmetic left shift of 32 bit value
+*
+* Inputs:  [R1,R2] - 32-bit value
+*          [R3]    - Shift count
+*
+* Returns: [R1,R2] - 32-bit result
+******************************************************************************/
+  def __ashrsi3
+__ashrsi3:
+  mov  r15, @-2(r10)     /* Scratch reg */
+
+  /* Variable shift */
+  mov  r3, r0
+  ci   r0, 16
+  jlt  ashrlt16
+  jeq  ashreq16
+
+  /* Shift count greater than 16 */
+  sra  r1, 0
+
+ashreq16:
+  /* eq_16: Shift count equals 16 */
+  mov  r1, r2
+  seto r1
+  jlt  ashrdone
+  clr  r1
+  jmp  ashrdone
+
+ashrlt16:
+  /* lt_16: Shift count less than 16 */
+  abs  r0
+  jeq  ashrdone
+  mov  r2, r15
+  sra  r1, 0
+  srl  r2, 0
+  neg  r0
+  sla  r15, 0
+  soc  r15, r2
+
+ashrdone:
+  mov  @-2(r10), r15
+  b    *r11
+#endif
+
+
+#ifdef L_lshrsi3
+/******************************************************************************
+*                               __lshrsi3
+*******************************************************************************
+* Arithmetic left shift of 32 bit value
+*
+* Inputs:  [R1,R2] - 32-bit value
+*          [R3]    - Shift count
+*
+* Returns: [R1,R2] - 32-bit result
+******************************************************************************/
+  def __lshrsi3
+__lshrsi3:
+  mov  r15, @-2(r10)     /* Scratch reg */
+
+  /* Variable shift */
+  mov  r3, r0
+  ci   r0, 16
+  jlt  lshrlt16
+  jeq  lshreq16
+
+  /* Shift count greater than 16 */
+  srl  r1, 0
+
+lshreq16:
+  /* eq_16: Shift count equals 16 */
+  mov  r1, r2
+  clr  r1
+  jmp  lshrdone
+
+lshrlt16:
+  /* lt_16: Shift count less than 16 */
+  abs  r0
+  jeq  lshrdone
+  mov  r2, r15
+  srl  r1, 0
+  srl  r2, 0
+  neg  r0
+  sla  r15, 0
+  soc  r15, r2
+
+lshrdone:
+  mov  @-2(r10), r15
+  b    *r11
+#endif
+
+
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/longdivmod.c gcc-4.4.0/gcc/config/tms9900/longdivmod.c
--- gcc-4.4.0-orig/gcc/config/tms9900/longdivmod.c	2024-02-14 17:32:37.236912601 +0000
+++ gcc-4.4.0/gcc/config/tms9900/longdivmod.c	2024-02-14 17:32:37.244912643 +0000
@@ -0,0 +1,64 @@
+/* longdivmod.c
+   These methods provide long division and moduls.
+   change log:
+   12/26/2023 initial version
+*/
+
+// #include <longdivmod.h>
+
+long numerator_s32_cache = 0;
+long denominator_s32_cache = 0; 
+volatile long quotient_s32_cache;
+volatile long remainder_s32_cache;
+
+void divmod_s32 (long numerator, long denominator) {
+
+   long sign = 1;
+   long t;
+
+   quotient_s32_cache  = 0;
+   remainder_s32_cache = 0;
+
+   if (numerator < 0) {
+      sign      = sign * -1;
+      numerator = -numerator;
+   }
+
+   if (denominator < 0) {
+      sign        = sign * -1;
+      denominator = -denominator;
+   }
+
+   int i;
+   for (i = 31 ; i >= 0; i--) {
+      remainder_s32_cache = remainder_s32_cache << 1;
+      t                   = (long) 1 << i;
+      t                   = t & numerator; 
+      t                   = t >> i;
+      remainder_s32_cache = remainder_s32_cache | t;
+      if (remainder_s32_cache >= denominator) {
+         remainder_s32_cache = remainder_s32_cache - denominator;
+         quotient_s32_cache  = quotient_s32_cache | ((long) 1 << i);
+      }
+   }
+
+   quotient_s32_cache = quotient_s32_cache * sign;
+}
+
+long __divsi3 (long numerator, long denominator) {
+   if (numerator != numerator_s32_cache || denominator != denominator_s32_cache) {
+      numerator_s32_cache   = numerator;
+      denominator_s32_cache = denominator;
+      divmod_s32 (numerator_s32_cache, denominator_s32_cache);
+   }
+   return quotient_s32_cache;
+}
+
+long __modsi3 (long numerator, long denominator) {
+   if (numerator != numerator_s32_cache || denominator != denominator_s32_cache) {
+      numerator_s32_cache   = numerator;
+      denominator_s32_cache = denominator;
+      divmod_s32 (numerator_s32_cache, denominator_s32_cache);
+   }
+   return remainder_s32_cache;
+}
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/ltdf2.c gcc-4.4.0/gcc/config/tms9900/ltdf2.c
--- gcc-4.4.0-orig/gcc/config/tms9900/ltdf2.c	2023-12-23 10:48:53.513244386 +0000
+++ gcc-4.4.0/gcc/config/tms9900/ltdf2.c	2023-12-23 10:48:53.521244352 +0000
@@ -0,0 +1,9 @@
+/* 06/23/2023 mrvan initial version
+*/
+
+#include "math_private.h"
+
+// returns a value less than zero if a is strictly less than b
+int __ltdf2 (double a, double b) {
+   return d_compare (a, b); 
+}
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/math_private.h gcc-4.4.0/gcc/config/tms9900/math_private.h
--- gcc-4.4.0-orig/gcc/config/tms9900/math_private.h	2023-12-23 10:48:53.513244386 +0000
+++ gcc-4.4.0/gcc/config/tms9900/math_private.h	2023-12-23 10:48:53.521244352 +0000
@@ -0,0 +1,10 @@
+#ifndef MATH_PRIVATE_H
+#define MATH_PRIVATE_H
+
+// adjusts the exponent and first digit of mantissa to positive and returns -1 if the double is negative or 1 if not
+int d_adj_neg_pos (double *d);
+
+// compares two floats
+int d_compare (double a, double b);
+
+#endif
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/tms9900.c gcc-4.4.0/gcc/config/tms9900/tms9900.c
--- gcc-4.4.0-orig/gcc/config/tms9900/tms9900.c	2023-12-23 10:48:53.513244386 +0000
+++ gcc-4.4.0/gcc/config/tms9900/tms9900.c	2024-02-22 15:05:53.796277959 +0000
@@ -0,0 +1,1506 @@
+/* Subroutines for insn-output.c for TMS9900.
+   Copyright (C) 1987, 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002,
+   2004, 2005, 2006, 2007, 2008
+   Free Software Foundation, Inc.
+
+Copyright 2009 Eric Welser (EMW)
+Copyright 2023 Mark Burkley (MGB)
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#include "insn-modes.h"
+#include <stdio.h>
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "rtl.h"
+#include "tree.h"
+#include "tm_p.h"
+#include "regs.h"
+#include "hard-reg-set.h"
+#include "real.h"
+#include "insn-config.h"
+#include "conditions.h"
+#include "output.h"
+#include "insn-attr.h"
+#include "flags.h"
+#include "recog.h"
+#include "expr.h"
+#include "libfuncs.h"
+#include "toplev.h"
+#include "basic-block.h"
+#include "function.h"
+#include "ggc.h"
+#include "reload.h"
+#include "target.h"
+#include "target-def.h"
+#include "df.h"
+#include "dfp.h"
+#include "decimal128.h"
+#include "decNumber.h"
+
+/* Define this to put insn debug info into output files.  Note this method is a
+ * bit of a hack that takes a copy of the output file pointer.  On rare
+ * occasions this pointer may go invalid before we are finished which may cause
+ * a segfault on write so if debugging segfaults make sure to test with inline
+ * debug disabled 
+
+ * Note that this is also controlled by the -minline_rtl command line switch, so is
+ * always left enabled now.
+ */
+// #undef TMS9900_INLINE_DEBUG
+#define TMS9900_INLINE_DEBUG 1
+
+/* Define this to 1 to output debug info to stdout as we are compiling. */
+#if 0
+#define dbgprintf printf
+#else
+#define dbgprintf(...)
+#endif
+
+static bool tms9900_pass_by_reference (CUMULATIVE_ARGS *,
+                                       enum machine_mode, const_tree, bool);
+static bool tms9900_asm_integer(rtx x, unsigned int size, int aligned_p);
+
+static int tms9900_dwarf_label_counter;
+
+/* Define data types */
+#undef  TARGET_ASM_BYTE_OP
+#define TARGET_ASM_BYTE_OP "\tbyte\t"
+
+#undef  TARGET_ASM_ALIGNED_HI_OP
+#define TARGET_ASM_ALIGNED_HI_OP "\tdata\t"
+
+#undef  TARGET_PASS_BY_REFERENCE
+#define TARGET_PASS_BY_REFERENCE tms9900_pass_by_reference
+
+#undef  TARGET_ASM_INTEGER
+#define TARGET_ASM_INTEGER tms9900_asm_integer
+
+#undef  TARGET_FUNCTION_OK_FOR_SIBCALL
+#define TARGET_FUNCTION_OK_FOR_SIBCALL tms9900_ok_for_sibcall
+
+/*  MGB if we return true here, then any constants we define using
+ *  force_const_mem will get added to a shared pool instead of a function pool.
+ *  This should result in better use of memory as duplicates will be eliminated.
+ *  We don't care about distances as all memory references are 16-bits.
+ *
+ *  NOTE : force_const_mem must only be called in a define_expand not a
+ *  define_insn as it is too late to add a constant to the pool for output by
+ *  the time we are emitting insns.
+ *
+ *  Actually, expands have problems too.  Presumably because later compiler
+ *  passes can generate new compare insns which then can't be matched.
+ *  define_insn_and_split works better
+ *
+ *  Changing this to be false to use per fucntion pools instead.  If byte
+ *  constants are placed at the end of a compilation unit, it may result in an
+ *  odd address for the end of the pseg which messes up loading.  TODO fix that
+ *  properly sometime.
+ */
+
+static bool
+tms9900_use_blocks_for_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED,
+				const_rtx x ATTRIBUTE_UNUSED)
+{
+  // return true;
+  return false;
+}
+
+#undef TARGET_USE_BLOCKS_FOR_CONSTANT_P
+#define TARGET_USE_BLOCKS_FOR_CONSTANT_P tms9900_use_blocks_for_constant_p
+
+static bool
+tms9900_ok_for_sibcall (tree decl, tree exp)
+{
+  return true;
+}
+
+#define TARGET_ASM_ALIGNED_HI_OP "\tdata\t"
+#define TARGET_ASM_ALIGNED_SI_OP NULL
+#define TARGET_ASM_ALIGNED_DI_OP NULL
+#define TARGET_ASM_ALIGNED_TI_OP NULL
+
+static bool
+tms9900_cannot_force_const_mem (rtx x);
+
+#undef TARGET_CANNOT_FORCE_CONST_MEM
+#define TARGET_CANNOT_FORCE_CONST_MEM tms9900_cannot_force_const_mem
+
+struct gcc_target targetm = TARGET_INITIALIZER;
+
+#include "ftoa.c"
+#include "atof.c"
+
+static void
+tms9900_encode_real (const struct real_format *fmt, long *buf,
+		    const REAL_VALUE_TYPE *r)
+{
+  char a[256];
+  unsigned char d[8];
+  decimal128ToString((const decimal128*)r->sig, a);
+
+  tireal_atof (a, d);
+
+  // Convert 8-bytes to 3-longs ????
+  buf[0] = (d[0] << 24) | (d[1] << 16) | (d[2] << 8) | d[3];
+  buf[1] = (d[4] << 24) | (d[5] << 16) | (d[6] << 8) | d[7];
+  buf[2] = 0;
+}
+
+/*  Decode a TI real to REAL_VALUE_TYPE by first converting it to a string.  The
+ *  r->sig member of the real value is a decimal128 struct */
+static void
+tms9900_decode_real (const struct real_format *fmt, REAL_VALUE_TYPE *r,
+		    const long *buf)
+{
+  char s[32];
+  unsigned char d[8];
+
+  /*  Assuming reverse mapping of longs to bytes that we did in encode */
+  d[0] = (buf[0] >> 24) & 0xff;
+  d[1] = (buf[0] >> 16) & 0xff;
+  d[2] = (buf[0] >> 8) & 0xff;
+  d[3] = buf[0] & 0xff;
+  d[4] = (buf[1] >> 24) & 0xff;
+  d[5] = (buf[1] >> 16) & 0xff;
+  d[6] = (buf[1] >> 8) & 0xff;
+  d[7] = buf[1] & 0xff;
+
+  tireal_ftoa (d, s);
+    
+  decimal_real_from_string (r, s);
+}
+
+const struct real_format tms9900_real_format =
+  {
+    tms9900_encode_real,
+    tms9900_decode_real,
+    10,         // base 10
+    14,         // 14 digits
+    14,         // 14 digits
+    -63,        // lowest exp
+    64,         // highest exp
+    63,
+    63,
+    false,      // Don't round toward 0
+    false,      // Don't have sign dependent rounding
+    false,      // Don't have NAN
+    false,      // Don't have INF
+    false,      // Don't have denorm whatever that is
+    true,       // Do have signed zero
+    false,      // Don't have qnan
+    false       // Don't have that last thing
+  };
+
+
+/* Set global variables as needed for the options enabled.  */
+
+void override_options (void)
+{
+  /* We use TI99 floating point, not IEEE floating point.  */
+  if (!TARGET_NO_TI99_FLOAT)
+    REAL_MODE_FORMAT (DFmode) = &tms9900_real_format;
+}
+
+/* Non-volatile registers to be saved across function calls */
+#define MAX_SAVED_REGS 6
+
+static int nvolregs[]={
+   HARD_LR_REGNUM,
+   HARD_BP_REGNUM,
+   HARD_R12_REGNUM,
+   HARD_R13_REGNUM,
+   HARD_R14_REGNUM,
+   HARD_R15_REGNUM};
+
+/* If defined, a C expression which determines whether, and in which direction,
+   to pad out an argument with extra space.  The value should be of type
+   `enum direction': either `upward' to pad above the argument,
+   `downward' to pad below, or `none' to inhibit padding.
+
+   Structures are stored left shifted in their argument slot.  */
+int tms9900_function_arg_padding (enum machine_mode mode,
+                                  const_tree type)
+{
+  if (type != 0 && AGGREGATE_TYPE_P (type))
+  {
+    dbgprintf ("%s upward\n", __func__);
+    return upward;
+  }
+
+  /* Fall back to the default.  */
+  return DEFAULT_FUNCTION_ARG_PADDING (mode, type);
+}
+
+
+/* Update the data in CUM to advance over an argument
+   of mode MODE and data type TYPE.
+   (TYPE is null for libcalls where that information may not be available.)  */
+void tms9900_function_arg_advance (CUMULATIVE_ARGS *cum, 
+                                   enum machine_mode mode,
+                                   tree type, 
+                                   int named ATTRIBUTE_UNUSED)
+{
+  int arg_bytes;
+  if(mode == BLKmode)
+  {
+     arg_bytes = int_size_in_bytes (type);
+  }
+  else
+  {
+     arg_bytes = GET_MODE_SIZE (mode);
+  }
+  cum->nregs += ((arg_bytes + 1)/ UNITS_PER_WORD) * REGS_PER_WORD;
+  dbgprintf("%s bytes=%d\n", __func__, arg_bytes);
+  return;
+}
+
+
+/* Initialize a variable CUM of type CUMULATIVE_ARGS
+   for a call to a function whose data type is FNTYPE.
+   For a library call, FNTYPE is NULL.  */
+void tms9900_init_cumulative_args (CUMULATIVE_ARGS *cum, 
+                                   tree fntype ATTRIBUTE_UNUSED,
+                                   rtx libname ATTRIBUTE_UNUSED)
+{
+  /* Varargs vectors are treated the same as long long. Using
+     named_count avoids having to change the way 'named' is handled */
+  cum->named_count = 0;
+  cum->nregs = 0;
+}
+
+
+/* Determine where to put an argument to a function.
+   Value is zero to push the argument on the stack,
+   or a hard register in which to store the argument.
+
+   MODE is the argument's machine mode.
+   TYPE is the data type of the argument (as a tree).
+      This is null for libcalls where that information may
+      not be available.
+   CUM is a variable of type CUMULATIVE_ARGS which gives info about
+      the preceding args and about the function being called.
+   NAMED is nonzero if this argument is a named parameter
+      (otherwise it is an extra parameter matching an ellipsis).  */
+rtx tms9900_function_arg (CUMULATIVE_ARGS *cum, 
+                          enum machine_mode mode,
+		          tree type,
+                          int named)
+{
+   if (mode == VOIDmode)
+   {
+     /* Pick an arbitrary value for operand 2 of the call insn.  */
+     dbgprintf ("%s void\n", __func__);
+     return const0_rtx;
+   }
+  
+   /* TODO it seems named is zero for the last named parameter before an
+    * elipsis.  The value named_count in the cum structure is not used but in
+    * the arm backend, the code traverses the arg tree to count the number of
+    * named params.  Maybe its a known thing that named_count should be
+    * maintained separately
+    */
+   if (/* Vararg argument, must live on stack */
+       !named ||
+       /* Argument doesn't completely fit in arg registers */      
+       GET_MODE_SIZE(mode) + cum->nregs > TMS9900_ARG_REGS)
+   {
+      dbgprintf ("%s named=%d size=%d nr=%d max=%d : alloc on stack\n", __func__,
+              named, (int)GET_MODE_SIZE(mode), cum->nregs, TMS9900_ARG_REGS);
+      return NULL_RTX;
+   }
+
+   /* Allocate registers for argument */
+   dbgprintf ("%s alloc in reg %d\n", __func__, cum->nregs+1);
+   return gen_rtx_REG (mode, cum->nregs + HARD_R1_REGNUM);
+}
+
+/* Output all constant addresses using hex values */
+static void tms9900_output_addr_const(FILE *file, rtx addr)
+{
+  if(CONST_INT_P(addr))
+    fprintf(file, ">%X", (int)(INTVAL(addr)) & 0xFFFF);
+  else
+    output_addr_const(file, addr);
+}
+
+/* Construct string expression matching an address operand */
+void print_operand_address (FILE *file,
+                            register rtx addr)
+{
+  retry:
+  switch (GET_CODE (addr))
+    {
+    case MEM:
+      addr = XEXP (addr, 0);
+      goto retry;
+
+    case REG:
+      fprintf (file, "*%s", reg_names[REGNO (addr)]);
+      break;
+
+    case POST_MODIFY:
+    case POST_INC:
+      fprintf (file, "*%s+", reg_names[REGNO (XEXP (addr, 0))]);
+      break;
+
+    case PLUS:
+      /* @xxxx(R0) */
+      if (GET_CODE (addr) == PLUS            &&
+          GET_CODE (XEXP (addr, 0)) == REG   &&
+          REG_OK_FOR_BASE_P (XEXP (addr, 0)) &&
+          CONSTANT_ADDRESS_P (XEXP (addr, 1)))
+      {
+        fprintf(file, "@");
+        tms9900_output_addr_const (file, XEXP (addr, 1));
+        fprintf(file, "(%s)", reg_names[REGNO (XEXP (addr, 0))]);
+      }
+
+      /* @(symbol+xxxx)(R0) */
+      else if(GET_CODE (addr) == PLUS )
+      {
+        rtx base   = 0;
+        rtx offset = 0;
+        int regno  = 0;
+        if(GET_CODE(XEXP(addr,0)) == MEM)
+        {
+          rtx op = XEXP(addr,0);
+          op = XEXP(op, 0);
+          if(GET_CODE (op) == PLUS             &&
+             GET_CODE (XEXP (op, 0)) == REG    &&
+             REG_OK_FOR_BASE_P (XEXP (op, 0))  &&
+             CONSTANT_ADDRESS_P(XEXP (op, 1))  &&
+             CONSTANT_ADDRESS_P(XEXP(addr, 1)))
+          {
+            base   = XEXP(addr, 1);
+            offset = XEXP(op, 1);
+            regno  = REGNO(XEXP(op, 0));
+            if(CONST_INT_P(base) && CONST_INT_P(offset))
+            {
+              fprintf(file, "@>%X(%s)", (int)(INTVAL(base) + INTVAL(offset)) & 0xFFFF, reg_names[regno]);
+            }
+            else
+            {
+              fprintf(file, "@(");
+              tms9900_output_addr_const (file, base);
+              fprintf(file, "+>%X)(%s)", ((int)INTVAL(offset)) & 0xFFFF, reg_names[regno]);
+            }
+          }
+        }
+      }
+      else
+      {
+        gcc_assert (0);
+      }
+      break;
+
+    default:
+      fprintf(file, "@");
+      tms9900_output_addr_const (file, addr);
+    }
+}
+
+/* Should we save this register?  The only registers we care about are R11 which
+ * must be saved if we are not a leaf function or if used by an inline asm and
+ * R14 if we use a frame pointer in this function. */ 
+int tms9900_should_save_reg(int regno)
+{
+  dbgprintf("%s ever_live=%d used=%d R%d leaf=%d fp_need=%d\n",
+         __func__, df_regs_ever_live_p(regno), call_used_regs[regno],
+         regno, current_function_is_leaf,
+         frame_pointer_needed);
+
+  /*  Generic condition for register that is used and marked as must be
+   *  preserved */
+  if (df_regs_ever_live_p(regno) && (call_used_regs[regno] == 0))
+  {
+    dbgprintf ("%s save live and not used\n", __func__);
+    return 1;
+  }
+
+  /*  Special case, R11 is declared as used so save it */
+  if (df_regs_ever_live_p(regno) && regno == HARD_LR_REGNUM)
+  {
+    dbgprintf ("%s save LR, ever_live\n", __func__);
+    return 1;
+  }
+
+  /*  This function calls other functions, save R11 */
+  if (regno == HARD_LR_REGNUM && !current_function_is_leaf)
+  {
+    dbgprintf ("%s save LR, not leaf\n", __func__);
+    return 1;
+  }
+          
+  /*  Not used, but the logic here is to only save BP if we need a frame pointer */
+  if (regno == HARD_BP_REGNUM && frame_pointer_needed)
+  {
+    dbgprintf ("%s save BP\n", __func__);
+    return 1;
+  }
+
+  dbgprintf ("%s no save\n", __func__);
+  return 0;
+}
+
+/* Get number of bytes used to save registers in the current stack frame */
+static int tms9900_get_saved_reg_size(void)
+{
+   int size = 0;
+   int i;
+
+   for (i = 0; i < MAX_SAVED_REGS; i++)
+      if (tms9900_should_save_reg (nvolregs[i]))
+         size += 2; 
+
+   return size;
+}
+
+static int tms9900_get_regs_to_save (int saveregs[])
+{
+   int i;
+   int count = 0;
+
+   for (i = 0; i < MAX_SAVED_REGS; i++)
+      if (tms9900_should_save_reg (nvolregs[i]))
+         saveregs[count++] = nvolregs[i];
+
+   return count;
+}
+
+static void print_arg_offset (int from)
+{
+    switch (from)
+    {
+    case ARG_POINTER_REGNUM: dbgprintf ("%d=ARG_PTR_R ", from); break;
+    case HARD_SP_REGNUM: dbgprintf ("%d=HARD_SP_R ", from); break;
+    case FRAME_POINTER_REGNUM: dbgprintf ("%d=FR_PTR_R ", from); break;
+    default: dbgprintf ("%d=dunno? ", from); break;
+    }
+}
+
+/* Define the offset between two registers, one to be eliminated, and the
+   other its replacement, at the start of a routine.
+   MGB return values as they are AFTER the prolog */
+int tms9900_initial_elimination_offset (int from,
+                                        int to)
+{
+  /*  
+      [argn]
+      .
+      [arg0]
+      . <- arg pointer
+      [saved regs]
+      [frame]
+      . <- stack pointer
+      . <- frame pointer
+  */
+
+  // dbgprintf("%s savedregs=%d frame=%d ", __func__,
+  //     tms9900_get_saved_reg_size(), get_frame_size());
+  // print_arg_offset (from);
+  // print_arg_offset (to);
+  int ret = 0;
+  if (from == ARG_POINTER_REGNUM && to == HARD_SP_REGNUM)
+  {
+    ret =(tms9900_get_saved_reg_size()+
+           get_frame_size ());
+  }
+  if (from == FRAME_POINTER_REGNUM && to == HARD_SP_REGNUM)
+  {
+    ret = 0;
+  }
+  if (from == ARG_POINTER_REGNUM && to == FRAME_POINTER_REGNUM)
+  {
+    ret =(tms9900_get_saved_reg_size()+
+           get_frame_size ());
+  }
+  // dbgprintf ("%s res=%d\n", __func__, ret);
+  return ret;
+}
+
+
+/* Determine if an address is represented using a valid expression */
+int legitimate_address_p (enum machine_mode mode,
+                          rtx address)
+{
+    GO_IF_LEGITIMATE_ADDRESS(mode, address, win);   
+    return 0;
+    
+  win:
+    return 1;
+}
+
+
+/* Determine the memory operand type
+   returns : 0 - Not a memory operand
+             1 - Register indirect : *Rn
+             2 - Post increment    : *Rn+
+             3 - Indexed register  : @INDEX(Rn)
+*/
+int tms9900_address_type(rtx op,
+                         enum machine_mode mode ATTRIBUTE_UNUSED)
+{
+  rtx addr;
+
+  /* Eliminate non-memory operations */
+  if (GET_CODE (op) != MEM)
+    return 0;
+
+  /* Decode the address now.  */
+indirection:
+  addr = XEXP (op, 0);
+  switch (GET_CODE (addr))
+  {
+    case REG:
+      /* Register indirect: *Rn */
+      return 1;
+	
+    case POST_INC:
+      /* Post increment: *Rn+ */
+      return 2;
+	
+    case MEM:
+      /* Yes, we know this is a memory expression.
+         Strip this code and try again */
+      op=addr;
+      goto indirection;
+	
+    case CONST_INT:
+    case LABEL_REF:	       
+    case CONST:
+    case SYMBOL_REF:
+      /* Indexed register : @ADDRESS(R0) - extra word required */
+
+    case PLUS:
+      /* Indexed register : @INDEX(Rn) - extra word required */
+      return 3;
+
+    default:
+      break;
+  }
+    
+  /* We should never get here, but we need to return something */
+  return 0;
+}
+
+
+/* Emit a branch condtional instruction */
+const char* output_branch (const char *pos, const char *neg, int length)
+{
+    static int label_id = 0;
+    
+    static char buf[1000];
+    length -= 10;
+    if(length == 2)
+    {
+        sprintf(buf, "%s  %%l0",pos);
+    }
+    else if(length == 4)
+    {
+        if(*pos == 'L')
+            sprintf(buf, "jlt  %%l0\n"
+                         "\tjeq  %%l0");
+        else if(*pos == 'G')
+            sprintf(buf, "jgt  %%l0\n"
+                         "\tjeq  %%l0");
+        else
+            gcc_unreachable();
+    }
+    else if(length == 6)
+    {
+	sprintf(buf, "%s  JMP_%d\n"
+                     "\tb    @%%l0\n"
+                     "JMP_%d", neg, label_id, label_id);	
+	label_id++;
+    }
+    else if(length == 8)
+    {
+        if(*neg == 'L')
+            sprintf(buf, "jlt  JMP_%d\n"
+                         "\tjeq  JMP_%d\n"
+                         "\tb    @%%l0\n"
+                         "JMP_%d", label_id, label_id, label_id);
+        else if(*neg == 'G')
+            sprintf(buf, "jgt  JMP_%d\n"
+                         "\tjeq  JMP_%d\n"
+                         "\tb    @%%l0\n"
+                         "JMP_%d", label_id, label_id, label_id);
+        else
+            gcc_unreachable();
+
+	label_id++;
+    }
+    else
+    {
+	gcc_unreachable();
+    }    
+    return buf;
+}
+
+
+/* Emit a jump instrcution */
+const char* output_jump (int length)
+{
+    length -= 10;
+    switch(length)    
+    {
+        case 2: return("jmp  %l0");
+        case 4: return("b    @%l0");
+        default: gcc_unreachable();
+    }
+}
+
+
+/* Determine if an instruction will update the conditional
+   flag as a side effect. This is used to eliminate unnneded
+   comparison instructions */
+void notice_update_cc_on_set(rtx exp, rtx insn ATTRIBUTE_UNUSED)
+{
+  if (GET_CODE (SET_DEST (exp)) == CC0)
+  {
+    cc_status.flags = 0;					
+    cc_status.value1 = SET_DEST (exp);			
+    cc_status.value2 = SET_SRC (exp);			
+  }
+  else if((GET_MODE (SET_DEST(exp)) == HImode ||
+           GET_MODE (SET_DEST(exp)) == QImode)
+          &&
+          (GET_CODE(SET_SRC(exp)) == PLUS  ||
+           GET_CODE(SET_SRC(exp)) == MINUS ||
+           GET_CODE(SET_SRC(exp)) == AND   ||
+           GET_CODE(SET_SRC(exp)) == IOR   ||
+           GET_CODE(SET_SRC(exp)) == XOR   ||
+           GET_CODE(SET_SRC(exp)) == NOT   ||
+           GET_CODE(SET_SRC(exp)) == NEG   ||
+           GET_CODE(SET_SRC(exp)) == ABS   ||
+           GET_CODE(SET_SRC(exp)) == REG   ||
+           GET_CODE(SET_SRC(exp)) == MEM))
+  {
+    cc_status.flags = 0;
+    cc_status.value1 = SET_SRC (exp);
+    cc_status.value2 = SET_DEST (exp);
+  }
+  else
+  {  
+    /* This last else is a bit paranoid, but since nearly all
+       instructions play with condition codes, it's reasonable. */
+    CC_STATUS_INIT;
+  }		        
+}
+
+/* A C statement to output to the stdio stream STREAM an assembler
+   instruction to assemble a string constant containing the LEN bytes
+   at PTR.  PTR will be a C expression of type `char *' and LEN a C
+   expression of type `int'. */
+void tms9900_output_ascii(FILE* stream, const char* ptr, int len)
+{
+   int i;
+   int in_text = 0;
+   int count = 0;
+   for (i = 0; i < len; i++)
+   {
+      int c = *ptr++;
+      if (ISPRINT(c))
+      {
+         /* End TEXT statement */
+         if (count==64)
+         {
+            fprintf (stream, "'\n");
+            in_text = 0;
+            count = 0;
+         }
+
+         /* Start TEXT statement */
+         if(in_text == 0)
+         {
+            fprintf (stream, "\ttext '");
+            in_text = 1;
+         }
+         putc (c, stream);
+         count++;
+         if(c == '\'') putc (c, stream);
+      }
+      else
+      {
+         /* Close TEXT statement */
+         if(in_text == 1)
+         {
+            fprintf (stream, "'\n");
+            in_text = 0;
+         }
+
+         /* Handle non-printable characters by inlining BYTE constants*/
+         fprintf (stream, "\tbyte %d\n", (unsigned char)c);
+      }
+   }
+
+   /*  If we ran out of input before we had closed the text, close it now */
+   if(in_text == 1)
+      fprintf (stream, "'\n");
+}
+
+void tms9900_expand_prologue (void)
+{
+   /* Find non-volatile registers which need to be saved */
+   int saveregs[MAX_SAVED_REGS];
+   int regcount = tms9900_get_regs_to_save (saveregs);
+   int frame_size = get_frame_size();
+
+   dbgprintf("%s saving regs=%d frame=%d\n", __func__, regcount, frame_size);
+   if (regcount > 2)
+   {
+      /* Allocate stack space for saved regs if more than 2 saved. */
+      /*
+      ai sp, -regs*2        4      14+8+8   = 30
+      mov sp, r0            2      14+8     = 22
+      mov r9 , *r0+         2      14+8+8+8 = 38
+      mov r13, *r0+         2      14+8+8+8 = 38
+      mov r14, *r0+         2      14+8+8+8 = 38
+      mov r15, *r0+         2      14+8+8+8 = 38
+      mov r11, *r0          2      14+8+8+8 = 34
+      ai sp, -frame         4      14+8+8   = 30
+      */
+      /* Emit "ai sp, -regcount*2" */
+      emit_insn(gen_addhi3(stack_pointer_rtx, stack_pointer_rtx, 
+                          GEN_INT(-regcount * 2)));
+
+      /* Copy sp to r0 and use r0 as the dest
+       * with auto-inc */
+
+      /* Emit "mov sp, r0" */
+      emit_insn(gen_movhi(gen_rtx_REG(HImode, HARD_R0_REGNUM),
+                          stack_pointer_rtx));
+
+      for (int i = 0; i < regcount; i++)
+      {
+         /*  Don't postinc if last reg */
+         if(i == regcount-1)
+         {
+            /* Emit "mov Rx, *R0" */
+            emit_insn(gen_movhi(
+            gen_rtx_MEM(HImode, gen_rtx_REG(HImode, HARD_R0_REGNUM)),
+                        gen_rtx_REG(HImode, saveregs[i])));
+         }
+         else
+         {
+            /* Emit "mov Rx, *R0+" */
+            emit_insn(gen_movhi(
+            gen_rtx_MEM(HImode, 
+                        gen_rtx_POST_INC(HImode, 
+                            gen_rtx_REG(HImode, HARD_R0_REGNUM))),
+                        gen_rtx_REG(HImode, saveregs[i])));
+         }
+      }
+   }
+   else
+   {
+      /* Save registers and create stack frame.  Since we currently only save up to 2 regs,
+       * we use dect instead of ai for the sp.  NOTE we must store regs in
+       * reverse order if doing it this way.  */
+      /*
+      dect sp               3      10+6     = 16
+      mov r11, *sp          2      14+8+8+8 = 38
+      dect sp               3      10+6     = 16
+      mov r14, *sp          2      14+8+8+8 = 38
+      ai sp, -frame         4      14+8+8   = 30
+      */
+      for (int i = regcount-1; i >= 0; i--)
+      {
+         dbgprintf("%s save R%d\n", __func__, saveregs[i]);
+         /* Emit "dect sp" */
+         emit_insn(gen_addhi3(stack_pointer_rtx, stack_pointer_rtx, GEN_INT(-2)));
+
+         /* Emit "mov Rx, *SP" */
+         emit_insn(gen_movhi(
+                     gen_rtx_MEM(HImode, stack_pointer_rtx),
+                     gen_rtx_REG(HImode, saveregs[i])));
+      }
+   }
+
+   if(frame_size > 0)
+   {
+      dbgprintf("%s alloc frame %d\n", __func__, frame_size);
+      /* Emit "ai sp, -framesize" */
+      emit_insn(gen_addhi3(stack_pointer_rtx, stack_pointer_rtx, 
+                          GEN_INT(-frame_size)));
+   }
+
+   /* Set frame pointer */
+   if(frame_pointer_needed)
+   {
+      dbgprintf("%s set fp\n", __func__);
+      /* Emit "mov sp, bp" */
+      emit_insn(gen_movhi(gen_rtx_REG(HImode, FRAME_POINTER_REGNUM),
+                          stack_pointer_rtx));
+   }
+
+   dbgprintf("%s done\n", __func__);
+}
+
+void tms9900_expand_epilogue (bool is_sibcall)
+{
+   /*
+   ai sp, frame         4      14+8+8   = 30
+   mov *sp+, r14        2      14+8+8+8 = 38
+   mov *sp+, r11        2      14+8+8+8 = 38
+   */
+
+   /* Find frame size to restore */
+   int frame_size = get_frame_size();
+
+   if(frame_size != 0)
+   {
+      dbgprintf("%s delete frame size=%d\n", __func__, frame_size);
+      /* Emit "ai sp, frame_size" */
+      emit_insn(gen_addhi3(stack_pointer_rtx, stack_pointer_rtx, 
+                           GEN_INT(frame_size)));
+   }
+
+   /* Find non-volatile registers which need to be restored */
+   int saveregs[MAX_SAVED_REGS];
+   int regcount = tms9900_get_regs_to_save (saveregs);
+   int i = 0;
+
+   for (i = 0; i < regcount; i++)
+   {
+      dbgprintf("%s restore R%d\n", __func__, saveregs[i]);
+      /* Emit "mov *SP+, Rx" */
+      emit_insn(gen_movhi(
+         gen_rtx_REG(HImode, saveregs[i]),
+         gen_rtx_MEM(HImode, 
+                     gen_rtx_POST_INC(HImode, stack_pointer_rtx))));
+   }
+   
+   if(!is_sibcall)
+   {
+      // dbgprintf("%s return\n", __func__);
+      /* Emit the return instruction "b *R11" */
+      emit_insn(gen_rtx_UNSPEC(HImode, 
+                               gen_rtvec (1, gen_rtx_REG(HImode, HARD_R11_REGNUM)),
+                               UNSPEC_RETURN));
+   }
+   dbgprintf("%s done\n", __func__);
+}
+
+/* All registers may be used as a base, except R0 or 
+   pseudoregs when we are in strict mod */
+int tms9900_reg_ok_for_base(int strict, rtx reg)
+{
+  return(!strict || 
+         (REGNO(reg) !=0 && REGNO(reg) <= HARD_R15_REGNUM));
+}
+
+/* Determine if the specified address is a valid operand */
+int tms9900_go_if_legitimate_address(enum machine_mode mode ATTRIBUTE_UNUSED, rtx operand, int strict)
+{
+  /* Accept *R0 */
+  if (GET_CODE (operand) == REG &&
+      tms9900_reg_ok_for_base(strict, operand))
+    return 1;
+
+  /* Accept *R0+ */
+  if (GET_CODE (operand) == POST_INC      &&
+      GET_CODE (XEXP (operand, 0)) == REG &&
+      tms9900_reg_ok_for_base(strict, XEXP (operand, 0)))
+    return 1;
+
+  /* Accept @xxxx */
+  if (CONSTANT_ADDRESS_P (operand))
+    return 1;
+
+  /* Accept @xxxx(R0)*/
+  if (GET_CODE (operand) == PLUS            &&
+      GET_CODE (XEXP (operand, 0)) == REG   &&
+      tms9900_reg_ok_for_base(strict, XEXP (operand, 0)) &&
+      CONSTANT_ADDRESS_P (XEXP (operand, 1)))
+    return 1;
+
+  /* Accept @(symbol+xxxx)(R0)*/
+/*
+  if(GET_CODE (operand) == PLUS )
+  {
+    if(GET_CODE(XEXP(operand,0)) == MEM)
+    {
+      rtx op = XEXP(operand,0);
+      op = XEXP(op, 0);
+      if(GET_CODE (op) == PLUS             &&
+         GET_CODE (XEXP (op, 0)) == REG    &&
+         tms9900_reg_ok_for_base(strict, XEXP (op, 0))  &&
+         CONSTANT_ADDRESS_P (XEXP (op, 1)) &&
+         CONSTANT_ADDRESS_P(XEXP(operand, 1)))
+      {
+        return 1;
+      }
+    }
+  }
+*/
+  /* Anything else is invalid */
+// printf("MGB not legit add : ");
+// print_inline_rtx (stdout, operand, 0);
+// printf("\n");
+  return 0;
+}
+
+
+/* All aggregate types or types larger than four bytes which are
+   to be passsed by value are silently copied to the stack and 
+   then passed by reference. */
+static bool
+tms9900_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,
+                       enum machine_mode mode ATTRIBUTE_UNUSED,
+                       const_tree type, bool named ATTRIBUTE_UNUSED)
+{
+  unsigned int size;
+  if (type)
+    {
+      if (AGGREGATE_TYPE_P (type))
+        return(true);
+      size = int_size_in_bytes (type);
+    }
+  else
+    size = GET_MODE_SIZE (mode);
+  return(size > 4);
+}
+
+
+/* Output a difference of two labels that will be an assembly time
+   constant if the two labels are local.  (.long lab1-lab2 will be
+   very different if lab1 is at the boundary between two sections; it
+   will be relocated according to the second section, not the first,
+   so one ends up with a difference between labels in different
+   sections, which is bad in the dwarf2 eh context for instance.)  */
+void
+tms9900_asm_output_dwarf_delta (FILE *file, int size,
+                               const char *lab1, const char *lab2)
+{
+  int islocaldiff = (lab1[0] == '*' && lab1[1] == 'L'
+                     && lab2[0] == '*' && lab2[1] == 'L');
+  const char *directive = "data";
+  islocaldiff=1;
+  if(size > 2) fprintf(file,"\n\tdata 0\n",size);
+  if (islocaldiff)
+    fprintf (file, "\t.set L$set$%d,", tms9900_dwarf_label_counter);
+  else
+    fprintf (file, "\t%s\t", directive);
+  assemble_name_raw (file, lab1);
+  fprintf (file, "-");
+  assemble_name_raw (file, lab2);
+  if (islocaldiff)
+    fprintf (file, "\n\t%s L$set$%d", directive, tms9900_dwarf_label_counter++);
+}
+
+
+/* Output an offset from a label for use in a dwarf record */
+void tms9900_asm_output_dwarf_offset (FILE *file, int size, const char * lab,
+                                section *base)
+{
+  char sname[64];
+  sprintf(sname, "%s",&base->named.name[0]);
+  tms9900_asm_output_dwarf_delta (file, size, lab, sname);
+}
+
+
+/* Output an integer value of a specified size and alignemnt */
+static bool
+tms9900_asm_integer(rtx x, unsigned int size, int aligned_p)
+{
+  if(!aligned_p)
+  {
+    if(GET_CODE(x) == CONST_INT)
+    {
+      unsigned int value = INTVAL(x);
+      int i;
+      fprintf(asm_out_file, "\tbyte\t");
+      for(i = size-1; i>=1; i--)
+      {
+        fprintf(asm_out_file, "0x%X,", (value >> (i*8)) & 0xFF);        
+      }
+      fprintf(asm_out_file, "0x%X", value & 0xFF);
+      return true;
+    }
+  }
+  return default_assemble_integer(x,size,1);
+}
+
+
+//==================================================================
+// Code for tms9900_subreg pass
+
+
+#include "tree-pass.h"
+#include "basic-block.h"
+#include "rtl.h"
+
+static void
+tms9900_extract_subreg(rtx insn, rtx arg, rtx* parg)
+{
+  dbgprintf("%s\n", __func__);
+  if(BINARY_P(arg))
+  {
+    dbgprintf("%s recurse\n", __func__);
+    /* Recurse until we find a leaf expression */
+    tms9900_extract_subreg(insn, XEXP(arg,0), &XEXP(arg,0));
+    tms9900_extract_subreg(insn, XEXP(arg,1), &XEXP(arg,1));
+  }
+  else
+
+  {
+    if(GET_CODE(arg) == SUBREG && GET_MODE(arg) == QImode)
+    {
+      dbgprintf ("%s creating extract\n", __func__);
+      /* Found a subreg expression we need to extract.
+         Place it in a seperate instruction before this one */
+      rtx temp_reg = gen_reg_rtx(QImode);
+      rtx extract = gen_rtx_SET(QImode, temp_reg, arg);
+
+      if(dump_file)
+      {
+        fprintf(dump_file, "\nModifying insn %d, extracting subreg to new instruction %d\n",
+                INSN_UID(insn), INSN_UID(extract));
+      }
+
+      // print_inline_rtx (stdout, extract, 0);
+      /* Replace expression in instruction with our new temp register */
+      memcpy(parg, &temp_reg, sizeof(rtx));
+      emit_insn_before(extract, insn);
+
+      if(dump_file)
+      {
+        fprintf(dump_file, "New sequence:\n");
+        print_rtl_single(dump_file, extract);
+        print_rtl_single(dump_file, insn);
+      }
+    }
+  }
+}
+
+static bool
+gate_tms9900_subreg (void)
+{
+  return true;
+}
+
+static unsigned int
+tms9900_subreg (void)
+{
+  dbgprintf("%s disabled\n", __func__);
+  return 0;
+  basic_block bb;
+  rtx insn;
+
+  FOR_EACH_BB (bb)
+    FOR_BB_INSNS (bb, insn)
+    {
+    dbgprintf("%s looping\n", __func__);
+    if (INSN_P (insn))
+    {
+      dbgprintf("%s get single_set\n", __func__);
+      rtx set=single_set (insn);
+      if(set !=NULL)
+      {
+        /* We only need to handle cases where there may be
+           subreg expressions in an operation in the source
+           argument. Unary expressions are already handled
+           in the machine description. */
+        rtx src=SET_SRC(set);
+        if(BINARY_P(src))
+        {
+          tms9900_extract_subreg(insn, XEXP(src,0), &XEXP(src,0));
+          tms9900_extract_subreg(insn, XEXP(src,1), &XEXP(src,1));
+        }
+      }
+    }
+    else
+      dbgprintf("%s not INSN_P\n", __func__);
+    }
+
+  dbgprintf("%s done\n", __func__);
+  return 0;
+}
+
+
+struct rtl_opt_pass pass_tms9900_subreg =
+{
+ {
+  RTL_PASS,
+  "tms9900_subreg",                     /* name */
+  gate_tms9900_subreg,                  /* gate */
+  tms9900_subreg,                       /* execute */
+  NULL,                                 /* sub */
+  NULL,                                 /* next */
+  0,                                    /* static_pass_number */
+  0,                                    /* tv_id */
+  0,                                    /* properties_required */
+  0,                                    /* properties_provided */
+  0,                                    /* properties_destroyed */
+  0,                                    /* todo_flags_start */
+  TODO_dump_func |
+  TODO_ggc_collect                      /* todo_flags_finish */
+ }
+};
+
+//==================================================================
+// Code for tms9900_postinc pass
+
+/* last instruction to use target register */
+struct reg_last_used {
+  rtx insn;
+  int regnum;
+  int is_deref;
+  int mode;
+  rtx parent;
+  int argnum;
+};
+
+static struct reg_last_used reg_last_insn[1024] = {0};
+
+
+static bool
+gate_tms9900_postinc(void)
+{
+  return true;
+}
+
+
+/* Find an instruction which uses a form like *(register+constant) we could 
+   merge via pointer postincrement in an earlier instruction.*/
+static void
+tms9900_find_merge_insn(rtx insn, rtx parent, int argnum, rtx arg)
+{
+  if(MEM_P(arg))
+  {
+    rtx expr = XEXP(arg,0);
+    if(GET_CODE(expr) == PLUS)
+    {
+      rtx val1 = XEXP(expr,0);
+      rtx val2 = XEXP(expr,1);
+      int offset;
+      int regnum = -1;
+      rtx reg;
+
+      /* Isolate regnum and offset in sum */
+      if(CONST_INT_P(val1) && REG_P(val2))
+      {
+         offset = INTVAL(val1);
+         regnum = REGNO(val2);
+         reg = val2;
+      }
+      else if(CONST_INT_P(val2) && REG_P(val1))
+      {
+         offset = INTVAL(val2);
+         regnum = REGNO(val1);
+         reg = val1;
+      }
+
+      if((regnum >= 0) && 
+         (offset == 2 || offset == 1) &&
+         (find_regno_note(insn, REG_DEAD, regnum)))
+      {
+        /* Found an indexed address with a small offset, investigate further */
+        struct reg_last_used *last = &reg_last_insn[regnum];
+        if(dump_file)
+        {
+          fprintf(dump_file,"\n\nPossible merge candidate:\n");
+          print_rtl_single(dump_file, insn);
+          // fprintf(dump_file,"\nLast use of reg %d was in insn %d:\n", regnum, INSN_UID(last->insn));
+          print_rtl_single(dump_file, last->insn);
+        }
+
+        if((last->is_deref) && (GET_MODE_SIZE(last->mode) == offset))
+        {
+          /* Modify previous instruction to use postincrement */
+          rtx temp_inc = gen_rtx_POST_INC(last->mode, reg);
+          rtx temp_arg = gen_rtx_MEM(last->mode,temp_inc); 
+          memcpy(XEXP(last->parent, last->argnum), temp_arg, rtx_size(temp_arg));
+
+          /* Modify this instruction to remove index */
+          temp_arg = gen_rtx_MEM(last->mode,reg); 
+          memcpy(XEXP(parent, argnum), temp_arg, rtx_size(temp_arg));
+
+          if(dump_file) 
+          {
+            fprintf(dump_file,"\nModified instruction %d:\n",INSN_UID(last->insn));
+            print_rtl_single(dump_file,last->insn);
+          }
+        }
+        else if(dump_file) fprintf(dump_file, "\nCannot merge\n");
+        return;
+      }
+    }
+  }
+
+  if(BINARY_P(arg))
+  {
+    /* This is a binary expression, check the children */
+    tms9900_find_merge_insn(insn, arg, 0, XEXP(arg,0));
+    tms9900_find_merge_insn(insn, arg, 1, XEXP(arg,1));
+  }
+  else
+  {
+    /* This is a leaf expression. Note the register used here for later */
+    int is_deref = 0;
+    if(MEM_P(arg))
+    {
+      arg = XEXP(arg,0);
+      is_deref = 1;
+    }
+    if(REG_P(arg))
+    {
+      int index = REGNO(arg);
+      reg_last_insn[index].insn = insn;
+      reg_last_insn[index].is_deref = is_deref;
+      reg_last_insn[index].mode = GET_MODE(arg);     
+      reg_last_insn[index].regnum = REGNO(arg);
+      reg_last_insn[index].parent = parent;
+      reg_last_insn[index].argnum = argnum;
+    }
+  }
+}
+
+
+static unsigned int
+tms9900_postinc (void)
+{
+  basic_block bb;
+  rtx insn;
+  int i;
+
+  dbgprintf("%s\n", __func__);
+  FOR_EACH_BB (bb)
+  {
+    memset(reg_last_insn, 0, sizeof(reg_last_insn));
+    FOR_BB_INSNS (bb, insn)
+    {
+  dbgprintf("%s loop\n", __func__);
+      if (INSN_P (insn))
+      {
+        rtx set=single_set (insn);
+        if(set !=NULL)
+        {
+          /* Look for memory references of the form *(costant+reg) */
+          tms9900_find_merge_insn(insn, set, 0, SET_DEST(set));
+          tms9900_find_merge_insn(insn, set, 1, SET_SRC(set));
+        }
+      }
+    }
+  }
+  dbgprintf("%s done\n", __func__);
+  return 0;
+}
+
+
+struct rtl_opt_pass pass_tms9900_postinc =
+{
+ {
+  RTL_PASS,
+  "tms9900_postinc",                    /* name */
+  gate_tms9900_postinc,                 /* gate */
+  tms9900_postinc,                      /* execute */
+  NULL,                                 /* sub */
+  NULL,                                 /* next */
+  0,                                    /* static_pass_number */
+  0,                                    /* tv_id */
+  0,                                    /* properties_required */
+  0,                                    /* properties_provided */
+  0,                                    /* properties_destroyed */
+  0,                                    /* todo_flags_start */
+  TODO_dump_func |
+  TODO_ggc_collect                      /* todo_flags_finish */
+ }
+};
+
+// MGB additions start here - mostly for debug
+
+/*  Check if there is a byte offset correction needed for an operand.  If
+ *  operand is a register and REGNO matches ORIGINAL_REGNO and offset is non
+ *  zero then a correction is needed.  -1 indicates an extend is needed, +1
+ *  indicates a truncate is needed. */
+extern bool tms9900_operand_subreg_offset (rtx operand, int mode)
+{
+  /*  If the source operand is not a register or does not have an offset of
+   *  minus 1 byte then no action required */
+  // if (!REG_P (operand) || (REG_OFFSET (operand) % 2) == 0)
+  // if (!REG_P (operand) || REG_OFFSET (operand) != -1)
+  if (!REG_P (operand) || REG_OFFSET (operand) == 0)
+    return false;
+
+  int offset = REG_OFFSET (operand);
+
+  // Bypass debug flag and put direct to file
+  // tms9900_inline_debug ("; reg/reg=%d/%d expr=%d\n", REGNO(operand),
+  fprintf (asm_out_file, "; SUBR off=%d mode=%s reg/reg=%d/%d\n",
+           REG_OFFSET (operand), GET_MODE_NAME (mode),
+           REGNO(operand), ORIGINAL_REGNO(operand));
+
+  if (mode == QImode && offset != 1)
+    return false;
+
+  if (mode == HImode && offset != -1)
+    return false;
+
+  /*  If the source register is not the original register, and the original is a
+   *  mem expression, then the offset refers to something else, so we can ignore
+   *  this case */
+  if (ORIGINAL_REGNO (operand) != REGNO (operand))
+      //  && REG_EXPR (operand))
+  {
+    tms9900_debug_operands ("REG_EXPR", operand, NULL, 0);
+    return false;
+  }
+
+  // tms9900_inline_debug ("; correct required\n");
+  fprintf (asm_out_file, "; SUBR correction required\n");
+  /*  Correction is needed */
+  return true;
+}
+
+/* Determine if it's legal to put X into the constant pool.  This
+   is not possible if X contains the address of a symbol that is
+   not constant (TLS) or not known at final link time (PIC).
+
+   MGB : This is probably overkill for us as we can't generate PIC code and
+   don't have threads but including it here for completeness 
+*/
+
+static bool
+tms9900_cannot_force_const_mem (rtx x)
+{
+  // printf("%s code=%s\n", __func__, GET_RTX_NAME(GET_CODE(x)));
+  switch (GET_CODE (x))
+    {
+    case CONST_INT:
+    case CONST_DOUBLE:
+    case CONST_VECTOR:
+    case LABEL_REF:
+    case SYMBOL_REF:
+      /* Accept all non-symbolic constants.  */
+      return false;
+#if 0
+    case LABEL_REF:
+      /* Labels are OK iff we are non-PIC.  */
+      return flag_pic != 0;
+
+    case SYMBOL_REF:
+      /* 'Naked' TLS symbol references are never OK,
+	 non-TLS symbols are OK iff we are non-PIC.  */
+      if (SYMBOL_REF_TLS_MODEL (x))
+	return true;
+      else
+	return flag_pic != 0;
+#endif
+    case CONST:
+      return tms9900_cannot_force_const_mem (XEXP (x, 0));
+    case PLUS:
+    case MINUS:
+      return tms9900_cannot_force_const_mem (XEXP (x, 0))
+         || tms9900_cannot_force_const_mem (XEXP (x, 1));
+    case UNSPEC:
+      return true;
+    default:
+      gcc_unreachable ();
+    }
+}
+
+/* Determine if a given RTX is a valid constant.  We already know this
+   satisfies CONSTANT_P.  */
+
+bool
+tms9900_legitimate_constant_p (rtx x)
+{
+  // printf ("%s x=%s\n", __func__, GET_RTX_NAME(GET_CODE(x)));
+  return true;
+}
+
+/* Determine if a given RTX is a valid constant address.  */
+
+bool
+tms9900_constant_address_p (rtx x)
+{
+  // printf ("%s x=%s\n", __func__, GET_RTX_NAME(GET_CODE(x)));
+  switch (GET_CODE (x))
+    {
+    case LABEL_REF:
+    case CONST_INT:
+    case HIGH:
+      return true;
+
+    case CONST:
+    case SYMBOL_REF:
+      return tms9900_legitimate_constant_p (x);
+
+    default:
+      return false;
+    }
+}
+
+#include <stdlib.h>
+#include <stdarg.h>
+
+extern void tms9900_inline_debug (const char *fmt,...)
+{
+#ifndef TMS9900_INLINE_DEBUG
+    return;
+#endif
+    if (!TARGET_TI99_INLINE_RTL)
+        return;
+
+    va_list ap;
+
+    va_start (ap, fmt);
+    vfprintf (asm_out_file, fmt, ap);
+    va_end (ap);
+}
+
+extern void tms9900_debug_operands (const char *name, rtx insn, rtx ops[], int count)
+{
+#ifndef TMS9900_INLINE_DEBUG
+    return;
+#endif
+
+    if (!TARGET_TI99_INLINE_RTL)
+        return;
+
+    static int refcount;
+    if (insn)
+    {
+        fprintf(asm_out_file, "\n; %s-%d : ", name, INSN_UID(insn));
+        print_inline_rtx (asm_out_file, insn, 0);
+        fprintf(asm_out_file, "\n\n");
+    }
+    else
+    {
+        fprintf(asm_out_file, "\n; %s-expand-%d\n", name, ++refcount);
+        for (int i = 0; i < count; i++)
+        {
+            fprintf(asm_out_file, "; OP%d : ", i);
+
+            /* For print_inline_rtx to prefix its output with a comment indicator.
+             * This is similar to passing -dP to gcc but more specific to our needs
+             */
+            extern const char *print_rtx_head;
+            print_rtx_head = "; ";
+
+            print_inline_rtx (asm_out_file, ops[i], 0);
+            fprintf (asm_out_file, "code=[%s:%s]\n", GET_RTX_NAME(GET_CODE(ops[i])),
+                     GET_MODE_NAME (GET_MODE (ops[i])));
+        }
+    }
+}
+
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/tms9900.h gcc-4.4.0/gcc/config/tms9900/tms9900.h
--- gcc-4.4.0-orig/gcc/config/tms9900/tms9900.h	2023-12-23 10:48:53.513244386 +0000
+++ gcc-4.4.0/gcc/config/tms9900/tms9900.h	2024-02-23 10:24:17.493321623 +0000
@@ -0,0 +1,1241 @@
+/* Definitions of target machine for GNU compiler.
+   Texas Instruments TMS9900
+   Copyright (C) 2009
+
+Copyright 2009 Eric Welser (EMW)
+Copyright 2023 Mark Burkley (MGB)
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.
+*/
+
+/*****************************************************************************
+**
+** Controlling the Compilation Driver, `gcc'
+**
+*****************************************************************************/
+
+#undef ENDFILE_SPEC
+
+/* Define this for front-ended changes */
+#define TMS9900
+
+/* Options to pass to the assembler */
+#ifndef ASM_SPEC
+#define ASM_SPEC ""
+#endif
+
+/* Options for the linker. 
+   We need to tell the linker the target elf format.
+   This can be overridden by -Wl option of gcc.  */
+#ifndef LINK_SPEC
+#define LINK_SPEC "-m tms9900"
+#endif
+
+/* More linker options, these are used at the beginning of the command */
+#undef STARTFILE_SPEC
+/*#define STARTFILE_SPEC "crt1%O%s"*/
+#define STARTFILE_SPEC ""
+
+/* More linker options, used at the end of the command string */
+#ifndef LIB_SPEC
+#define LIB_SPEC       ""
+#endif
+
+/* Options to pass to CC1 and other language front ends */
+#ifndef CC1_SPEC
+#define CC1_SPEC       ""
+#endif
+
+/* Options to pass to the C Preprocessor */
+#ifndef CPP_SPEC
+#define CPP_SPEC ""
+#endif
+
+// MGB TODO
+// Setting to 0 or 1 makes no difference to string constants - they are always
+// emitted before the function.  Int consts are currently never emitted but it
+// doesn't logically make sense to emit them before as they haven't been defined
+// yet???  They have if use expand or split so undefning now.
+// #define CONSTANT_POOL_BEFORE_FUNCTION	0
+
+/* Names to predefine in the preprocessor for this target machine.  */
+#define TARGET_CPU_CPP_BUILTINS()		\
+  do						\
+    {						\
+      builtin_define_std ("tms9900");		\
+    }						\
+  while (0)
+
+/* As an embedded target, we have no libc.  */
+//#ifndef inhibit_libc
+//#  define inhibit_libc
+//#endif
+
+/* Forward type declaration for prototypes definitions.
+   rtx_ptr is equivalent to rtx. Can't use the same name.  */
+struct rtx_def;
+typedef struct rtx_def *rtx_ptr;
+
+union tree_node;
+typedef union tree_node *tree_ptr;
+
+/* We can't declare enum machine_mode forward nor include 'machmode.h' here.
+   Prototypes defined here will use an int instead. It's better than no
+   prototype at all.  */
+typedef int enum_machine_mode;
+
+/*****************************************************************************
+**
+** Run-time Target Specification
+**
+*****************************************************************************/
+
+/* Run-time compilation parameters selecting different hardware subsets.  */
+
+extern short *reg_renumber;	/* def in local_alloc.c */
+
+#define TARGET_OP_TIME		(optimize && optimize_size == 0)
+#define TARGET_RELAX            (TARGET_NO_DIRECT_MODE)
+
+/* Default target_flags if no switches specified.  */
+#ifndef TARGET_DEFAULT
+# define TARGET_DEFAULT		0
+#endif
+
+#define OVERRIDE_OPTIONS override_options ()
+
+/* Define this macro as a C expression for the initializer of an
+   array of string to tell the driver program which options are
+   defaults for this target and thus do not need to be handled
+   specially when using `MULTILIB_OPTIONS'.  */
+#ifndef MULTILIB_DEFAULTS
+# define MULTILIB_DEFAULTS { "tms9900" }
+#endif
+
+/* Print subsidiary information on the compiler version in use.  */
+#define TARGET_VERSION	fprintf (stderr, " (TMS9900)")
+
+
+/* Target machine storage layout */
+
+/* Define this as 1 if most significant byte of a word is the lowest numbered.  */
+#define BYTES_BIG_ENDIAN 	1
+
+/* Define this as 1 if most significant bit is lowest numbered
+   in instructions that operate on numbered bit-fields.  */
+#define BITS_BIG_ENDIAN         1
+
+/* Define this as 1 if most significant word of a multiword number is lowest numbered.  */
+#define WORDS_BIG_ENDIAN 	1
+
+/* Width of a word, in units (bytes).  */
+#define UNITS_PER_WORD		2
+
+/* Definition of size_t.  This is really an unsigned short as the
+   TMS9900 only handles a 64K address space.  */
+#define SIZE_TYPE               "short unsigned int"
+
+/* A C expression for a string describing the name of the data type
+   to use for the result of subtracting two pointers.  The typedef
+   name `ptrdiff_t' is defined using the contents of the string.
+   The TMS9900 only has a 64K address space.  */
+#define PTRDIFF_TYPE            "short int"
+
+/* Allocation boundary (bits) for storing pointers in memory.  */
+#define POINTER_BOUNDARY	16
+
+/* Normal alignment required for function parameters on the stack, in bits.
+   This can't be less than BITS_PER_WORD */
+#define PARM_BOUNDARY		(BITS_PER_WORD)
+
+/* Boundary (bits) on which stack pointer should be aligned.  */
+#define STACK_BOUNDARY		16
+
+/* Allocation boundary (bits) for the code of a function.  */
+#define FUNCTION_BOUNDARY	16
+
+/* Biggest alignment which, if violated, may cause a fault */
+#define BIGGEST_ALIGNMENT	16
+
+/* Alignment of field after `int : 0' in a structure.  */
+#define EMPTY_FIELD_BOUNDARY	16
+
+/* Every structure's size must be a multiple of this.  */
+#define STRUCTURE_SIZE_BOUNDARY 16
+
+/* Define this as 1 if instructions will fail to work if given data not
+   on the nominal alignment.  If instructions will merely go slower
+   in that case, do not define this macro.  */
+#define STRICT_ALIGNMENT	1
+
+/* An integer expression for the size in bits of the largest integer
+   machine mode that should actually be used.  All integer machine modes of
+   this size or smaller can be used for structures and unions with the
+   appropriate sizes.  */
+#define MAX_FIXED_MODE_SIZE	32
+
+/* target machine storage layout */
+
+/* Size (bits) of the type "int" on target machine */
+#define INT_TYPE_SIZE           16
+
+/* Size (bits) of the type "short" on target machine */
+#define SHORT_TYPE_SIZE		16
+
+/* Size (bits) of the type "long" on target machine */
+#define LONG_TYPE_SIZE		32
+
+/* Size (bits) of the type "long long" on target machine */
+#define LONG_LONG_TYPE_SIZE     64
+
+/* A C expression for the size in bits of the type `float' on the
+   target machine. If you don't define this, the default is one word.
+   Don't use default: a word is only 16.
+   MGB let's see if we can make floats and doubles the same size
+   MGB doesn't work - gcc assumes sizeof float == sizeof SI ? */
+#define FLOAT_TYPE_SIZE         64
+
+/* A C expression for the size in bits of the type double on the target
+   machine. If you don't define this, the default is two words.
+   Be IEEE compliant.  */
+#define DOUBLE_TYPE_SIZE        64
+
+#define LONG_DOUBLE_TYPE_SIZE   64
+
+/*  We don't have "floats" as in 32-bit floating point values (SFmode) but we do
+ *  have "doubles" as in 64-bit (DFmode). */
+#define LIBGCC2_HAS_SF_MODE 0
+#define LIBGCC2_HAS_DF_MODE 1
+
+/* Define this as 1 if `char' should by default be signed; else as 0.  */
+#define DEFAULT_SIGNED_CHAR	1
+
+/* A C expression for a string describing the name of the data type
+   to use for wide characters.  The typedef name `wchar_t' is defined
+   using the contents of the string.
+   
+   Define these to avoid dependence on meaning of `int'.
+   Note that WCHAR_TYPE_SIZE is used in cexp.y,
+   where TARGET_SHORT is not available.  */
+#define WCHAR_TYPE              "short int"
+#define WCHAR_TYPE_SIZE         16
+
+/* Standard register usage.  */
+
+#define HARD_REG_SIZE           (2)
+
+#define REGS_PER_WORD (UNITS_PER_WORD / HARD_REG_SIZE)
+
+/* Assign names to real TMS9900 registers. */
+#define HARD_R0_REGNUM		0
+#define HARD_R1_REGNUM		1
+#define HARD_R2_REGNUM		2
+#define HARD_R3_REGNUM		3
+#define HARD_R4_REGNUM		4
+#define HARD_R5_REGNUM		5
+#define HARD_R6_REGNUM		6
+#define HARD_R7_REGNUM		7
+#define HARD_R8_REGNUM		8
+#define HARD_R9_REGNUM		9
+#define HARD_R10_REGNUM		10
+#define HARD_R11_REGNUM		11
+#define HARD_R12_REGNUM		12
+#define HARD_R13_REGNUM		13
+#define HARD_R14_REGNUM		14
+#define HARD_R15_REGNUM		15
+
+/* Shift count register */
+#define HARD_SC_REGNUM		HARD_R0_REGNUM
+/* Base pointer */
+#define HARD_BP_REGNUM		HARD_R9_REGNUM
+/* Stack pointer */
+#define HARD_SP_REGNUM		HARD_R10_REGNUM
+/* Old PC after BL instruction */
+#define HARD_LR_REGNUM		HARD_R11_REGNUM
+/* static chain */
+#define HARD_CB_REGNUM		HARD_R12_REGNUM
+/* Arg pointer */
+#define HARD_AP_REGNUM		HARD_R13_REGNUM
+
+/* How to refer to registers in assembler output.  This sequence is indexed
+   by compiler's hard-register-number (see above). */
+#define REGISTER_NAMES \
+{ "r0",  "r1", "r2",  "r3",  "r4",  "r5",  "r6",  "r7",  \
+  "r8",  "r9", "r10", "r11", "r12", "r13", "r14", "r15"}
+
+/* Number of actual hardware registers. The hardware registers are assigned
+   numbers for the compiler from 0 to just below FIRST_PSEUDO_REGISTER. 
+   All registers that the compiler knows about must be given numbers, even
+   those that are not normally considered general registers.  */
+#define FIRST_PSEUDO_REGISTER	(16)
+
+/* NOTE - BP (R9) is not a fixed register and may be used as a general
+ * register by functions that do not require a stack frameo
+ */
+/* 1 for registers that have pervasive standard uses and are not available
+ * for the register allocator.  */
+#define FIXED_REGISTERS \
+  {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0}
+/* SC 1  2  3  4  5  6  7  8  BP SP LR CB AP 14 15*/
+
+/* MGB It seemed excessive to always preserve R13,R14,R15 as these will only
+ * have values to be saved if we were invoked by a BLWP which is never emitted
+ * by this backend.  I have removed them from the list.  If someone is writing
+ * an ISR / DSR which is invoked by a BLWP then we can ask them to save
+ * R13/R14/R15 themselves.
+ *
+ * It also seems counter-intuitive that LR should be identified as a call reg
+ * but gcc/reginfo.c will assert if any register is fixed and not a call reg.
+ *
+ * MGB JAN-24 I'm adding back in R12 thru R15 as call used regs.  It actually
+ * seems to allow gcc to generate better code - why is that? TODO
+ */
+/* 0 for registers which must be preserved across function call boundaries */
+#define CALL_USED_REGISTERS \
+  {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0}
+/* SC 1  2  3  4  5  6  7  8  BP SP LR CB AP 14 15*/
+
+/* Define this macro to change register usage conditional on target flags. */
+#define CONDITIONAL_REGISTER_USAGE 
+
+/* List the order in which to allocate registers.  Each register must be
+   listed once, even those in FIXED_REGISTERS.  */
+#define REG_ALLOC_ORDER	\
+   {HARD_R1_REGNUM, HARD_R2_REGNUM, HARD_R3_REGNUM, HARD_R4_REGNUM,\
+    HARD_R5_REGNUM, HARD_R6_REGNUM, HARD_R7_REGNUM, HARD_R8_REGNUM,\
+    HARD_R14_REGNUM, HARD_R15_REGNUM, HARD_R12_REGNUM, HARD_SC_REGNUM,\
+    HARD_AP_REGNUM, HARD_BP_REGNUM, HARD_LR_REGNUM, HARD_SP_REGNUM}
+
+/* A C expression for the number of consecutive hard registers,
+   starting at register number REGNO, required to hold a value of
+   mode MODE.  */
+#define HARD_REGNO_NREGS(REGNO, MODE) \
+   ((GET_MODE_SIZE (MODE) + HARD_REG_SIZE - 1) / HARD_REG_SIZE)
+
+/* Value is 1 if hard register REGNO (or starting with REGNO) can hold a value of machine-mode MODE
+ */
+#define HARD_REGNO_MODE_OK(REGNO, MODE) \
+   (!(MODE == SImode && REGNO==HARD_R15_REGNUM))
+  
+/* A C expression that is nonzero if hard register number REGNO2 can be
+   considered for use as a rename register for REGNO1 */
+#define HARD_REGNO_RENAME_OK(REGNO1,REGNO2) 1
+
+/* Value is 1 if it is a good idea to tie two pseudo registers when one has
+   mode MODE1 and one has mode MODE2.  If HARD_REGNO_MODE_OK could produce
+   different values for MODE1 and MODE2, for any hard reg, then this must be
+   0 for correct output. */
+#define MODES_TIEABLE_P(MODE1, MODE2) 0
+
+/* Define the classes of registers for register constraints in the
+   machine description.  Also define ranges of constants.
+
+   One of the classes must always be named ALL_REGS and include all hard regs.
+   If there is more than one class, another class must be named NO_REGS
+   and contain no registers.
+
+   The classes must be numbered in nondecreasing order; that is,
+   a larger-numbered class must never be contained completely
+   in a smaller-numbered class.
+
+   For any two classes, it is very desirable that there be another
+   class that represents their union.
+*/
+enum reg_class
+{
+  NO_REGS,
+  FIXED_REGS,     /* Register used for fixed purposes (LR, SP) */
+  BASE_REGS,      /* Registers which may be used as a memory base */
+  ALL_REGS,       /* All registers, including fakes */
+  LIM_REG_CLASSES
+};
+
+/* The name GENERAL_REGS must be the name of a class (or an alias for
+   another name such as ALL_REGS).  This is the class of registers
+   that is allowed by "g" or "r" in a register constraint.
+   Also, registers outside this class are allocated only when
+   instructions express preferences for them. */
+#define GENERAL_REGS	ALL_REGS
+
+/* The number of distict register classes */
+#define N_REG_CLASSES	(int) LIM_REG_CLASSES
+
+/* Give names of register classes as strings for dump file.  */
+#define REG_CLASS_NAMES \
+{ "NO_REGS",       \
+  "FIXED_REGS",    \
+  "BASE_REGS",     \
+  "ALL_REGS" }
+
+/* An initializer containing the contents of the register classes,
+   as integers which are bit masks.  The Nth integer specifies the
+   contents of class N.  The way the integer MASK is interpreted is
+   that register R is in the class if `MASK & (1 << R)' is 1.  */
+
+/*--------------------------------------------------------------
+   SC      0x00000001
+   R1      0x00000002
+   R2      0x00000004
+   R3      0x00000008
+   R4      0x00000010
+   R5      0x00000020
+   R6      0x00000040
+   R7      0x00000080
+   R8      0x00000100
+   BP      0x00000200
+   SP      0x00000400
+   LR      0x00000800
+   R12     0x00001000
+   R13     0x00002000
+   R14     0x00004000
+   R15     0x00008000
+--------------------------------------------------------------*/
+
+#define REG_CLASS_CONTENTS \
+/* NO_REGS       */  {{ 0x00000000 }, \
+/* FIXED_REGS    */   { 0x00000A01 }, /* SC,LR,SP */ \
+/* BASE_REGS     */   { 0x0000FFFE }, \
+/* ALL_REGS      */   { 0x0000FFFF }}
+
+/* Set up a C expression whose value is a register class containing hard
+   register REGNO */
+#define REGNO_REG_CLASS(REGNO) \
+   (REGNO == HARD_SC_REGNUM  ? FIXED_REGS : \
+    REGNO == HARD_LR_REGNUM  ? FIXED_REGS   : \
+    REGNO == HARD_SP_REGNUM  ? FIXED_REGS   : \
+    REGNO <= HARD_R15_REGNUM ? ALL_REGS   : \
+    NO_REGS)
+
+/* Get register class from a letter in the machine description. */
+#define REG_CLASS_FROM_LETTER(C) \
+   ((C) == 'T' ? ALL_REGS   : \
+    NO_REGS)
+
+/* A C expression that places additional restrictions of the register
+   class to use when it is necessary to copy value X into a register
+   in class CLASS. Some values may require the use of a more restrictive
+   class.*/
+#define PREFERRED_RELOAD_CLASS(X,CLASS)	CLASS
+
+/* Return the maximum number of consecutive registers needed to represent
+   mode MODE in a register of class CLASS.  */
+#define CLASS_MAX_NREGS(CLASS, MODE) \
+   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)
+
+/* The letters I, J, K, L and M in a register constraint string
+   can be used to stand for particular ranges of immediate operands.
+   This macro defines what the ranges are.
+   C is the letter, and VALUE is a constant value.
+   Return 1 if VALUE is in the range specified by C.
+
+   'I' is for 32-bit value xxxx0000
+   'J' is for 32-bit value 0000xxxx
+   'K' is for 32-bit value xxxxxxxx
+   'L' is for 2 or -2
+   'M' is for -1
+   'N' is for 1
+   'O' is for 0
+   'P' is for 16-bit value 00ff
+*/
+#define CONST_OK_FOR_LETTER_P(VALUE, C) \
+  ((C) == 'L' ? ((VALUE) == 2 || (VALUE) == -2): \
+   (C) == 'M' ? ((VALUE) == -1): \
+   (C) == 'N' ? ((VALUE) == 1): \
+   (C) == 'O' ? ((VALUE) == 0): \
+   (C) == 'P' ? ((VALUE) == 0x00ff): \
+   (C) == 'I' ? ((VALUE) & 0xffff0000) == 0: \
+   (C) == 'J' ? ((VALUE) & 0x0000ffff) == 0: \
+   (C) == 'K' ? (((VALUE) & 0xffff0000) != 0 && \
+		 ((VALUE) & 0x0000ffff) != 0): \
+   0)
+
+/* Similar, but for floating constants, and defining letters G and H.
+
+   `G' is for 0.0.  */
+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \
+  ((C) == 'G' ? (GET_MODE_CLASS (GET_MODE (VALUE)) == MODE_FLOAT \
+		 && VALUE == CONST0_RTX (GET_MODE (VALUE))) : 0) 
+
+/* Letters in the range `Q' through `U' may be defined in a
+   machine-dependent fashion to stand for arbitrary operand types. 
+   The machine description macro `EXTRA_CONSTRAINT' is passed the
+   operand as its first argument and the constraint letter as its
+   second operand.
+
+   This macro returns 1 if the provided CODE matches the provided OP
+
+   `Q'	is for memory references that require an extra word after the opcode.
+   `R'	is for memory references which are encoded within the opcode.  */
+#define EXTRA_CONSTRAINT(OP,CODE)					\
+  ((GET_CODE (OP) != MEM) ? 0						\
+   : !legitimate_address_p (GET_MODE (OP), XEXP (OP, 0)) ? 0		\
+   : ((CODE) == 'Q') ? (tms9900_address_type (OP, GET_MODE (OP)) == 3)  \
+   : ((CODE) == 'R') ? (tms9900_address_type (OP, GET_MODE (OP)) == 1)	\
+   : 0)
+   // constantpool_mem_p (OP)
+
+/* Stack layout; function entry, exit and calling.  */
+
+/* Define this if pushing a word on the stack
+   makes the stack pointer a smaller address.  */
+#define STACK_GROWS_DOWNWARD
+
+/* Define this to nonzero if the nominal address of the stack frame
+   is at the high-address end of the local variables;
+   that is, each additional local variable allocated
+   goes at a more negative offset in the frame.
+
+   Define to 0 for TMS9900, the frame pointer is the bottom
+   of local variables.  */
+#define FRAME_GROWS_DOWNWARD 0
+
+/* Offset within stack frame to start allocating local variables at.
+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the
+   first local allocated.  Otherwise, it is the offset to the BEGINNING
+   of the first local allocated.  */
+#define STARTING_FRAME_OFFSET 0
+
+/* Offset of first parameter from the argument pointer register value.  */
+#define FIRST_PARM_OFFSET(FNDECL)	0
+
+/* After the prologue, RA is at 0(AP) in the current frame.  */
+#define RETURN_ADDR_RTX(COUNT, FRAME)					\
+  ((COUNT) == 0								\
+   ? gen_rtx_MEM (Pmode, arg_pointer_rtx)                               \
+   : 0)
+
+/* Before the prologue, the top of the frame is at 2(sp).  */
+#define INCOMING_FRAME_SP_OFFSET        0
+
+/* Register to use for pushing function arguments.  */
+#define STACK_POINTER_REGNUM		HARD_SP_REGNUM
+
+/* Base register for access to local variables of the function.  */
+#define FRAME_POINTER_REGNUM		HARD_BP_REGNUM
+
+/* Base register for access to arguments of the function.  */
+#define ARG_POINTER_REGNUM		HARD_AP_REGNUM
+
+/* Register in which static-chain is passed to a function.  */
+#define STATIC_CHAIN_REGNUM	        HARD_R12_REGNUM
+
+/* Definitions for register eliminations.
+
+   This is an array of structures.  Each structure initializes one pair
+   of eliminable registers.  The "from" register number is given first,
+   followed by "to".  Eliminations of the same "from" register are listed
+   in order of preference.
+
+   The pseudo arg pointer and pseudo frame pointer registers can always
+   be eliminated; they are replaced with either the stack or the real
+   frame pointer.  */
+#define ELIMINABLE_REGS \
+  {{ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM},\
+   {ARG_POINTER_REGNUM,   FRAME_POINTER_REGNUM},\
+   {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}
+
+/* Value should be nonzero if functions must have frame pointers.
+   Zero means the frame pointer need not be set up (and parms may be
+   accessed via the stack pointer) in functions that seem suitable.
+   This is computed in `reload', in reload1.c.  */
+#define FRAME_POINTER_REQUIRED	0
+
+#define CAN_DEBUG_WITHOUT_FP 1
+
+/* Given FROM and TO register numbers, say whether this elimination is allowed.
+   Frame pointer elimination is automatically handled.
+
+   All other eliminations are valid.  */
+#define CAN_ELIMINATE(FROM, TO)		1
+
+/* Define the offset between two registers, one to be eliminated, and the other
+   its replacement, at the start of a routine.  */
+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \
+    { OFFSET = tms9900_initial_elimination_offset (FROM, TO); }
+
+/* Passing Function Arguments on the Stack.  */
+
+/* A C expression.  If nonzero, push insns will be used to pass
+   outgoing arguments.  If the target machine does not have a push
+   instruction, set it to zero.  That directs GCC to use an alternate
+   strategy: to allocate the entire argument block and then store the
+   arguments into it.  When `PUSH_ARGS' is nonzero, `PUSH_ROUNDING'
+   must be defined too. */
+#define PUSH_ARGS 0
+
+/* We want the stack and args grow in opposite directions, even if
+   PUSH_ARGS is 0.
+   MGB added, var param lists were not working */
+#define PUSH_ARGS_REVERSED 1
+
+/* Value is 1 if returning from a function call automatically pops the
+   arguments described by the number-of-args field in the call. FUNTYPE is
+   the data type of the function (as a tree), or for a library call it is
+   an identifier node for the subroutine name. */
+#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE)	0
+
+/* MGB to load a byte into a word we need to zero extend it.  Defining this
+ * macro solves some problems with upgrading QI to HI but introduces others
+ * where it extends a QI and then subsequently refers to the reg in QI mode
+ * anyway.  Leaving commented out for now */
+// #define LOAD_EXTEND_OP(MODE) ZERO_EXTEND
+
+/* Passing Arguments in Registers.  */
+
+/* The number of argument registers we can use (R1..R8) */
+#define TMS9900_ARG_REGS (HARD_R8_REGNUM - HARD_R1_REGNUM + 1)
+
+/* Define a data type for recording info about an argument list
+   during the scan of that argument list.  This data type should
+   hold all necessary information about the function itself
+   and about the args processed so far, enough to enable macros
+   such as FUNCTION_ARG to determine where the next arg should go.  */
+typedef struct tms9900_args
+{
+  int nregs;        /* Number of registers used so far */
+  int named_count;  /* Number of named arguments (for varargs) */  
+} CUMULATIVE_ARGS;
+
+/* If defined, a C expression which determines whether, and in which direction,
+   to pad out an argument with extra space.  The value should be of type
+   `enum direction': either `upward' to pad above the argument,
+   `downward' to pad below, or `none' to inhibit padding.
+
+   Structures are stored left shifted in their argument slot.  */
+#define FUNCTION_ARG_PADDING(MODE, TYPE) \
+  tms9900_function_arg_padding ((MODE), (TYPE))
+
+#undef PAD_VARARGS_DOWN
+#define PAD_VARARGS_DOWN \
+  (tms9900_function_arg_padding (TYPE_MODE (type), type) == downward)
+
+/* Initialize a variable CUM of type CUMULATIVE_ARGS for a call to a
+   function whose data type is FNTYPE. For a library call, FNTYPE is 0.  */
+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \
+   (tms9900_init_cumulative_args (&CUM, FNTYPE, LIBNAME))
+
+/* Update the data in CUM to advance over an argument of mode MODE and data
+   type TYPE. (TYPE is null for libcalls where that information may not be
+   available.) */
+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED) \
+    (tms9900_function_arg_advance (&CUM, MODE, TYPE, NAMED))
+
+/* Define where to put the arguments to a function.
+   Value is zero to push the argument on the stack,
+   or a hard register in which to store the argument.
+
+   MODE is the argument's machine mode.
+   TYPE is the data type of the argument (as a tree).
+    This is null for libcalls where that information may
+    not be available.
+   CUM is a variable of type CUMULATIVE_ARGS which gives info about
+    the preceding args and about the function being called.
+   NAMED is nonzero if this argument is a named parameter
+    (otherwise it is an extra parameter matching an ellipsis).  */
+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \
+  (tms9900_function_arg (&CUM, MODE, TYPE, NAMED))
+
+/* This target hook should return `true' if an argument at the
+   position indicated by CUM should be passed by reference.  This
+   predicate is queried after target independent reasons for being
+   passed by reference, such as `TREE_ADDRESSABLE (type)'.
+
+   If the hook returns true, a copy of that argument is made in
+   memory and a pointer to the argument is passed instead of the
+   argument itself.  The pointer is passed in whatever way is
+   appropriate for passing a pointer to that type. */
+/*
+#define TARGET_PASS_BY_REFERENCE(CUM,MODE,TYPE,NAMED) \
+ (TYPE && TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST)
+*/
+
+/* Define the profitability of saving registers around calls.
+
+   Disable this because the saving instructions generated by
+   caller-save need a reload and the way it is implemented,
+   it forbids all spill registers at that point.  Enabling
+   caller saving results in spill failure.  */
+#define CALLER_SAVE_PROFITABLE(REFS,CALLS) 0
+
+/* 1 if N is a possible register number for function argument passing. */
+#define FUNCTION_ARG_REGNO_P(N)	\
+     (((N) >= HARD_R1_REGNUM) && ((N) <= HARD_R8_REGNUM))
+
+/* 8- and 16-bit values are returned in R1, 32-bit values are
+   passed in R1+R2, The high word is in R1. */
+#define FUNCTION_VALUE(VALTYPE, FUNC) \
+     gen_rtx_REG (TYPE_MODE (VALTYPE), HARD_R1_REGNUM)
+
+/* 8- and 16-bit values are returned in R1, 32-bit values are
+   passed in R1+R2, The high word is in R1. */
+#define LIBCALL_VALUE(MODE)						\
+     gen_rtx_REG (MODE, HARD_R1_REGNUM)
+
+/* 1 if N is a possible register number for a function value.  */
+#define FUNCTION_VALUE_REGNO_P(N) \
+     ((N) == HARD_R1_REGNUM)
+
+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,
+   the stack pointer does not matter.  The value is tested only in functions
+   that have frame pointers. No definition is equivalent to always zero.  */
+#define EXIT_IGNORE_STACK	0
+
+/* Generating Code for Profiling.  */
+
+/* Output assembler code to FILE to increment profiler label # LABELNO
+   for profiling a function entry.  */
+#define FUNCTION_PROFILER(FILE, LABELNO)		\
+    fprintf (FILE, "\tldy\tLP%d\n\tjsr mcount\n", (LABELNO))
+
+/* Let's see whether this works as trampoline:
+     LI Rn, @STATIC	0x0200	0x0000 <- STATIC; Y = STATIC_CHAIN_REGNUM
+     B  FUNCTION	0x0820  0x0000 <- FUNCTION
+*/
+#define TRAMPOLINE_TEMPLATE(FILE)	\
+{					\
+  assemble_aligned_integer (2, GEN_INT (0x0200+STATIC_CHAIN_REGNUM));	\
+  assemble_aligned_integer (2, const0_rtx);				\
+  assemble_aligned_integer (2, GEN_INT(0x0820));			\
+  assemble_aligned_integer (2, const0_rtx);				\
+}
+
+#define TRAMPOLINE_SIZE 8
+#define TRAMPOLINE_ALIGNMENT 16
+
+/* Emit RTL insns to initialize the variable parts of a trampoline.
+   FNADDR is an RTX for the address of the function's pure code.
+   CXT is an RTX for the static chain value for the function.  */
+#define INITIALIZE_TRAMPOLINE(TRAMP,FNADDR,CXT)	\
+{					\
+  emit_move_insn (gen_rtx_MEM (HImode, plus_constant (TRAMP, 2)), CXT); \
+  emit_move_insn (gen_rtx_MEM (HImode, plus_constant (TRAMP, 6)), FNADDR); \
+}
+
+/* The TMS9900 can only do post increment */
+#define HAVE_POST_INCREMENT  (1)
+#define HAVE_PRE_INCREMENT   (0)
+#define HAVE_POST_DECREMENT  (0)
+#define HAVE_PRE_DECREMENT   (0)
+#define HAVE_POST_MODIFY_REG (1)
+
+/* The name of the class to which a valid base register must belong.
+   A base register is one used in an address which is the register
+   value plus a displacement. */
+#define BASE_REG_CLASS	BASE_REGS
+
+/* From https://gcc.gnu.org/onlinedocs/gccint/Register-Classes.html
+ *
+ * "The difference between an index register and a base register is that the
+ * index register may be scaled. "
+ *
+ *  We don't allow any index regs as TMS9900 regs can't be scaled
+ */
+/* The class value for index registers. */
+#define INDEX_REG_CLASS	NO_REGS
+
+/* A C expression which is nonzero if register number NUM is suitable
+   for use as a base register in operand addresses.  It may be either
+   a suitable hard register or a pseudo register that has been
+   allocated such a hard register. 
+   Any hard register except R0 is a valid base */
+#define REGNO_OK_FOR_BASE_P(NUM) \
+   ((NUM) >= HARD_R1_REGNUM && (NUM) <= HARD_R15_REGNUM)
+
+/* A C expression which is nonzero if register number NUM is suitable
+   for use as an index register in operand addresses.  It may be
+   either a suitable hard register or a pseudo register that has been
+   allocated such a hard register. The difference between an index
+   register and a base register is that the index register may be scaled. */
+#define REGNO_OK_FOR_INDEX_P(NUM) 0
+
+/* 1 if X is an rtx for a constant that is a valid address.  */
+/*
+#define CONSTANT_ADDRESS_P(X)	\
+  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF \
+          || CONST_INT_P (X) || GET_CODE (X) == CONST      \
+          || GET_CODE (X) == HIGH)
+*/
+// #define CONSTANT_ADDRESS_P(X)  CONSTANT_P(X)
+#define CONSTANT_ADDRESS_P(X)  tms9900_constant_address_p(X)
+
+/* Maximum number of registers that can appear in a valid memory address */
+#define MAX_REGS_PER_ADDRESS	1
+
+/* The behavior of several macros depend on whether or not we are in 
+   strict mode. Define a constant for this */
+#ifdef REG_OK_STRICT
+#define IS_STRICT_P 1
+#else
+#define IS_STRICT_P 0
+#endif
+
+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression that is a
+   valid memory address for an instruction. The MODE argument is the
+   machine mode for the MEM expression that wants to use this address.  */
+
+/*--------------------------------------------------------------
+   Valid addresses are either direct or indirect (MEM) versions
+   of the following forms:
+	constant		N
+	register		X
+	indexed			N,X
+--------------------------------------------------------------*/
+
+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression
+   that is a valid memory address for an instruction.
+   The MODE argument is the machine mode for the MEM expression
+   that wants to use this address. */
+#define GO_IF_LEGITIMATE_ADDRESS(mode, operand, ADDR) \
+  { \
+  if(tms9900_go_if_legitimate_address(mode, operand, IS_STRICT_P)) \
+    { \
+    goto ADDR; \
+    } \
+  fail: ;\
+  }
+
+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx and check its
+   validity for a certain class.  We have two alternate definitions for each
+   of them.  The usual definition accepts all pseudo regs; the other rejects
+   them unless they have been allocated suitable hard regs.  The symbol
+   REG_OK_STRICT causes the latter definition to be used.
+  
+   Most source files want to accept pseudo regs in the hope that they will
+   get allocated to the class that the insn wants them to be in. Source files
+   for reload pass need to be strict. After reload, it makes no difference,
+   since pseudo regs have been eliminated by then.  */
+#define REG_OK_FOR_BASE_P(X) (tms9900_reg_ok_for_base(IS_STRICT_P, X)) 
+
+/* Nonzero if X is a hard reg that can be used as an index.  */
+#define REG_OK_FOR_INDEX_P(X) (0)
+
+
+/* Try machine-dependent ways of modifying an illegitimate address
+   to be legitimate.  If we find one, return the new, valid address.
+   This macro is used in only one place: `memory_address' in explow.c.
+  
+   OLDX is the address as it was before break_out_memory_refs was called.
+   In some cases it is useful to look at this to decide what needs to be done.
+  
+   MODE and WIN are passed so that this macro can use
+   GO_IF_LEGITIMATE_ADDRESS.
+  
+   It is always safe for this macro to do nothing.
+   It exists to recognize opportunities to optimize the output.  */
+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)
+  
+/* Go to LABEL if ADDR (a legitimate address expression)
+   has an effect that depends on the machine mode it is used for.  */
+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)
+
+/* Nonzero if the constant value X is a legitimate general operand.
+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */
+
+/* "TARGET_CANNOT_FORCE_CONST_MEM should not be defined to be true for an
+    ordinary constant.  It should only return true for special cases like
+    the address of a TLS symbol.
+ 
+    gcc will automatically generate a constant pool when it sees a
+    constant which is not LEGITIMATE_CONSTANT_P." */
+
+// #define LEGITIMATE_CONSTANT_P(X)	1
+// #define LEGITIMATE_CONSTANT_P(X)	(GET_CODE(X)!=CONST_INT)
+#define LEGITIMATE_CONSTANT_P(X) tms9900_legitimate_constant_p(X)
+
+/* Tell final.c how to eliminate redundant test instructions.  */
+#define NOTICE_UPDATE_CC(EXP, INSN) \
+{ if (GET_CODE (EXP) == SET)					\
+    {								\
+      notice_update_cc_on_set(EXP, INSN);			\
+    }								\
+  else if (GET_CODE (EXP) == PARALLEL				\
+	   && GET_CODE (XVECEXP (EXP, 0, 0)) == SET)		\
+    {								\
+      notice_update_cc_on_set(XVECEXP (EXP, 0, 0), INSN);	\
+    }								\
+  else if (GET_CODE (EXP) == CALL)				\
+    { /* all bets are off */ CC_STATUS_INIT; }			\
+  if (cc_status.value1 && GET_CODE (cc_status.value1) == REG	\
+      && cc_status.value2					\
+      && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2)) \
+    { 								\
+      cc_status.value2 = 0;					\
+    }								\
+}
+
+/*   A C expression for the cost of moving data of mode MODE from a
+     register in class FROM to one in class TO.  The classes are
+     expressed using the enumeration values such as `GENERAL_REGS'.  A
+     value of 2 is the default; other values are interpreted relative to
+     that.
+
+     It is not required that the cost always equal 2 when FROM is the
+     same as TO; on some machines it is expensive to move between
+     registers if they are not general registers.
+
+     If reload sees an insn consisting of a single `set' between two
+     hard registers, and if `REGISTER_MOVE_COST' applied to their
+     classes returns a value of 2, reload does not check to ensure that
+     the constraints of the insn are met.  Setting a cost of other than
+     2 will allow reload to verify that the constraints are met.  You
+     should do this if the `movM' pattern's constraints do not allow
+     such copying. */
+#define REGISTER_MOVE_COST(MODE, FROM, TO) 4
+
+/* A C expression for the cost of moving data of mode MODE between a
+   register of class CLASS and memory; IN is zero if the value is to
+   be written to memory, nonzero if it is to be read in.  This cost
+   is relative to those in `REGISTER_MOVE_COST'.  If moving between
+   registers and memory is more expensive than between two registers,
+   you should define this macro to express the relative cost
+
+   For the TMS9900, memory access is four times slower than registers
+   MGB I don't think it is 4x more expensive, but lowering it to 4 caused some
+   code bloat so changing it back to 16 */
+#define MEMORY_MOVE_COST(MODE,CLASS,IN)	16
+
+/* A C expression for the cost of a branch instruction.  A value of 1
+   is the default; other values are interpreted relative to that.
+
+   Pretend branches are cheap because GCC generates sub-optimal code
+   for the default value.  */
+#define BRANCH_COST(speed_p, predictable_p) 0
+
+/* Nonzero if access to memory by bytes is slow and undesirable.  */
+#define SLOW_BYTE_ACCESS 0
+
+/* Defining the Output Assembler Language.  */
+
+/* A default list of other sections which we might be "in" at any given
+   time.  For targets that use additional sections (e.g. .tdesc) you
+   should override this definition in the target-specific file which
+   includes this file.  */
+
+/* Output before read-only data.  */
+#define TEXT_SECTION_ASM_OP	("\tpseg")
+
+/* Output before writable data.  */
+#define DATA_SECTION_ASM_OP	("\tdseg")
+
+/* Output before uninitialized data.  */
+#define BSS_SECTION_ASM_OP 	("\tcseg")
+
+/* Define this macro to be an expression with a nonzero value if jump tables
+   (for tablejump insns) should be output in the text section, along with the
+   assembler instructions. Otherwise, the readonly data section is used. */
+#define JUMP_TABLES_IN_TEXT_SECTION 1
+
+
+/* Define the pseudo-ops used to switch to the .ctors and .dtors sections.
+
+   Same as config/elfos.h but don't mark these section SHF_WRITE since
+   there is no shared library problem.  */
+/*EMW - Neglect C++ for now...
+#undef CTORS_SECTION_ASM_OP
+#define CTORS_SECTION_ASM_OP	"\t.section\t.ctors,\"a\""
+
+#undef DTORS_SECTION_ASM_OP
+#define DTORS_SECTION_ASM_OP	"\t.section\t.dtors,\"a\""
+
+#define TARGET_ASM_CONSTRUCTOR  tms9900_asm_out_constructor
+#define TARGET_ASM_DESTRUCTOR   tms9900_asm_out_destructor
+EMW*/
+
+/* Comment character */
+#define ASM_COMMENT_START	"*"
+
+/* Output to assembler file text saying following lines
+   may contain character constants, extra white space, comments, etc.  */
+#define ASM_APP_ON 		"* Begin inline assembler code\n"
+
+/* Output to assembler file text saying following lines
+   no longer contain unusual constructs.  */
+#define ASM_APP_OFF 		"* End of inline assembler code\n"
+
+/* output external reference */
+#undef ASM_OUTPUT_EXTERNAL
+#define ASM_OUTPUT_EXTERNAL(FILE,DECL,NAME) \
+  {fputs ("\tref\t", FILE); \
+  assemble_name (FILE, NAME); \
+  fputs ("\n", FILE);}
+
+#define ASM_OUTPUT_LABEL(FILE,NAME) \
+  {							\
+    assemble_name ((FILE), (NAME));			\
+    fputc ('\n', (FILE));				\
+  }
+
+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,NAME) \
+  {							\
+    assemble_name ((FILE), (NAME));			\
+    fputc ('\n', (FILE));				\
+  }
+
+/* Print operand X (an rtx) in assembler syntax to file FILE.
+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.
+   For `%' followed by punctuation, CODE is the punctuation and X is null. */
+#define PRINT_OPERAND(FILE, X, CODE)  		\
+{ if (CODE == '#') fprintf (FILE, "#");		\
+  else if (GET_CODE (X) == REG)			\
+    fprintf (FILE, "%s", reg_names[REGNO (X)]);	\
+  else if (GET_CODE (X) == MEM)			\
+    output_address (XEXP (X, 0));		\
+  else if (GET_CODE (X) == PC)			\
+    fprintf (FILE, "$");			\
+  else if (GET_CODE (X) == CONST_INT)		\
+    fprintf (FILE, ">%X", (unsigned short)(INTVAL(X) & 0xFFFF));	\
+  else output_addr_const (FILE, X);}
+
+/* Print a memory operand whose address is ADDR, on file FILE.  */
+#define PRINT_OPERAND_ADDRESS(FILE, ADDR) \
+   print_operand_address (FILE, ADDR)
+
+/* This is how to output an insn to push/pop a register on the stack.
+   It need not be very fast code.  
+
+   Don't define because we don't know how to handle that with
+   the STATIC_CHAIN_REGNUM (soft register).  Saving the static
+   chain must be made inside FUNCTION_PROFILER.  */
+#undef ASM_OUTPUT_REG_PUSH
+#undef ASM_OUTPUT_REG_POP
+
+/* This is how to output an element of a case-vector that is relative.  */
+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \
+  fprintf (FILE, "\t%s\tL%d-L%d\n", integer_asm_op (2, TRUE), VALUE, REL)
+
+/* This is how to output an element of a case-vector that is absolute.  */
+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \
+  fprintf (FILE, "\t%s\tL%d\n", integer_asm_op (2, TRUE), VALUE)
+
+/* Advance to the next word boundary */
+#undef ALIGN_ASM_OP
+#define ALIGN_ASM_OP "\teven\t"
+
+/* This is how to output an assembler line that says to advance the
+   location counter to a multiple of 2**LOG bytes.  */
+#define ASM_OUTPUT_ALIGN(FILE,LOG)      \
+  switch (LOG)                          \
+    {                                   \
+      case 0:                           \
+        break;                          \
+      case 1:                           \
+        fprintf (FILE, "\teven\n");     \
+        break;                          \
+      default:                          \
+        gcc_unreachable ();             \
+    }
+
+/* Assembler Commands for Exception Regions.  */
+
+/* Default values provided by GCC should be ok. Assuming that DWARF-2
+   frame unwind info is ok for this platform.  */
+#define DWARF2_DEBUGGING_INFO 1
+
+/* Prefer dwarf format for debugging info */
+#undef PREFERRED_DEBUGGING_TYPE
+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG
+
+/* Use 16-bit values for dwarf address pointers */
+#define DWARF2_ADDR_SIZE 2
+
+/* Enable support for source line debugging in emitted assembly code */
+#define HAVE_AS_DWARF2_DEBUG_LINE 1
+
+/* Only emit ".file" and ".loc" directives if debugging is enabled */
+#define DWARF2_ASM_LINE_DEBUG_INFO (write_symbols != NO_DEBUG)
+
+/* This flag is true if the target supports `TARGET_ASM_NAMED_SECTION'. */
+#define TARGET_HAVE_NAMED_SECTIONS 1
+
+/* Output assembly directives to switch to section NAME.  The section
+   should have attributes as specified by FLAGS, which is a bit mask
+   of the `SECTION_*' flags defined in `output.h'.  If ALIGN is
+   nonzero, it contains an alignment in bytes to be used for the
+   section, otherwise some target default should be used.  Only
+   targets that must specify an alignment within the section
+   directive need pay attention to ALIGN - we will still use
+   `ASM_OUTPUT_ALIGN'. */
+#define TARGET_ASM_NAMED_SECTION  default_elf_asm_named_section
+
+/* The prefix for local labels.  You should be able to define this as
+   an empty string, or any arbitrary string (such as ".", ".L%", etc)
+   without having to make any other changes to account for the specific
+   definition.  Note it is a string literal, not interpreted by printf
+   and friends.  */
+/*#define LOCAL_LABEL_PREFIX "."*/
+
+/* Directive to give a symbol global scope */
+#define GLOBAL_ASM_OP   "\tdef\t"
+
+/* Miscellaneous Parameters.  */
+
+/* Specify the machine mode that this machine uses
+   for the index in the tablejump instruction.  */
+#define CASE_VECTOR_MODE	Pmode
+
+/* This flag, if defined, says the same insns that convert to a signed fixnum
+   also convert validly to an unsigned one.  */
+#define FIXUNS_TRUNC_LIKE_FIX_TRUNC
+
+/* Max number of bytes we can move from memory to memory in one
+   reasonably fast instruction.  */
+#define MOVE_MAX 		2
+
+/* MOVE_RATIO is the number of move instructions that is better than a
+   block move.  Make this small, since the code size grows very
+   large with each move.  */
+#define MOVE_RATIO(speed)	3
+
+/* Define if shifts truncate the shift count which implies one can omit
+   a sign-extension or zero-extension of a shift count.  */
+#define SHIFT_COUNT_TRUNCATED	1
+
+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits
+   is done just by pretending it is already truncated.  */
+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC)	0
+
+/* Specify the machine mode that pointers have. After generation of rtl, the
+   compiler makes no further distinction between pointers and any other
+   objects of this machine mode.  */
+#define Pmode			HImode
+
+/* An alias for the machine mode used for memory references to
+   functions being called, in `call' RTL expressions.  On most CISC
+   machines, where an instruction can begin at any byte address, this
+   should be `QImode'.  On most RISC machines, where all instructions
+   have fixed size and alignment, this should be a mode with the same
+   size and alignment as the machine instruction words - typically
+   `SImode' or `HImode'. */
+#define FUNCTION_MODE		HImode
+
+/* A C statement (sans semicolon) to output a reference to
+   `SYMBOL_REF' SYM.  If not defined, `assemble_name' will be used to
+   output the name of the symbol.  This macro may be used to modify
+   the way a symbol is referenced depending on information encoded by
+   `TARGET_ENCODE_SECTION_INFO'. */
+#define ASM_GENERATE_INTERNAL_LABEL(STRING, PREFIX, NUM) \
+  sprintf (STRING, "*%s%ld", PREFIX, (long)(NUM))
+
+/* A C statement to output to the stdio stream STREAM an assembler
+   instruction to advance the location counter by NBYTES bytes.
+   Those bytes should be zero when loaded.  NBYTES will be a C
+   expression of type `unsigned HOST_WIDE_INT'. */
+#define ASM_OUTPUT_SKIP(STREAM, NBYTES) \
+   fprintf(STREAM, "\tbss %lu\n", NBYTES);
+
+/* A C statement (sans semicolon) to output to the stdio stream
+   STREAM the assembler definition of uninitialized global DECL named
+   NAME whose size is SIZE bytes.  The variable ROUNDED is the size
+   rounded up to whatever alignment the caller wants. */
+#define ASM_OUTPUT_ALIGNED_BSS(STREAM, DECL, NAME, SIZE, ALIGNMENT)     \
+  do{\
+  if(ALIGNMENT > 1) fprintf ((STREAM), "\n\teven\n");                   \
+  asm_output_aligned_bss ((STREAM), (DECL), (NAME), (SIZE), (ALIGNMENT)); }while(0)
+
+/* A C statement (sans semicolon) to output to the stdio stream
+   STREAM the assembler definition of a common-label named NAME whose
+   size is SIZE bytes.  The variable ROUNDED is the size rounded up
+   to whatever alignment the caller wants. */
+#define ASM_OUTPUT_ALIGNED_COMMON(STREAM, NAME, SIZE, ALIGNMENT)           \
+do {                                                                       \
+     switch_to_section (bss_section);                                      \
+     if(ALIGNMENT > 1) fprintf ((STREAM), "\n\teven");                     \
+     fprintf ((STREAM), "\n\tdef %s\n", (NAME));                           \
+     assemble_name ((STREAM), (NAME));                                     \
+     fprintf ((STREAM), "\n\tbss %u\n", (int)(SIZE));                      \
+} while (0)
+
+/* A C statement (sans semicolon) to output to the stdio stream
+   STREAM the assembler definition of a local-common-label named NAME
+   whose size is SIZE bytes.  The variable ROUNDED is the size
+   rounded up to whatever alignment the caller wants. */
+#define ASM_OUTPUT_ALIGNED_LOCAL(STREAM, NAME, SIZE, ALIGNMENT)            \
+do {                                                                       \
+     switch_to_section (bss_section);                                      \
+     if(ALIGNMENT > 1) fprintf ((STREAM), "\n\teven\n");                   \
+     assemble_name ((STREAM), (NAME));                                     \
+     fprintf ((STREAM), "\n\tbss %u\n", (int)(SIZE));                      \
+} while (0)
+
+/* A C statement to output to the stdio stream STREAM an assembler
+   instruction to assemble a string constant containing the LEN bytes
+   at PTR.  PTR will be a C expression of type `char *' and LEN a C
+   expression of type `int'. */
+#define ASM_OUTPUT_ASCII(STREAM, PTR, LEN) \
+   tms9900_output_ascii(STREAM, PTR, LEN)
+
+#define ASM_OUTPUT_DWARF_DELTA(FILE,SIZE,LABEL1,LABEL2)  \
+   tms9900_asm_output_dwarf_delta (FILE, SIZE, LABEL1, LABEL2)
+
+#define ASM_OUTPUT_DWARF_OFFSET(FILE,SIZE,LABEL,BASE)  \
+   tms9900_asm_output_dwarf_offset (FILE, SIZE, LABEL, BASE)
+
+/* Put references to global constructors in a .init section. The crt0 code
+   will invoke these constructors at startup, before calling main. */
+#define INIT_SECTION_ASM_OP
+
+#undef  SIZE_ASM_OP
+#undef  TYPE_ASM_OP
+#define SIZE_ASM_OP     "\t.size\t"
+#define TYPE_ASM_OP     "\t.type\t"
+
+#undef TYPE_OPERAND_FMT
+#define TYPE_OPERAND_FMT        "@%s"
+
+#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)                    \
+  do {                                                                  \
+     if (!flag_inhibit_size_directive)                                  \
+      ASM_OUTPUT_MEASURED_SIZE (FILE, FNAME);                           \
+  } while (0)
+
+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)                       \
+do {                                                                    \
+  ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, "object");                     \
+  size_directive_output = 0;                                            \
+  if (!flag_inhibit_size_directive && DECL_SIZE (DECL))                 \
+    {                                                                   \
+      size_directive_output = 1;                                        \
+      ASM_OUTPUT_SIZE_DIRECTIVE (FILE, NAME,                            \
+                                 int_size_in_bytes (TREE_TYPE (DECL))); \
+    }                                                                   \
+  ASM_OUTPUT_LABEL(FILE, NAME);                                         \
+} while (0)
+
+
+#undef ASM_FINISH_DECLARE_OBJECT
+#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)        \
+  do {                                                                  \
+    const char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);             \
+    HOST_WIDE_INT size;                                                 \
+    if (!flag_inhibit_size_directive                                    \
+        && DECL_SIZE (DECL)                                             \
+        && ! AT_END && TOP_LEVEL                                        \
+        && DECL_INITIAL (DECL) == error_mark_node                       \
+        && !size_directive_output                                       \
+        && (size = int_size_in_bytes (TREE_TYPE (DECL))) > 0)           \
+      {                                                                 \
+        size_directive_output = 1;                                      \
+        ASM_OUTPUT_SIZE_DIRECTIVE (FILE, name, size);                   \
+      }                                                                 \
+  } while (0)
+
+
+#ifdef FILE
+void tms9900_asm_output_dwarf_delta (FILE *file, int size,
+                               const char *lab1, const char *lab2);
+#endif
+
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/tms9900.md gcc-4.4.0/gcc/config/tms9900/tms9900.md
--- gcc-4.4.0-orig/gcc/config/tms9900/tms9900.md	2023-12-23 10:48:53.513244386 +0000
+++ gcc-4.4.0/gcc/config/tms9900/tms9900.md	2024-02-22 15:39:36.716500047 +0000
@@ -0,0 +1,3327 @@
+;;- Machine description for the TMS9900 for GNU C compiler
+;; Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2004, 2005
+;; 2007, 2008 Free Software Foundation, Inc.
+
+;; Copyright 2009 Eric Welser (EMW)
+;; Copyright 2023 Mark Burkley (MGB)
+
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+;; SI is 32 bit
+;; HI is 16 bit
+;; QI is 8 bit 
+
+;; MGB NOTES
+;;    - rtx notation is insn(dst,src) but tms asm notation is <op> src,dst so
+;;      beware of operand ordering
+;;    - all byte (QI) ops need to have expands to cater for the fact that in
+;;      TMS9900 a 16-bit operation can't be done on a reg that contains an 8-bit value
+;;      unless it has been shifted by 8
+;;    - Many byte insns are restricted to registers only as TMS9900 doesn't have
+;;      byte version of abs, neg, etc.
+;;    - Insns like extend, trunc, abs, etc, are done in place but passed two
+;;      distinct params.  This is ok, the compiler is forced to move src and dst to the
+;;      same reg by the "0" constraint.
+;;    - optimiser doesn't understand opcodes, just insns.  So keep insns as
+;;      short as possible.  One opcode preferable, two max.  Any more, use an expand instead
+;;    - byte immediates can be problematic as immediates are 16-bit only and the
+;;      other byte is an unknown.  In these cases, byte immediates are re-written in an
+;;      expand to refer to a label in a constant pool using force_const_mem
+;;    - I'm avoiding clobbers in expands and declaring temp rtx regs inside code
+;;      instead.  Also using r0 as a scratch reg since it cannot be used as a general
+;;      reg.
+;;    - 32-bit arith insns have been moved to C code.  Emitting lengthy opcode
+;;      sequences shouldn't be part of a md file.
+
+;; Description of class IDs
+;;   'L' is for 2 or -2
+;;   'M' is for -1
+;;   'N' is for 1
+;;   'O' is for 0
+;;   'Q' is for memory references that need an extra word after the opcode.
+;;   'R' is for memory references which are encoded within the opcode.
+
+;;- See file "rtl.def" for documentation on define_insn, match_*, et. al.
+
+;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code
+;;- updates for most instructions.
+
+;;- Operand classes for the register allocator:
+
+;; Compare instructions.
+
+
+;; define attributes
+;; currently type is only fpu or arith or unknown, maybe branch later ?
+;; default is arith
+(define_attr "type" "unknown,arith,fp" (const_string "arith"))
+
+;; length default is 1 words each
+(define_attr "length" "" (const_int 2))
+
+;; a user's asm statement
+(define_asm_attributes
+  [(set_attr "type" "unknown")
+; all bets are off how long it is - make it 256, forces long jumps 
+; whenever jumping around it !!!
+   (set_attr "length" "256")])
+
+;;-------------------------------------------------------------------
+;;  UNSPEC Definitions
+;;-------------------------------------------------------------------
+(define_constants
+  [(UNSPEC_RETURN  0)])
+
+
+;;-------------------------------------------------------------------
+;;  Predicate Definitions
+;;-------------------------------------------------------------------
+
+;;-------------------------------------------------------------------
+;;  Function Calls
+;;-------------------------------------------------------------------
+
+
+;;-------------------------------------------------------------------
+;; Jump to a subroutine which returns a value
+(define_insn "call"
+  [(call (match_operand:HI 0 "general_operand" "rR,Q")
+         (match_operand:HI 1 "general_operand"  "g,g"))
+  ]
+  ""
+  {
+    tms9900_debug_operands ("call", insn, operands, 2);
+    if(SIBLING_CALL_P(insn))
+      output_asm_insn("b    %0", operands);
+    else
+      output_asm_insn("bl   %0", operands);
+    return("");
+  }
+  [(set_attr "length" "2,4")]
+)
+
+
+;-------------------------------------------------------------------
+; Jump to a subroutine which returns a value
+(define_insn "call_value"
+  [(set (match_operand 0 "" "")
+        (call (match_operand:HI 1 "general_operand" "rR,Q")
+	      (match_operand:HI 2 "general_operand" "g,g")))
+  ]
+  ""
+  {
+    tms9900_debug_operands ("call_value", insn, operands, 3);
+    if(SIBLING_CALL_P(insn))
+      output_asm_insn("b    %1", operands);
+    else
+      output_asm_insn("bl   %1", operands);
+    return("");
+  }
+  [(set_attr "length" "2,4")]
+)
+
+;; The O2 and O3 optimise options replace BL @xxx with LI Ry,xxx and BL *Ry
+;; when the BL is inside a loop, even though the LI is also inside the loop,
+;; which makes it less efficient.  This peephole undoes this "optimisation"
+
+; There is an issue with this when the register used to hold the jump address
+; gets spilled to the stack.  The resulting attempt to do call @6[sp] fails of
+; course.  Popping from stack needs to go through a reg.  But why spill a label
+; address to stack?  That makes no sense.
+
+; This peephole is disabled due to the above failure.  It's recomended instead
+; to use -fno-function-cse to prevent gcc from replacing labels with regs
+
+; (define_peephole2
+;   [(set (match_operand:HI 0 "general_operand" "")
+; 	(match_operand:HI 1 "general_operand" ""))
+;    (set (match_operand:HI 2 "general_operand" "")
+; 	(call (mem:HI (match_dup 0))
+;               (match_operand:HI 3 "general_operand" "")))]
+;   ""
+;   [(set (match_dup 2)
+;         (call (mem:HI (match_dup 1))
+;               (match_dup 3)))]
+;   "")
+
+
+
+;;-------------------------------------------------------------------
+;; Define function prologue
+(define_expand "prologue"
+  [(const_int 0)]
+  ""
+{
+  tms9900_debug_operands ("prologue", NULL_RTX, NULL, 0);
+  tms9900_expand_prologue();
+  DONE;
+})
+
+
+;;-------------------------------------------------------------------
+;; Define function epilogue
+(define_expand "epilogue"
+  [(return)]
+  ""
+{
+  tms9900_debug_operands ("epilogue", NULL_RTX, NULL, 0);
+  tms9900_expand_epilogue(false);
+  DONE;
+})
+
+(define_expand "sibcall_epilogue"
+  [(return)]
+  ""
+{
+  tms9900_debug_operands ("sibcall_epilogue", NULL_RTX, NULL, 0);
+  tms9900_expand_epilogue(true);
+  DONE;
+})
+
+
+;;-------------------------------------------------------------------
+;; Define function return
+(define_insn "*rt"
+  [(unspec [(match_operand:HI 0 "general_operand" "")] UNSPEC_RETURN)]
+  ""
+  {
+    tms9900_debug_operands ("*rt", insn, operands, 1);
+    return("b    *r11");
+  }
+  [(set_attr "length" "2")])
+
+
+;;-------------------------------------------------------------------
+;;  Comparison Instructions
+;;-------------------------------------------------------------------
+
+;; cmp to zero is done explicitly or implicitly so can just do a mov to self to
+;; compare.  BUT if self is a ROM target then that could invoke unintended side
+;; effects like bank switching, so mov to temp reg r0 instead.  This also saves
+;; 2 bytes for mem label compares.
+
+;;-------------------------------------
+(define_insn "tsthi"
+  [(set (cc0)
+	(match_operand:HI 0 "nonimmediate_operand" "rR,Q"))]
+  ""
+  {
+    tms9900_debug_operands ("tsthi", insn, operands, 1);
+    return("mov  %0, r0");
+  }
+  [(set_attr "length" "2,6")])
+
+
+;;-------------------------------------
+(define_insn "tstqi"
+  [(set (cc0)
+	(match_operand:QI 0 "nonimmediate_operand" "rR,Q"))]
+  ""
+  {
+    tms9900_debug_operands ("tstqi", insn, operands, 1);
+    return("movb %0, r0");
+  }
+  [(set_attr "length" "2,6")])
+ 
+;;-------------------------------------
+;; Compare 2 16-bit values.
+;;
+;; If we are comparing a memory value to an immediate, it is cheaper to
+;; compare to a literal than load an immediate to a scratch reg and compare to that
+;; reg, so define insn as a split with the condition that op0 is not a reg and
+;; op1 is a constant int.  If so, rewrite as a compare to a forced mem const.
+
+(define_insn_and_split "cmphi"
+  [(set (cc0)
+	(compare (match_operand:HI 0 "nonimmediate_operand" "rR,rR,Q,Q,r")
+		 (match_operand:HI 1 "general_operand"      "rR,Q,rR,Q,i")))]
+  ""
+  {
+    tms9900_debug_operands ("split_cmphi", insn, operands, 2);
+
+    if (which_alternative < 4)
+      return "c    %0, %1";
+    else
+      return "ci   %0, %1";
+  }
+  "CONST_INT_P (operands[1]) && !REG_P (operands[0])"
+  [(set (cc0)
+	(compare (match_dup 0)
+		 (match_dup 1)))]
+  {
+    tms9900_debug_operands ("split_cmphi", NULL_RTX, operands, 2);
+
+    int val = INTVAL (operands[1]) & 0xffff;
+    operands[1] = force_const_mem (HImode, GEN_INT (val));
+  }
+  [(set_attr "length" "2,4,4,6,4")]
+)
+
+;;-------------------------------------
+;
+; TODO expand to nonimmediate, not just memory
+;
+; Replace:
+;   mov @x, r1
+;   cmp @y, r1
+;
+; With:
+;   cmp @y, @x
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "")
+	(match_operand:HI 1 "memory_operand" ""))
+   (set (cc0)
+        (compare (match_operand:HI 2 "memory_operand" "")
+                 (match_dup 0)))]
+  ""
+  [(set (cc0) 
+        (compare (match_dup 2)
+                 (match_dup 1)))]
+  {
+    tms9900_debug_operands ("peep-movhi-cmphi", NULL_RTX, operands, 3);
+  }
+)
+
+;;-------------------------------------
+;
+; Replace:
+;   movb @x,r1 
+;   cmpb @y,r1
+;
+; With:
+;   cmpb @y,@x
+
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "")
+	(match_operand:QI 1 "memory_operand" ""))
+   (set (cc0)
+        (compare (match_operand:QI 2 "memory_operand" "")
+                 (match_dup 0)))]
+  ""
+  [(set (cc0) 
+        (compare (match_dup 2)
+                 (match_dup 1)))]
+  {
+    tms9900_debug_operands ("peep-movqi-cmpqi", NULL_RTX, operands, 3);
+  }
+)
+
+;;-------------------------------------
+;; Compare 2 8-bit values.
+;;
+;; Byte compares using immediates are problematic since the lower 8 bits are
+;; unpredictable, so immediates are not allowed.  Compares to immediates are
+;; handled by a split which replaces the immediate with a memory ref to a literal.
+;;
+;; The exception for compare to zero has been removed as adding a clr
+;; instruction is longer than storing a zero byte in the constant pool 
+;; 
+;; Emitting a constant doesn't work if done as an insn.  Forcing a constant in an
+;; expand doesn't work either in all cases.  Defining a split caused a compliation
+;; abort when the cmpqi insn didn't have a match for a comparison to an immediate.
+;; Using define_insn_and_split seems to solve the problem for all cases so far.
+;;
+;; This is a good candidate for define_insn_and_rewrite but this doesn't exist yet
+;; in gcc4.4.0
+;;
+;; For some unknown reason, adding specific constraints here causes a reload error.
+;; Making a general constraint with a worst-case length of 6 bytes avoid the issue.
+
+(define_insn_and_split "cmpqi"
+  [(set (cc0)
+	(compare (match_operand:QI 0 "nonimmediate_operand" "=g")
+		 (match_operand:QI 1 "general_operand"      "g")))]
+  ""
+  "cb   %0, %1"
+  "CONST_INT_P (operands[1])"
+  [(set (cc0)
+ 	(compare (match_dup 0)
+ 		 (match_dup 1)))]
+  {
+    tms9900_debug_operands ("split_cmpqi", NULL_RTX, operands, 2);
+    int val = INTVAL (operands[1]) & 0xff;
+    operands[1] = force_const_mem (QImode, GEN_INT (val));
+  }
+  [(set_attr "length" "6")]
+)
+
+;;-------------------------------------
+;; Target specific insns to clr (set to 0) and seto (set to -1) for byte and
+;; word.  NOTE CLR and SETO operate on 16-bit values so QI variants are constrained
+;; to registers only
+
+(define_insn "tms9900_clrqi"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+        (const_int 0))]
+  ""
+  "clr  %0"
+  [(set_attr "length" "2")])
+
+(define_insn "tms9900_setoqi"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+        (const_int 255))]
+  ""
+  "seto %0"
+  [(set_attr "length" "2")])
+
+(define_insn "tms9900_clrhi"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
+        (const_int 0))]
+  ""
+  "clr  %0"
+  [(set_attr "length" "2,4")])
+
+(define_insn "tms9900_setohi"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
+        (const_int 65535))]
+  ""
+  "seto %0"
+  [(set_attr "length" "2,4")])
+
+;;-------------------------------------------------------------------
+;;  Move Operations
+;;-------------------------------------------------------------------
+  ; "movb %1, %0"
+  ;
+  ;  We need a constraint of i or we get the error "insn does not satisfy its
+  ; constraints".  Confusing since the split should remove the immediate.  If we
+  ; change general to nonimmed then we get "unrecognizable insn" so it seems we
+  ; need to add alternate 4 even though it never actually can be used.
+  ;
+  ; nvm setoqi had register_operand as constraint
+
+(define_expand "movqi"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "")
+        (match_operand:QI 1 "general_operand"      ""))]
+  ""
+  {
+    tms9900_debug_operands ("movqi", NULL_RTX, operands, 2);
+
+    if (CONST_INT_P (operands[1]))
+    {
+      int val = INTVAL (operands[1]) & 0xff;
+      if (val == 0 && REG_P (operands[0]))
+      {
+        emit_insn (gen_tms9900_clrqi (operands[0]));
+        DONE;
+      }
+
+      if (val == 0xff && REG_P (operands[0]))
+      {
+        emit_insn (gen_tms9900_setoqi (operands[0]));
+        DONE;
+      }
+
+      tms9900_inline_debug ("; movqi replace const with label\n");
+      operands[1] = force_const_mem (QImode, operands[1]);
+    }
+
+    emit_insn (gen_tms9900_movqi (operands[0], operands[1]));
+    DONE;
+  }
+)
+
+;;-------------------------------------------------------------------
+;; Native move byte value
+;;
+;; NOTE - this native method does not allow immediates
+
+(define_insn "tms9900_movqi"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=r,rR>,Q,  rR>,Q")
+        (match_operand:QI 1 "general_operand"      "r, rR>,rR>,Q,  Q"))]
+  ""
+  {
+    tms9900_debug_operands ("tms9900_movqi", insn, operands, 2);
+
+    /* Register to Register - If src has an offset, then it has been downgraded from a
+     * HI, so move the entire 16-bit word and do a byte swap */
+
+    if (which_alternative == 0 &&
+        REG_P (operands[1]) && REG_OFFSET (operands[1]) == 1 &&
+        ORIGINAL_REGNO (operands[1]) == REGNO (operands[1]))
+    {
+      output_asm_insn ("mov  %1, %0", operands);
+      output_asm_insn ("swpb %0 ; movqi subreg truncate", operands);
+    }
+    else
+      output_asm_insn ("movb %1, %0", operands);
+
+    return "";
+  }
+  [(set_attr "length" "4,2,4,4,6")]
+)
+
+;;-------------------------------------------------------------------
+;; Move two-byte value
+;;
+;; Constraints O and M are listed as separate alternatives to allow SETO or CLR
+;; to be used which would have a different length to LI.  SETO and CLR can also
+;; work with R and Q.
+
+(define_expand "movhi"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "")
+        (match_operand:HI 1 "general_operand"      ""))]
+  ""
+  {
+    tms9900_debug_operands ("movhi", NULL_RTX, operands, 2);
+
+    if (CONST_INT_P (operands[1]))
+    {
+      int val = INTVAL(operands[1]) & 0xffff;
+
+      if (val == 0)
+      {
+        emit_insn (gen_tms9900_clrhi (operands[0]));
+        DONE;
+      }
+
+      if (val == 0xffff)
+      {
+        emit_insn (gen_tms9900_setohi (operands[0]));
+        DONE;
+      }
+
+      if (!REG_P (operands[0]))
+      {
+        tms9900_inline_debug ("; movhi replace const with label\n");
+        operands[1] = force_const_mem (HImode, operands[1]);
+      }
+    }
+
+    emit_insn (gen_tms9900_movhi (operands[0], operands[1]));
+    DONE;
+  }
+)
+
+(define_insn "tms9900_movhi"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,  Q,r")
+        (match_operand:HI 1 "general_operand"      "rR>, Q,  rR>,Q,i"))]
+  ""
+  {
+    tms9900_debug_operands ("movhi", insn, operands, 2);
+    tms9900_inline_debug ("; movhi alt=%d\n", which_alternative);
+
+    if (which_alternative == 4)
+    {
+      return("li   %0, %1");
+    }
+    else
+    {
+      return("mov  %1, %0");
+    }
+  }
+  [(set_attr "length" "2,4,4,6,4")])
+
+;;-------------------------------------------------------------------
+;; Move four-byte value as two 2-byte regs.  If immediate, emit two movhi insns
+;; with high and low part of constants.  Constraints O and M are allowed so we
+;; can issue seto or clr for -1 and 0 respectively
+;;
+;; Changed this from an expand back to an insn - why?
+;;-------------------------------------------------------------------
+(define_insn "movsi"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR>,rR>,Q,  Q,r, r")
+	(match_operand:SI 1 "general_operand"      "rR>, Q,  rR>,Q,OM,n"))]
+  ""
+  {
+    tms9900_debug_operands ("movsi", insn, operands, 2);
+    tms9900_inline_debug ("; movsi alt=%d\n", which_alternative);
+
+    rtx args[4];
+    args[0] = gen_highpart (HImode, operands[0]);
+    args[1] = gen_lowpart (HImode, operands[0]);
+
+    if (which_alternative >= 4)
+    {
+      if (!CONST_INT_P (operands[1]))
+        gcc_unreachable();
+
+      args[2] = gen_rtx_CONST_INT (HImode, ((UINTVAL(operands[1])&0xffff0000)>>16));
+      args[3] = gen_rtx_CONST_INT (HImode, (UINTVAL(operands[1])&0xffff));
+      tms9900_inline_debug ("; movsi op1=%08X hi=%04X lo=%04X\n",
+                            INTVAL (operands[1]),
+                            INTVAL (args[2]),
+                            INTVAL (args[3]));
+
+      if (INTVAL(args[2]) == 0xffff)
+        output_asm_insn("seto %0", args);
+      else if (INTVAL(args[2]) == 0)
+        output_asm_insn("clr  %0", args);
+      else
+        output_asm_insn("li   %0, %2", args);
+
+      if (INTVAL(args[3]) == 0xffff)
+        output_asm_insn("seto %1", args);
+      else if (INTVAL(args[3]) == 0)
+        output_asm_insn("clr  %1", args);
+      else
+        output_asm_insn("li   %1, %3", args);
+    }
+    else
+    {
+      args[2] = gen_highpart (HImode, operands[1]);
+      args[3] = gen_lowpart (HImode, operands[1]);
+      output_asm_insn("mov  %2, %0", args);
+      output_asm_insn("mov  %3, %1", args);
+    }
+    return("");
+  }
+  [(set_attr "length" "4,8,8,12,4,8")])
+
+;;-------------------------------------------------------------------
+;; Type Conversions
+;;-------------------------------------------------------------------
+
+(define_insn "*zero_extendqihi2_subreg"
+  [(set (match_operand:HI 0 "register_operand" "=r,r,r")
+	(zero_extend:HI (subreg:HI (match_operand:QI 1 "nonimmediate_operand" "0,R,Q") 0)))]
+  ""
+  {
+    tms9900_debug_operands ("zero_extendqihi2_subreg", insn, operands, 2);
+
+    if (which_alternative > 0)
+    {
+      output_asm_insn ("movb %1, %0", operands);
+    }
+    output_asm_insn ("srl  %0, 8", operands);
+    return("");
+  }
+  [(set_attr "length" "2,4,6")])
+
+;;-------------------------------------------------------------------
+;; Zero Extend
+;; If op1 is not a register, we need to mov the value to op0 first.  As a
+;; result, R and Q constraints are different length to r.
+;;-------------------------------------
+
+(define_insn "zero_extendqihi2"
+  [(set (match_operand:HI 0 "register_operand" "=r,r,r")
+	(zero_extend:HI (match_operand:QI 1 "nonimmediate_operand" "0,R,Q")))]
+  ""
+  {
+    tms9900_debug_operands ("zero_extendqihi2", insn, operands, 2);
+
+    if (which_alternative > 0)
+    {
+      output_asm_insn ("movb %1, %0", operands);
+    }
+    output_asm_insn ("srl  %0, 8", operands);
+    return("");
+  }
+  [(set_attr "length" "2,4,6")])
+
+;;-------------------------------------
+; TODO Could do a gen_lowpart into op0 to prevent the tmp
+(define_expand "zero_extendqisi2"
+  [(set (match_operand:SI 0 "register_operand" "")
+	(zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "")))]
+  ""
+  {
+    tms9900_debug_operands ("zero_extendqisi2", NULL_RTX, operands, 2);
+    rtx tmp = gen_reg_rtx (HImode);
+    emit_insn (gen_zero_extendqihi2 (tmp, operands[1]));
+    emit_insn (gen_zero_extendhisi2 (operands[0], tmp));
+    DONE;
+  }
+)
+
+(define_insn "zero_extendhisi2"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR,Q")
+	(zero_extend:SI (match_operand:HI 1 "general_operand" "g,g")))]
+  ""
+  {
+    tms9900_debug_operands ("zero_extendhisi2", insn, operands, 2);
+    rtx args[3];
+    args[0] = gen_highpart (HImode, operands[0]);
+    args[1] = gen_lowpart (HImode, operands[0]);
+    args[2] = operands[1];
+
+    output_asm_insn("mov  %2, %1", args);
+    output_asm_insn("clr  %0", args);
+    return("");
+  }
+  [(set_attr "length" "4,8")])
+
+
+;;-------------------------------------------------------------------
+;; Sign Extend
+;;-------------------------------------------------------------------
+
+(define_insn "extendqihi2"
+  [(set (match_operand:HI 0 "register_operand" "=r,r,r")
+	(sign_extend:HI (match_operand:QI 1 "nonimmediate_operand" "0,R,Q")))]
+  ""
+  {
+    tms9900_debug_operands ("extendqihi2", insn, operands, 2);
+    if (which_alternative > 0)
+    {
+      output_asm_insn ("movb %1, %0", operands);
+    }
+    output_asm_insn("sra  %0, 8", operands);
+    return("");
+  }
+  [(set_attr "length" "2,4,6")])
+			 
+
+(define_expand "extendqisi2"
+  [(set (match_operand:SI 0 "register_operand" "")
+	(sign_extend:SI (match_operand:QI 1 "nonimmediate_operand" "")))]
+  ""
+  {
+    tms9900_debug_operands ("extendqisi2", NULL_RTX, operands, 2);
+    rtx tmp = gen_reg_rtx (HImode);
+    emit_insn (gen_extendqihi2 (tmp, operands[1]));
+    emit_insn (gen_extendhisi2 (operands[0], tmp));
+    DONE;
+  }
+)
+
+;;-------------------------------------
+(define_insn "extendhisi2"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR,Q")
+	(sign_extend:SI (match_operand:HI 1 "general_operand" "g,g")))]
+  ""
+  {
+    tms9900_debug_operands ("extendhisi2", insn, operands, 2);
+    rtx args[3];
+    rtx offset[1];
+    args[0] = gen_highpart (HImode, operands[0]);
+    args[1] = gen_lowpart (HImode, operands[0]);
+    args[2] = operands[1];
+
+    if(which_alternative == 1)
+      offset[0] = GEN_INT(6);
+    else
+      offset[0] = GEN_INT(4);
+
+    output_asm_insn("mov  %2, %1", args);
+    /* sign extend.  If highpart is negative, seto, else clr.  This is slightly
+     * cheaper (either 20 or 30 cycles) than doing sra 16 (44 cycles) */
+    output_asm_insn("seto %0", args);
+    output_asm_insn("jlt  $+%0", offset);
+    output_asm_insn("clr  %0", args);
+    return("");
+  }
+  [(set_attr "length" "8,12")])
+
+;;-------------------------------------------------------------------
+;; Truncate
+;
+;  swpb will suffice for non-strict in place truncation.  There is no strict variant of
+;  truncate so I am assuming we doesn't care about unused bits.
+;;-------------------------------------
+
+(define_insn "trunchiqi2"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,Q")
+	(truncate:QI (match_operand:HI 1 "nonimmediate_operand" "0,0")))]
+  ""
+  {
+    tms9900_debug_operands ("trunchiqi2", insn, operands, 2);
+    return ("swpb %0");
+  }
+  [(set_attr "length" "2,4")])
+
+(define_insn "truncsihi2"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
+	(truncate:HI (match_operand:SI 1 "nonimmediate_operand" "rR>,Q,rR>,Q")))]
+  ""
+  {
+    tms9900_debug_operands ("truncsihi2", insn, operands, 2);
+    operands[1] = gen_lowpart (HImode, operands[1]);
+    return "mov  %1, %0";
+  }
+  [(set_attr "length" "2,4,4,6")])
+
+(define_expand "truncsiqi2"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "")
+	(truncate:QI (match_operand:SI 1 "nonimmediate_operand" "")))]
+  ""
+  {
+    tms9900_debug_operands ("truncsiqi2", NULL_RTX, operands, 2);
+    emit_insn (gen_truncsihi2 (operands[0], operands[0]));
+    emit_insn (gen_trunchiqi2 (operands[0], operands[0]));
+    DONE;
+  }
+)
+
+;;-------------------------------------------------------------------
+;;  Branch Instructions
+;;-------------------------------------------------------------------
+
+
+;;-------------------------------------------------------------------
+;; Jump if equal
+(define_insn "beq"
+  [(set (pc)
+	(if_then_else (eq (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  {
+    tms9900_debug_operands ("beq", insn, operands, 1);
+    return(output_branch("jeq", "jne", get_attr_length(insn)));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 12)))])
+
+
+;;-------------------------------------
+;; Jump if equal, reversed comparison operands
+(define_insn "*beq_reversed"
+  [(set (pc)
+	(if_then_else (eq (cc0)
+			  (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  {
+    tms9900_debug_operands ("*beq_reversed", insn, operands, 1);
+    return(output_branch("jne", "jeq", get_attr_length(insn)));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 12)))])
+
+
+;;-------------------------------------------------------------------
+;; Jump if not equal
+(define_insn "bne"
+  [(set (pc)
+	(if_then_else (ne (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  {
+    tms9900_debug_operands ("bne", insn, operands, 1);
+    return output_branch(\"jne\", \"jeq\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 12)))])
+
+
+;;-------------------------------------
+;; Jump if not equal, reversed comparison operands
+(define_insn "*bne_reversed"
+  [(set (pc)
+	(if_then_else (ne (cc0)
+			  (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  {
+    tms9900_debug_operands ("*bne_reversed", insn, operands, 1);
+    return output_branch(\"jeq\", \"jne\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 12)))])
+
+
+;;-------------------------------------------------------------------
+;; Jump if unsigned less than
+(define_insn "bltu"
+  [(set (pc)
+	(if_then_else (ltu (cc0)
+			   (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  {
+    tms9900_debug_operands ("bltu", insn, operands, 1);
+    return output_branch(\"jl\", \"jhe\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 12)))])
+
+
+;;-------------------------------------
+;; Jump if unsigned less than, reversed comparison operands
+(define_insn "*bltu_reversed"
+  [(set (pc)
+	(if_then_else (ltu (cc0)
+			   (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  {
+    tms9900_debug_operands ("*bltu_reversed", insn, operands, 1);
+    return output_branch(\"jhe\", \"jl\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 12)))])
+
+
+;;-------------------------------------------------------------------
+;; Jump if unsigned less than or equal
+(define_insn "bleu"
+  [(set (pc)
+	(if_then_else (leu (cc0)
+			   (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  {
+    tms9900_debug_operands ("bleu", insn, operands, 1);
+    return output_branch(\"jle\", \"jh\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 12)))])
+
+
+;;-------------------------------------
+;; Jump if unsigned less than or equal, reversed comparison operands
+(define_insn "*bleu_reversed"
+  [(set (pc)
+	(if_then_else (leu (cc0)
+			   (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  {
+    tms9900_debug_operands ("*bleu_reversed", insn, operands, 1);
+    return output_branch(\"jh\", \"jle\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 12)))])
+
+
+;;-------------------------------------------------------------------
+;; Jump if unsigned greater than
+(define_insn "bgtu"
+  [(set (pc)
+	(if_then_else (gtu (cc0)
+			   (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  {
+    tms9900_debug_operands ("bgtu", insn, operands, 1);
+    return output_branch(\"jh\", \"jle\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 12)))])
+
+
+;;-------------------------------------
+;; Jump if unsigned greater than, reversed comparison operands
+(define_insn "*bgtu_reversed"
+  [(set (pc)
+	(if_then_else (gtu (cc0)
+			   (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  {
+    tms9900_debug_operands ("*bgtu_reversed", insn, operands, 1);
+    return output_branch(\"jle\", \"jh\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 12)))])
+
+
+;;-------------------------------------------------------------------
+;; Jump if unsigned greater than or equal
+(define_insn "bgeu"
+  [(set (pc)
+	(if_then_else (geu (cc0)
+			   (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  {
+    tms9900_debug_operands ("bgeu", insn, operands, 1);
+    return output_branch(\"jhe\", \"jl\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 12)))])
+
+
+;;-------------------------------------
+;; Jump if unsigned greater than or equal, reversed comparison operands
+(define_insn "*bgeu_reversed"
+  [(set (pc)
+	(if_then_else (geu (cc0)
+			   (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  {
+    tms9900_debug_operands ("*bgeu_reversed", insn, operands, 1);
+    return output_branch(\"jl\", \"jhe\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 12)))])
+
+
+;;-------------------------------------------------------------------
+;; Jump if less than
+(define_insn "blt"
+  [(set (pc)
+	(if_then_else (lt (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  {
+    tms9900_debug_operands ("blt", insn, operands, 1);
+    return output_branch(\"jlt\", \"GE\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 18)
+				      (const_int 12)))])
+
+
+;;-------------------------------------
+;; Jump if less than, reversed comparison operands
+; Was commented out
+(define_insn "*blt_reversed"
+  [(set (pc)
+	(if_then_else (lt (cc0)
+			  (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  {
+    tms9900_debug_operands ("*blt_reversed", insn, operands, 1);
+    return output_branch(\"GE\", \"jlt\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 14)))])
+
+
+;;-------------------------------------------------------------------
+;; Jump if less than or equal
+(define_insn "ble"
+  [(set (pc)
+	(if_then_else (le (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  {
+    tms9900_debug_operands ("ble", insn, operands, 1);
+    return output_branch(\"LE\", \"jgt\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 14)))])
+
+
+;;-------------------------------------
+;; Jump if less than or equal, reversed comparison operands
+(define_insn "*ble_reversed"
+  [(set (pc)
+	(if_then_else (le (cc0)
+			  (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  {
+    tms9900_debug_operands ("*ble_reversed", insn, operands, 1);
+    return output_branch(\"jgt\", \"LE\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 18)
+				      (const_int 12)))])
+
+
+;;-------------------------------------------------------------------
+;; Jump if greater than
+(define_insn "bgt"
+  [(set (pc)
+	(if_then_else (gt (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  {
+    tms9900_debug_operands ("bgt", insn, operands, 1);
+    return output_branch(\"jgt\", \"LE\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 18)
+				      (const_int 12)))])
+
+
+;;-------------------------------------
+;; Jump if greater than, reversed comparison operands
+; Was commented out
+(define_insn "*bgt_reversed"
+  [(set (pc)
+	(if_then_else (gt (cc0)
+			  (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  {
+    tms9900_debug_operands ("*bgt_reversed", insn, operands, 1);
+    return output_branch(\"LE\", \"jgt\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 14)))])
+
+
+;;-------------------------------------------------------------------
+;; Jump if greater than or equal
+; Was commented out
+(define_insn "bge"
+  [(set (pc)
+	(if_then_else (ge (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  {
+    tms9900_debug_operands ("bge", insn, operands, 1);
+    return output_branch(\"GE\", \"jlt\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 14)))])
+
+
+;;-------------------------------------
+;; Jump if greater than or equal, reversed comparison operands
+(define_insn "*bge_reversed"
+  [(set (pc)
+	(if_then_else (ge (cc0)
+			  (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  {
+    tms9900_debug_operands ("*bge_reversed", insn, operands, 1);
+    return output_branch(\"jlt\", \"GE\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 18)
+				      (const_int 12)))])
+
+
+;;-------------------------------------------------------------------
+;;  Jump Operations
+;;-------------------------------------------------------------------
+
+
+;;-------------------------------------------------------------------
+;; Unconditional jump to label
+(define_insn "jump"
+  [(set (pc)
+	(label_ref (match_operand 0 "" "")))]
+  ""
+  {
+    tms9900_debug_operands ("jump", insn, operands, 1);
+    return output_jump(get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 14)
+				      (const_int 12)))])
+
+
+;;-------------------------------------------------------------------
+;; Unconditional jump using pointer
+(define_insn "indirect_jump"
+  [(set (pc) (match_operand:HI 0 "nonimmediate_operand" "r,Q"))]
+  ""
+  {
+    tms9900_debug_operands ("indirect_jump", insn, operands, 1);
+    return "b    %0";
+  }
+  [(set_attr "length" "2,4")])
+
+
+;;-------------------------------------------------------------------
+;; Unconditional jump using jump table
+(define_insn "tablejump"
+  [(set (pc) (match_operand:HI 0 "nonimmediate_operand" "rR,Q"))
+   (use (label_ref (match_operand 1 "" "")))]
+  ""
+  {
+    tms9900_debug_operands ("tablejump", insn, operands, 1);
+    output_asm_insn("mov  %0, r0", operands);
+    output_asm_insn("b    *r0",    operands);
+    return(""); 
+  }
+  [(set_attr "length" "4,6")])
+
+
+;;-------------------------------------------------------------------
+;;  Bit Shift Operations
+;;-------------------------------------------------------------------
+
+;; NOTE : On the TMS9900 a shift count of 0 is interpreted as
+;; shift by 16, so test for 0 and jump over the shift if true.  Do the same in
+;; all other shift by register insns as well.
+
+;; Accept any shift count but if it is not a constant, load it into r0 first.
+
+;; If we are asked to shift by a constant 0 then the
+;; compiler is being stupid so detect this (constraint 'O') and emit nothing
+
+;;-------------------------------------------------------------------
+;; Arithmetic shift left.
+;;
+;;-------------------------------------------------------------------
+(define_insn "ashlhi3"
+  [(set (match_operand:HI 0 "register_operand" "=r,r,r,r")
+	(ashift:HI (match_operand:HI 1 "register_operand" "0,0,0,0")
+		   (match_operand:HI 2 "general_operand" "rR,Q,O,i")))]
+  ""
+  {
+    tms9900_debug_operands ("ashlhi3", insn, operands, 3);
+    if(which_alternative < 2)
+    {
+      output_asm_insn("mov  %2, r0",   operands);
+      output_asm_insn("jeq  $+4",    operands);
+      output_asm_insn("sla  %0, 0",  operands);
+    }
+    else if (which_alternative > 2)
+    {
+      output_asm_insn("sla  %0, %2", operands);
+    }
+    return(""); 
+  }
+  [(set_attr "length" "6,8,0,2")])
+
+
+;;-------------------------------------
+(define_insn "ashlqi3"
+  [(set (match_operand:QI 0 "register_operand" "=r,r,r,r")
+        (ashift:QI (match_operand:QI 1 "register_operand" "0,0,0,0")
+                   (match_operand:HI 2 "general_operand" "rR,Q,O,i")))]
+  ""
+  {
+    tms9900_debug_operands ("ashlqi3", insn, operands, 3);
+    if(which_alternative < 2)
+    {
+      output_asm_insn("mov  %2, r0",   operands);
+      output_asm_insn("jeq  $+8",       operands);  /* If shift count is zero, do nothing */
+      output_asm_insn("andi %0, >FF00", operands);
+      output_asm_insn("sla  %0, 0",     operands);
+    }
+    else if (which_alternative > 2)
+    {
+      output_asm_insn("andi %0, >FF00", operands);
+      output_asm_insn("sla  %0, %2",    operands);
+    }
+    return(""); 
+  }
+  [(set_attr "length" "10,12,0,6")])
+
+
+;;-------------------------------------------------------------------
+;; Arithmetic shift left (for QI mode)
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "=r,r")
+	(sign_extend:HI(match_operand:QI 1 "register_operand" "r,r")))
+   (set (match_operand:HI 2 "register_operand" "=r,r")
+	(ashift:HI (match_dup 0)
+                   (plus:HI (match_operand:HI 3 "const_int_operand" "i,i")
+                            (match_operand:HI 4 "const_int_operand" "i,i"))))]
+  ""
+  [(set (match_dup 2)
+        (match_dup 1))
+   (set (match_dup 2)
+        (ashift:QI (match_dup 2)
+                   (match_dup 3)))]
+  {
+    tms9900_debug_operands ("peep-alsqi", NULL_RTX, operands, 5);
+  }
+ )
+
+
+;;-------------------------------------
+(define_insn "ashrhi3"
+  [(set (match_operand:HI 0 "register_operand" "=r,r,r,r")
+	(ashiftrt:HI (match_operand:HI 1 "register_operand" "0,0,0,0")
+		     (match_operand:HI 2 "general_operand" "rR,Q,O,i")))]
+  ""
+  {
+    tms9900_debug_operands ("ashrhi3", insn, operands, 3);
+    if(which_alternative < 2)
+    {
+      output_asm_insn("mov  %2, r0",   operands);
+      output_asm_insn("jeq  $+4",    operands);
+      output_asm_insn("sra  %0, 0",  operands);
+    }
+    else if (which_alternative > 2)
+    {
+      output_asm_insn("sra  %0, %2", operands);
+    }
+    return(""); 
+  }
+  [(set_attr "length" "6,8,0,2")])
+
+
+;;-------------------------------------
+(define_insn "ashrqi3"
+  [(set (match_operand:QI 0 "register_operand" "=r,r,r,r")
+	(ashiftrt:QI (match_operand:QI 1 "register_operand" "0,0,0,0")
+		     (match_operand:HI 2 "general_operand" "rR,Q,O,i")))]
+  ""
+  {
+    tms9900_debug_operands ("ashrqi3", insn, operands, 3);
+    if(which_alternative < 2)
+    {
+      output_asm_insn("mov  %2, r0",  operands);
+      output_asm_insn("jeq  $+4",    operands);
+      output_asm_insn("sra  %0, 0",  operands);
+    }
+    else if (which_alternative > 2)
+    {
+      output_asm_insn("sra  %0, %2",    operands);
+    }
+    return(""); 
+  }
+  [(set_attr "length" "6,8,0,2")])
+
+
+;;-------------------------------------
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "r,r")
+	(sign_extend:HI(match_operand:QI 1 "register_operand" "r,r")))
+   (set (match_operand:HI 3 "register_operand" "r,r")
+	(ashiftrt:HI (match_operand:HI 4 "register_operand" "0,0")
+		     (match_operand:HI 5 "general_operand" "rRQ,i")))
+   (set (match_operand:QI 6 "register_operand" "r,r")
+        (subreg:QI (match_operand:HI 7 "register_operand" "3,3") 1))]
+  ""
+  [(set (match_dup 6)
+        (match_dup 1))
+   (set (match_dup 6)
+        (ashiftrt:QI (match_dup 6)
+                     (match_dup 5)))]
+  {
+    tms9900_debug_operands ("peep-asrhi", NULL_RTX, operands, 8);
+  }
+)
+
+
+;;-------------------------------------------------------------------
+;; Logical shift right
+
+
+
+;;-------------------------------------
+(define_insn "lshrhi3"
+  [(set (match_operand:HI 0 "register_operand" "=r,r,r,r")
+	(lshiftrt:HI (match_operand:HI 1 "register_operand" "0,0,0,0")
+		     (match_operand:HI 2 "general_operand" "rR,Q,O,i")))]
+  ""
+  {
+    tms9900_debug_operands ("lshrhi3", insn, operands, 3);
+    if(which_alternative < 2)
+    {
+      output_asm_insn("mov  %2, r0",  operands);
+      output_asm_insn("jeq  $+4",    operands);
+      output_asm_insn("srl  %0, 0",  operands);
+    }
+    else if (which_alternative > 2)
+    {
+      output_asm_insn("srl  %0, %2", operands);
+    }
+    return(""); 
+  }
+  [(set_attr "length" "6,8,0,2")])
+
+
+;;-------------------------------------
+; shift right 8 (extend) followed by truncate (swpb) negate each other so remove
+; by emitting a nop (const_int 0)
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "")
+	(lshiftrt:HI (match_dup 0)
+		     (const_int 8)))
+   (set (match_operand:QI 1 "register_operand" "")
+	(truncate:QI(match_dup 0)))]
+  ""
+  [(const_int 0)]
+  {
+    tms9900_debug_operands ("peep-asrhi", NULL_RTX, operands, 8);
+  }
+)
+
+;;-------------------------------------
+; same for arith shift 8
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "")
+	(ashiftrt:HI (match_dup 0)
+		     (const_int 8)))
+   (set (match_operand:QI 1 "register_operand" "")
+	(truncate:QI(match_dup 0)))]
+  ""
+  [(const_int 0)]
+  {
+    tms9900_debug_operands ("peep-asrhi", NULL_RTX, operands, 8);
+  }
+)
+
+;;-------------------------------------
+(define_insn "lshrqi3"
+  [(set (match_operand:QI 0 "register_operand" "=r,r,r,r")
+	(lshiftrt:QI (match_operand:QI 1 "register_operand" "0,0,0,0")
+		     (match_operand:HI 2 "general_operand" "rR,Q,O,i")))]
+  ""
+  {
+    tms9900_debug_operands ("lshrqi3", insn, operands, 3);
+    if(which_alternative < 2)
+    {
+      output_asm_insn("mov  %2, r0",  operands);
+      output_asm_insn("jeq  $+4",    operands);
+      output_asm_insn("srl  %0, 0",  operands);
+    }
+    else if (which_alternative > 2)
+    {
+      output_asm_insn("srl  %0, %2",    operands);
+    }
+    return(""); 
+  }
+  [(set_attr "length" "6,8,0,2")])
+
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "r,r")
+	(sign_extend:HI(match_operand:QI 1 "register_operand" "r,r")))
+   (set (match_operand:HI 3 "register_operand" "r,r")
+	(lshiftrt:HI (match_operand:HI 4 "register_operand" "0,0")
+		     (match_operand:HI 5 "general_operand" "rRQ,i")))
+   (set (match_operand:QI 6 "register_operand" "r,r")
+        (subreg:QI (match_operand:HI 7 "register_operand" "3,3") 1))]
+  ""
+  [(set (match_dup 6)
+        (match_dup 1))
+   (set (match_dup 6)
+        (lshiftrt:QI (match_dup 6)
+                     (match_dup 5)))]
+  {
+    tms9900_debug_operands ("peep-lsrhi", NULL_RTX, operands, 8);
+  }
+)
+      
+
+
+;;-------------------------------------------------------------------
+;; Rotate 
+
+
+;;-------------------------------------
+(define_expand "rotlhi3"
+  [(set (match_operand:HI 0 "register_operand" "=r,r")
+        (rotatert:HI (match_operand:HI 1 "register_operand" "0,0")
+                     (match_operand:HI 2 "general_operand" "rRQ,i")))]
+  ""
+  {
+    tms9900_debug_operands ("rotlhi3", NULL_RTX, operands, 3);
+    tms9900_inline_debug ("; rotlhi3 alt=%d\n", which_alternative);
+    if (GET_CODE (operands[2]) == CONST_INT)
+      operands[2] = GEN_INT ((16 - INTVAL (operands[2])) % 16);
+    else
+      {
+        rtx reg = gen_reg_rtx (HImode);
+        emit_insn (gen_subhi3 (reg, GEN_INT (16), operands[2]));
+        operands[2] = reg;
+      }
+    DONE;
+  })
+
+
+;;-------------------------------------
+(define_insn "rotrhi3"
+  [(set (match_operand:HI 0 "register_operand" "=r,r")
+        (rotatert:HI (match_operand:HI 1 "register_operand" "0,0")
+                     (match_operand:HI 2 "general_operand" "rRQ,i")))]
+  ""
+  "@
+  src  %0, 0
+  src  %0, %2" 
+ [(set_attr "length" "2,2")])
+
+
+;;-------------------------------------------------------------------
+;;  Bitwise Operations
+;;-------------------------------------------------------------------
+
+;;-------------------------------------------------------------------
+;; And
+;;
+;; Uses r0 as a clobber
+;;-------------------------------------
+(define_insn "andhi3"
+  [(set (match_operand:HI 0 "nonimmediate_operand"         "=rR>,rR>,Q,  Q,r,r,r,R>,Q")
+	(and:HI (match_operand:HI 1 "nonimmediate_operand" "0,   0,  0,  0,0,0,0,0, 0")
+		(match_operand:HI 2 "general_operand"      "rR>, Q,  rR>,Q,O,M,i,i, i")))]
+  ""
+  {
+    tms9900_debug_operands ("andhi3", insn, operands, 3);
+
+    /*  If the optimiser sees that we are doing an and operation with a constant
+     *  that is 0xFF or less then it assumes there is no need to extend any byte
+     *  parameters.  This is not true for tms9900 as we need to shift the MSB
+     *  into the LSB.  Check for offsets in the operands and emit shifts to get
+     *  the bytes into the right place. */
+
+    if (tms9900_operand_subreg_offset (operands[1], HImode))
+    {
+      tms9900_inline_debug ("; andhi3, op[1] off %d\n", REG_OFFSET (operands[1]));
+
+      /*  If the mask is a constant int of one byte then cheaper to do a swpb
+       *  than sra. */
+      if (CONST_INT_P (operands[2]) &&
+          (INTVAL (operands[2]) & 0xff) == INTVAL (operands[2]))
+        output_asm_insn ("swpb %1 ; andhi extend op1", operands);
+      else
+        output_asm_insn ("sra  %1,8 ; andhi extend op1", operands);
+    }
+
+    if(which_alternative == 4)
+    {
+      /* Some paranoia here - confirm O constraint really has given us a const int of
+       * zero */
+      if (!CONST_INT_P (operands[2]) || (INTVAL(operands[2]) & 0xFFFF) != 0)
+        gcc_unreachable();
+
+      /* Result will be zero */
+      return("clr  %0");
+    }
+    else if(which_alternative == 5)
+    {
+      if (!CONST_INT_P (operands[2]) || (INTVAL(operands[2]) & 0xFFFF) != 0xFFFF)
+        gcc_unreachable();
+
+      /* No operation required */
+      return("");
+    }
+    else if(which_alternative == 6)
+    {
+      /* AND const value and register */
+      output_asm_insn("andi %0, %2", operands);
+    }
+    else if(which_alternative >= 7)
+    {
+      /* AND const value and memory */
+      if (!CONST_INT_P (operands[2]))
+        gcc_unreachable();
+
+      int val = ~INTVAL(operands[2]);
+      operands[2] = GEN_INT(val & 0xFFFF);
+      output_asm_insn("li   r0, %2", operands);
+      output_asm_insn("szc  r0, %0", operands);
+    }
+    else
+    {
+      /* AND against non-const value.  Copy to R0 as clobber, invert and SZC */
+      output_asm_insn("mov  %2, r0", operands);
+      output_asm_insn("inv  r0",     operands);
+      output_asm_insn("szc  r0, %0", operands);
+    }
+    return(""); 
+  }
+  [(set_attr "length" "6,8,8,10,2,0,4,6,8")])
+
+
+(define_insn "*andnothi"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
+	(and:HI (match_operand:HI 1 "nonimmediate_operand" "0,0,0,0")
+		(not:HI (match_operand:HI 2 "nonimmediate_operand" "rR>,Q,rR>,Q"))))]
+  ""
+  {
+    tms9900_debug_operands ("*andnothi", insn, operands, 3);
+    return "szc  %2, %0";
+  }
+  [(set_attr "length" "2,4,4,6")])
+
+
+; This handles reverse-order not-and combinations
+(define_insn "*not_andhi"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
+	(and:HI (not:HI (match_operand:HI 1 "nonimmediate_operand" "rR>,Q,rR>,Q"))
+                (match_operand:HI 2 "nonimmediate_operand" "0,0,0,0")))]
+  ""
+  {
+    tms9900_debug_operands ("*not_andhi", insn, operands, 3);
+    return "szc  %1, %0";
+  }
+  [(set_attr "length" "2,4,4,6")])
+
+
+;;-------------------------------------
+;;
+;; NOTE - we assume that constraint 'i' will only pass a CONST_INT as labels
+;; etc don't make sense in the context of a byte operation.  Assert if assumption
+;; not true.  If the constant evaluates to 0x00 or 0xFF then apply a short circuit.
+;; This will mean length is shorter than declared but that should not matter.
+;;
+(define_insn "andqi3"
+  [(set (match_operand:QI 0 "nonimmediate_operand"         "=rR>,rR>,Q,  Q,r,R>,Q")
+	(and:QI (match_operand:QI 1 "nonimmediate_operand" "0,   0,  0,  0,0,0, 0")
+		(match_operand:QI 2 "general_operand"      "rR>, Q,  rR>,Q,i,i, i")))]
+  ""
+  {
+    tms9900_debug_operands ("andqi3", insn, operands, 3);
+    if(which_alternative >= 4)
+    {
+      if (!CONST_INT_P (operands[2]))
+        gcc_unreachable();
+
+      int val = (INTVAL(operands[2]) << 8) & 0xFF00;
+
+      /* AND const value and register */
+      if(val == 0xff00)
+        return("");
+
+      if (which_alternative == 4)
+      {
+        /* AND const value and register */
+        operands[2] = GEN_INT(val);
+        output_asm_insn ("andi %0, %2", operands);
+      }
+      else
+      {
+        /* AND const value and memory */
+        operands[2] = GEN_INT(~val);
+        output_asm_insn("li   r0, %2", operands);
+        output_asm_insn("szcb r0, %0", operands);
+      }
+    }
+    else
+    {
+      output_asm_insn("movb %2, r0", operands);
+      output_asm_insn("inv  r0", operands);
+      output_asm_insn("szcb r0, %0", operands);
+    }
+    return("");
+  }
+  [(set_attr "length" "6,8,8,10,4,6,8")])
+
+
+(define_insn "*andnotqi"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
+	(and:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0")
+		(not:QI (match_operand:QI 2 "nonimmediate_operand" "rR>,Q,rR>,Q"))))]
+  ""
+  {
+    tms9900_debug_operands ("*not_andhi", insn, operands, 3);
+    return "szcb %2, %0";
+  }
+  [(set_attr "length" "2,4,4,6")])
+
+
+; This handles reverse-order not-and combinations
+(define_insn "*not_andqi"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
+	(and:QI (not:QI (match_operand:QI 1 "nonimmediate_operand" "rR>,Q,rR>,Q"))
+                (match_operand:QI 2 "nonimmediate_operand" "0,0,0,0")))]
+  ""
+  {
+    tms9900_debug_operands ("*not_andhi", insn, operands, 3);
+    return "szcb %1, %0";
+  }
+  [(set_attr "length" "2,4,4,6")])
+
+
+;;-------------------------------------------------------------------
+;; Or
+
+
+;;-------------------------------------
+(define_insn "iorhi3"
+  [(set (match_operand:HI 0 "nonimmediate_operand"         "=rR>,rR>,Q,  Q,r,r,r")
+	(ior:HI (match_operand:HI 1 "nonimmediate_operand" "%0,  0,  0,  0,0,0,0")
+		(match_operand:HI 2 "general_operand"      "rR>, Q,  rR>,Q,O,M,n")))]
+  ""
+  {
+    tms9900_debug_operands ("iorhi3", insn, operands, 3);
+
+    if (which_alternative < 4)
+      return("soc  %2, %0");
+    else
+    {
+      if (!CONST_INT_P (operands[2]))
+        gcc_unreachable();
+
+      int val = INTVAL(operands[2]) & 0xFFFF;
+      if(val == 0xFFFF)
+        return "seto %0";
+      else if(val == 0)
+        return "";
+
+      return "ori  %0, %2";
+    }
+  }
+  [(set_attr "length" "2,4,4,6,0,2,4")])
+
+
+;;-------------------------------------
+(define_insn "iorqi3"
+   [(set (match_operand:QI 0 "nonimmediate_operand"        "=rR>,Q,  rR>,Q,r")
+	(ior:QI (match_operand:QI 1 "nonimmediate_operand" "0,   0,  0,  0,0")
+		(match_operand:QI 2 "general_operand"      "rR>, rR>,Q,  Q,n")))]
+  ""
+  {
+    tms9900_debug_operands ("iorqi3", insn, operands, 3);
+
+    if (which_alternative < 4)
+      return ("socb %2, %0");
+    else
+    {
+      if (!CONST_INT_P (operands[2]))
+        gcc_unreachable();
+
+      int val = (INTVAL(operands[2]) << 8) & 0xFF00;
+      tms9900_inline_debug ("; iorqi3 val=%X\n", val);
+      rtx args[2];
+      args[0] = operands[0];
+      args[1] = GEN_INT(val);
+      /* AND const value and register */
+      if(val == 0)
+        return("");
+      else if(val == 0xff00)
+        output_asm_insn("seto %0", args);
+      else
+        output_asm_insn("ori  %0, %1", args);
+    }
+    return("");
+  }
+  [(set_attr "length" "2,4,4,6,4")])
+
+
+;;-------------------------------------------------------------------
+;; Xor
+
+
+;;-------------------------------------
+(define_insn "xorhi3"
+  [(set (match_operand:HI 0 "register_operand" "=r,r")
+	(xor:HI (match_operand:HI 1 "register_operand" "%0,0")
+		(match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
+  ""
+  {
+    tms9900_debug_operands ("xorhi3", insn, operands, 3);
+    return "xor  %2, %0";
+  }
+  [(set_attr "length" "2,4")])
+
+
+;;-------------------------------------
+;; This works for regs only as xor is 16-bit only and should not be used on
+;; memory locations as it will affect the neighbouring byte
+(define_insn "xorqi3"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+	(xor:QI (match_operand:QI 1 "register_operand" "%0")
+		(match_operand:QI 2 "nonimmediate_operand" "r")))]
+  ""
+  {
+    tms9900_debug_operands ("xorqi3", insn, operands, 3);
+    return "xor  %2, %0";
+  }
+  [(set_attr "length" "2")])
+
+
+;;-------------------------------------------------------------------
+;; Not
+;;-------------------------------------
+(define_insn "one_cmplhi2"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
+        (not:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))]
+  ""
+  {
+    tms9900_debug_operands ("one_cmplhi2", insn, operands, 2);
+    return "inv  %0";
+  }
+  [(set_attr "length" "2,4")])
+
+
+;;-------------------------------------
+;; This works for regs only as inv is 16-bit only and should not be used on
+;; memory locations as it will affect the neighbouring byte
+(define_insn "one_cmplqi2"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=r")
+        (not:QI (match_operand:QI 1 "nonimmediate_operand" "0")))]
+  ""
+  {
+    tms9900_debug_operands ("one_cmplqi2", insn, operands, 2);
+    return "inv  %0";
+  }
+  [(set_attr "length" "2")])
+
+
+;;-------------------------------------------------------------------
+;;  Arithmetic Operations
+;;-------------------------------------------------------------------
+
+
+;;-------------------------------------------------------------------
+;; Add
+;;
+;; Define addhi3 as an insn and split.  If operand[2] is a constant and
+;; operand[0] is not a register, then it is cheaper to add a memory constant than
+;; to load into an intermediate register and do add immediate.
+;;
+;; The constraints LMN are broken out separately as these can be done using
+;; inc[t] or dec[t] directly on a reg or memory location.
+;;
+;; The first two constraints with a dest of register only try to catch a missing
+;; extend where a subreg with an offset is passed in either operands[1] or
+;; operands[2].  This needs to be corrected using SRA.  A subreg with an offset
+;; will only appear in a register.  It is also assumed this will only happen
+;; when the destination is a register.
+;;-------------------------------------
+(define_insn_and_split "addhi3"
+  [(set (match_operand:HI 0 "nonimmediate_operand"          "=r, r,rR>,Q,  r,R>, R>,Q,  Q")
+	(plus:HI (match_operand:HI 1 "nonimmediate_operand" "%0, 0,0,  0,  0,0,  0, 0,  0")
+		 (match_operand:HI 2 "general_operand"      "rR>,Q,LMN,LMN,i,rR>,Q, rR>,Q")))]
+  ""
+  {
+    tms9900_debug_operands ("addhi3", insn, operands, 3);
+    tms9900_inline_debug ("; addhi3, alt=%d\n", which_alternative);
+
+    /* Either op[1] or op[2] may be a subreg with an offset. Correct them
+     * first.  Worst case length for these alternatives are 8 and 10 bytes */
+
+    if (tms9900_operand_subreg_offset (operands[2], HImode))
+    {
+      tms9900_inline_debug ("; addhi3, op[2] off %d\n", REG_OFFSET (operands[2]));
+      if (!find_regno_note (insn, REG_DEAD, REGNO (operands[2])))
+      {
+        /* operands[2] has an offset but is not dead so we cannot change it.
+         * Move to an intermediate and swap there.  Replace op[2] with
+         * scratch reg R0 */
+        output_asm_insn ("mov  %2,r0 ; addhi op2 to scratch", operands);
+        output_asm_insn ("sra  r0,8 ; addhi extend op2", operands);
+        operands[2] = gen_rtx_REG (HImode, HARD_R0_REGNUM);
+      }
+      else
+      {
+        /* operands[2] dies here so extend in place */
+        output_asm_insn ("sra  %2,8 ; addhi extend op2", operands);
+      }
+    }
+
+    /* check for subreg in operand[1].  If the source register is the same as
+     * the original register, or the original is a not mem expression, then
+     * the offset refers to the register, so correction is needed */
+    if (tms9900_operand_subreg_offset (operands[1], HImode))
+    {
+      tms9900_inline_debug ("; addhi3, op[1] off %d\n", REG_OFFSET (operands[1]));
+      output_asm_insn ("sra  %1,8 ; addhi extend op1", operands);
+    }
+
+    if (which_alternative == 2 || which_alternative == 3)
+    {
+      switch(INTVAL(operands[2]))
+      {
+      case 1:  return("inc  %0");
+      case -1: return("dec  %0");
+      case 2:  return("inct %0");
+      case -2: return("dect %0");
+      default: gcc_unreachable();
+      }
+    }
+    else if (which_alternative == 4)
+      return("ai   %0, %2");
+    else
+      return ("a    %2, %0");
+  }
+  "CONST_INT_P (operands[2]) && !REG_P (operands[0])"
+  [(set (match_dup 0)
+	(plus:HI (match_dup 1)
+		 (match_dup 2)))]
+  {
+    tms9900_debug_operands ("split_addhi3", NULL_RTX, operands, 2);
+
+    /*  Only force a constant if it is not a value we could use inc[t] or dec[t]
+     *  instead. */
+    if (INTVAL (operands[2]) < -2 && INTVAL (operands[2]) > 2)
+        operands[2] = force_const_mem (HImode, operands[2]);
+  }
+  [(set_attr "length" "8,10,4,2,2,2,4,4,6")])
+
+
+;;-------------------------------------
+
+(define_insn "tms9900_addqi3"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
+	(plus:QI (match_operand:QI 1 "nonimmediate_operand" "%0,0,0,0")
+		 (match_operand:QI 2 "general_operand" "rR>,Q,rR>,Q")))]
+  ""
+  {
+    tms9900_debug_operands ("tms9900_addqi3", insn, operands, 3);
+    return("ab   %2, %0");
+  }
+  [(set_attr "length" "2,4,4,6")])
+
+
+(define_expand "addqi3"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "")
+	(plus:QI (match_operand:QI 1 "nonimmediate_operand" "")
+		 (match_operand:QI 2 "general_operand" "")))]
+  ""
+  {
+    tms9900_debug_operands ("addqi3", NULL_RTX, operands, 3);
+    if (!rtx_equal_p (operands[0], operands[1]))
+    {
+      if (!rtx_equal_p (operands[0], operands[2]))
+      {
+        // We have 3 distinct operands.  Copy op1 to op0 and then proceed
+        emit_move_insn (operands[0], operands[1]);
+      }
+      else
+      {
+        // op0 and op2 are the same but we need op0 and op1 to be the same so
+        // swap 1 and 2
+        rtx tmp = operands[1];
+        operands[1] = operands[2];
+        operands[2] = tmp;
+      }
+    }
+
+    if (CONST_INT_P (operands[2]))
+    {
+      tms9900_inline_debug ("; addqi3 replace const with label\n");
+      operands[2] = force_const_mem (QImode, operands[2]);
+    }
+
+    emit_insn (gen_tms9900_addqi3 (operands[0], operands[1], operands[2]));
+    DONE;
+  }
+)
+
+;;-------------------------------------------------------------------
+;; Subtract
+;;
+;; See comment on addhi3
+;;
+;; Immediates are not allowed; they will be handled by addhi3
+;;
+;; As with addhi3, the first two constraints break out op0 as a register to
+;; allow a more conservative length when subreg offset corrections are applied.
+;;
+;; NOTE: no @ on constraints for op1 as subtract is not commutative
+;;-------------------------------------
+(define_insn "subhi3"
+  [(set (match_operand:HI 0 "nonimmediate_operand"           "=r, r,R>, R>,Q,  Q")
+        (minus:HI (match_operand:HI 1 "nonimmediate_operand" "0,  0,0,  0, 0,  0")
+                  (match_operand:HI 2 "nonimmediate_operand" "rR>,Q,rR>,Q, rR>,Q")))]
+  ""
+  {
+    tms9900_debug_operands ("subhi3", insn, operands, 3);
+    tms9900_inline_debug ("; addhi3, alt=%d\n", which_alternative);
+
+    /* Either op[1] or op[2] may be a subreg with an offset. Correct them
+     * first.  Worst case length for these alternatives are 8 and 10 bytes */
+
+    if (tms9900_operand_subreg_offset (operands[2], HImode))
+    {
+      tms9900_inline_debug ("; subhi3, op[2] off %d\n", REG_OFFSET (operands[2]));
+      if (!find_regno_note (insn, REG_DEAD, REGNO (operands[2])))
+      {
+        /* operands[2] has an offset but is not dead so we cannot change it.
+         * Move to an intermediate and swap there.  Replace op[2] with
+         * scratch reg R0 */
+        output_asm_insn ("mov  %2,r0 ; subhi op2 to scratch", operands);
+        output_asm_insn ("sra  r0,8 ; subhi extend op2", operands);
+        operands[2] = gen_rtx_REG (HImode, HARD_R0_REGNUM);
+      }
+      else
+      {
+        /* operands[2] dies here so extend in place */
+        output_asm_insn ("sra  %2,8 ; subhi extend op2", operands);
+      }
+    }
+
+    /* check for subreg in operand[1]. */
+    if (tms9900_operand_subreg_offset (operands[1], HImode))
+    {
+      tms9900_inline_debug ("; subhi3, op[1] off %d\n", REG_OFFSET (operands[1]));
+      output_asm_insn ("sra  %1,8 ; addhi extend op1", operands);
+    }
+
+    output_asm_insn ("; set %0=%1 minus %2", operands);
+    return "s    %2, %0";
+  }
+  [(set_attr "length" "8,10,2,4,4,6")])
+
+
+;;-------------------------------------
+(define_insn "*rsubihi"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(minus:HI (match_operand:HI 1 "immediate_operand" "i")
+		  (match_operand:HI 2 "register_operand" "0")))]
+  ""
+  {
+    tms9900_debug_operands ("*rsubihi", insn, operands, 3);
+    if (INTVAL(operands[1]) == -1)
+      output_asm_insn("inc  %0",operands);
+    else if (INTVAL(operands[1]) == 1)
+      output_asm_insn("dec  %0",operands);
+    else if (INTVAL(operands[1]) == -2)
+      output_asm_insn("inct %0",operands);
+    else if (INTVAL(operands[1]) == 2)
+      output_asm_insn("dect %0",operands);
+    else
+    {
+      operands[1] = GEN_INT(-INTVAL(operands[1]));
+      output_asm_insn("ai   %0, %1",operands);
+    }
+    output_asm_insn("neg  %0",operands);
+    return "";
+  }
+  [(set_attr "length" "6")])
+
+
+;;-------------------------------------
+(define_insn "tms9900_subqi3"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,Q,rR>,Q")
+	(minus:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0")
+		  (match_operand:QI 2 "nonimmediate_operand" "rR>,rR>,Q,Q")))]
+  ""
+  {
+    tms9900_debug_operands ("tms9900_subqi3", insn, operands, 3);
+    return "sb   %2, %0";
+  }
+  [(set_attr "length" "2,4,4,6")])
+
+
+;;-------------------------------------
+
+;; TODO as with subhi3, gcc will convert an immediate to a subtract to an
+;; immediate add of the negative value, so why do we need to expand and create
+;; constants?
+
+(define_expand "subqi3"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "")
+	(minus:QI (match_operand:QI 1 "general_operand" "")
+		  (match_operand:QI 2 "general_operand" "")))]
+  ""
+  {
+    tms9900_debug_operands ("subqi3", NULL_RTX, operands, 3);
+    if (!rtx_equal_p (operands[0], operands[1]))
+    {
+      if (!rtx_equal_p (operands[0], operands[2]))
+      {
+        // We have 3 distinct operands.  Copy op1 to op0 and then proceed
+        emit_move_insn (operands[0], operands[1]);
+      }
+      else
+      {
+        // op0 and op2 are the same but we need op0 and op1 to be the same so
+        // swap 1 and 2
+        rtx tmp = operands[1];
+        operands[1] = operands[2];
+        operands[2] = tmp;
+      }
+    }
+
+    if (CONST_INT_P (operands[2]))
+    {
+      tms9900_inline_debug ("; subqi3 replace const with label\n");
+      operands[2] = force_const_mem (QImode, operands[2]);
+    }
+
+    emit_insn (gen_tms9900_subqi3 (operands[0], operands[1], operands[2]));
+    DONE;
+  }
+)
+
+
+;;-------------------------------------------------------------------
+;; Multiply
+;;
+;;-------------------------------------
+; Expand for signed HI = QI x QI
+; TODO check sign of highpart of HI
+(define_expand "mulqihi3"
+   [(set (match_operand:HI 0 "register_operand" "=r")
+        (mult:HI (match_operand:QI 1 "register_operand" "r")
+                 (match_operand:QI 2 "register_operand" "rRQ>")))]
+  ""
+  {
+    tms9900_debug_operands ("mulqihi3", NULL_RTX, operands, 3);
+
+    rtx result = gen_reg_rtx (SImode);
+    rtx op1 = gen_reg_rtx (HImode);
+    rtx op2 = gen_reg_rtx (HImode);
+    emit_insn (gen_extendqihi2 (op1, operands[1]));
+    emit_insn (gen_extendqihi2 (op2, operands[2]));
+    emit_move_insn(gen_highpart (HImode, result), op1);
+    emit_insn(gen_mulnative(result, result, op2));
+    emit_move_insn (operands[0], gen_lowpart (HImode, result));
+    DONE;
+  }
+)
+
+;;-------------------------------------
+; Expand for unsigned HI = QI x QI
+;
+(define_expand "umulqihi3"
+   [(set (match_operand:HI 0 "register_operand" "=r")
+        (mult:HI (match_operand:QI 1 "register_operand" "r")
+                 (match_operand:QI 2 "register_operand" "rRQ>")))]
+  ""
+  {
+    tms9900_debug_operands ("umulqihi3", NULL_RTX, operands, 3);
+
+    rtx result = gen_reg_rtx (SImode);
+    rtx op1 = gen_reg_rtx (HImode);
+    rtx op2 = gen_reg_rtx (HImode);
+
+    /* Extend expects both regs to be the same but passing two operands is legit
+     * as it forces the compiler to copy them to one reg first */
+    emit_insn (gen_zero_extendqihi2 (op1, operands[1]));
+    emit_insn (gen_zero_extendqihi2 (op2, operands[2]));
+    emit_move_insn(gen_highpart (HImode, result), op1);
+    emit_insn(gen_mulnative(result, result, op2));
+    emit_move_insn (operands[0], gen_lowpart (HImode, result));
+    DONE;
+  }
+)
+
+;;-------------------------------------
+; Expand for signed SI = HI x HI
+;
+(define_expand "mulhisi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(mult:SI (zero_extend (match_operand:HI 1 "register_operand" "=r,r"))
+		 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
+  ""
+  {
+    tms9900_debug_operands ("mulqihi3", NULL_RTX, operands, 3);
+    tms9900_inline_debug ("; mulhisi3 alt=%d\n", which_alternative);
+
+    rtx result = gen_reg_rtx (SImode);
+    emit_move_insn(gen_highpart (HImode, result), operands[1]);
+    emit_insn(gen_mulnative(result, result, operands[2]));
+    emit_move_insn (operands[0], result);
+    DONE;
+  }
+)
+
+;;-------------------------------------
+; Expand for unsigned SI = HI x HI
+;
+(define_expand "umulhisi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(mult:SI (zero_extend (match_operand:HI 1 "register_operand" "=r,r"))
+		 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
+  ""
+  {
+    tms9900_debug_operands ("umulhisi3", NULL_RTX, operands, 3);
+    tms9900_inline_debug ("; umulhisi3 alt=%d\n", which_alternative);
+
+    rtx result = gen_reg_rtx (SImode);
+    emit_move_insn(gen_highpart (HImode, result), operands[1]);
+    emit_insn(gen_mulnative(result, result, operands[2]));
+    emit_move_insn (operands[0], result);
+    DONE;
+  }
+)
+
+;;-------------------------------------
+; expand HI=HIxHI to native SI=SIxHI
+
+(define_expand "mulhi3"
+  [(set (match_operand:HI 0 "register_operand" "=r,r")
+        (mult:HI (match_operand:HI 1 "register_operand" "+0,0")
+                 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
+  ""
+  {
+    tms9900_debug_operands ("mulhi3", NULL_RTX, operands, 3);
+    tms9900_inline_debug ("; mulhi3 alt=%d\n", which_alternative);
+
+    rtx result = gen_reg_rtx (SImode);
+    emit_move_insn(gen_highpart (HImode, result), operands[1]);
+    emit_insn(gen_mulnative(result, result, operands[2]));
+    emit_move_insn (operands[0], gen_lowpart (HImode, result));
+    DONE;
+   }
+)
+
+;;-------------------------------------
+; This is the native multiplication on the tms9900.  SI=HIxHI
+;  Note it is expected that op1 == op0 so we specify that op1 is SI.
+;  All other variants, QIxQI, etc, should expand to this insn.
+;  Also, mpy is unsigned so signed variants need to expand differently.
+;  Signed vs unsigned makes no difference if operands and results are the same
+;  size but will yield wrong results if result is wider than operands.
+
+;  NOTE it does not appear subreg offsets are ever passed to this insn
+
+(define_insn "mulnative"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(mult:SI (match_operand:SI 1 "register_operand" "0,0")
+		 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
+  ""
+  {
+    tms9900_debug_operands ("mulnative", insn, operands, 3);
+    return ("mpy  %2, %0");
+  }
+  [(set_attr "length" "2,4")])
+
+;;-------------------------------------
+;; byte mul can only work in registers as we need to expand to HI mode
+
+(define_expand "udivmodqi4"
+  [(parallel [
+     (set (match_operand:QI 0 "register_operand" "=r")
+          (div:QI (match_operand:QI 1 "register_operand" "0")
+                  (match_operand:QI 2 "register_operand" "r")))
+     (set (match_operand:QI 3 "register_operand" "=r")
+          (mod:QI (match_dup 1) 
+                  (match_dup 2)))])]
+  ""
+  {
+    tms9900_debug_operands ("udivmodqi4", NULL_RTX, operands, 4);
+
+    /* Move and extend QI dividend to SI */
+    rtx dividend = gen_reg_rtx (SImode);
+    rtx scratch = gen_reg_rtx (HImode);
+    emit_insn(gen_zero_extendqihi2 (scratch, operands[1]));
+    emit_insn(gen_zero_extendhisi2 (dividend, scratch));
+
+    /* Extend the divisor */
+    rtx divisor = gen_reg_rtx (HImode);
+    emit_insn(gen_zero_extendqihi2 (divisor, operands[2]));
+
+    /* Do the division */
+    emit_insn(gen_udivmodsihi3(dividend, dividend, divisor));
+
+    /* Convert and store quotient from HI to QI */
+    rtx quotient = gen_reg_rtx (HImode);
+    emit_move_insn (quotient, gen_highpart (HImode, dividend));
+    emit_insn(gen_trunchiqi2 (operands[0], quotient));
+
+    /* Convert and store quotient from HI to QI */
+    rtx remainder = gen_reg_rtx (HImode);
+    emit_move_insn (remainder, gen_lowpart (HImode, dividend));
+    emit_insn(gen_trunchiqi2 (operands[3], remainder));
+    DONE;
+  })
+
+(define_expand "udivmodhi4"
+  [(parallel [
+     (set (match_operand:HI 0 "register_operand" "=r,r")
+          (div:HI (match_operand:HI 1 "register_operand" "+0,0")
+                  (match_operand:HI 2 "nonimmediate_operand" "+rR>,Q")))
+     (set (match_operand:HI 3 "register_operand" "=r,r")
+          (mod:HI (match_dup 1) 
+                  (match_dup 2)))])]
+  ""
+  {
+    tms9900_debug_operands ("udivmodhi4", NULL_RTX, operands, 4);
+    tms9900_inline_debug ("; udivmodhi4 alt=%d\n", which_alternative);
+    rtx dividend = gen_reg_rtx (SImode);
+    rtx tmp = gen_reg_rtx (HImode);
+    emit_move_insn(tmp, operands[1]);
+    emit_insn(gen_zero_extendhisi2 (dividend, tmp));
+    emit_insn(gen_udivmodsihi3(dividend, dividend, operands[2]));
+    emit_move_insn (operands[0], gen_highpart (HImode, dividend));
+    emit_move_insn (operands[3], gen_lowpart (HImode, dividend));
+    DONE;
+  })
+
+
+;;-------------------------------------
+;; Signed div/mod.  Native method is unsigned so record the sign of the result
+;; by xor'ing operands together to examine highest bit.  Then take abs of operands.
+;; Correct the sign of the quotient after the operation
+(define_expand "divmodqi4"
+  [(parallel [
+     (set (match_operand:QI 0 "register_operand" "=r,r")
+          (div:QI (match_operand:QI 1 "register_operand" "0,0")
+                  (match_operand:QI 2 "nonimmediate_operand" "rR>,Q")))
+     (set (match_operand:QI 3 "register_operand" "=r,r")
+          (mod:QI (match_dup 1) 
+                  (match_dup 2)))])]
+  ""
+  {
+    tms9900_debug_operands ("divmodqi4", NULL_RTX, operands, 4);
+    tms9900_inline_debug ("; divmodqi4 alt=%d\n", which_alternative);
+
+    /* Find quotient sign */
+    rtx sign = gen_reg_rtx (HImode); // sign of quotient
+    emit_insn(gen_extendqihi2 (operands[1], sign));
+    // emit_move_insn(sign, operands[1]);
+    emit_insn(gen_extendqihi2 (operands[2], operands[2]));
+    emit_insn(gen_xorhi3(sign, sign, operands[2]));
+
+    /* Use temp for operand2 and get abs value */
+    rtx divisor = gen_reg_rtx (HImode);
+    emit_move_insn(divisor, operands[2]);
+    emit_insn(gen_abshi2(divisor, divisor));
+
+    /* Use temp for operand1, get absolute value and extend to SI.  We don't
+     * have abssi2 so do abs on a tmp before extend  */
+    rtx dividend = gen_reg_rtx (SImode);
+    rtx tmp = gen_reg_rtx (HImode);
+    emit_move_insn(tmp, operands[1]);
+    emit_insn(gen_abshi2(tmp, tmp));
+    emit_insn(gen_extendhisi2 (dividend, tmp));
+
+    /* Perform division and modulus */
+    emit_insn(gen_udivmodsihi3(dividend, dividend, divisor));
+
+    /* Convert and store quotient from HI to QI */
+    rtx quotient = gen_reg_rtx (HImode);
+    emit_move_insn (quotient, gen_highpart (HImode, dividend));
+
+    /* Correct sign of quotient */
+    emit_insn(gen_divfixuphi2(quotient, sign));
+
+    /* Convert and store quotient from HI to QI */
+    emit_insn(gen_trunchiqi2 (operands[0], quotient));
+
+    /* Convert and store remainder from HI to QI */
+    rtx remainder = gen_reg_rtx (HImode);
+    emit_move_insn (remainder, gen_lowpart (HImode, dividend));
+    emit_insn(gen_trunchiqi2 (operands[3], remainder));
+
+    DONE;
+  }
+)
+
+
+(define_expand "divmodhi4"
+  [(parallel [
+     (set (match_operand:HI 0 "register_operand" "=r,r")
+          (div:HI (match_operand:HI 1 "register_operand" "0,0")
+                  (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))
+     (set (match_operand:HI 3 "register_operand" "=r,r")
+          (mod:HI (match_dup 1) 
+                  (match_dup 2)))])]
+  ""
+  {
+    tms9900_debug_operands ("divmodhi4", NULL_RTX, operands, 4);
+    tms9900_inline_debug ("; divmodhi4 alt=%d\n", which_alternative);
+    // rtx insn, div_equal, mod_equal, equal;
+
+    /* Find quotient sign */
+    rtx sign = gen_reg_rtx (HImode); // sign of quotient
+    emit_move_insn(sign, operands[1]);
+    emit_insn(gen_xorhi3(sign, sign, operands[2]));
+
+    /* Use temp for operand2 and get abs value */
+    rtx divisor = gen_reg_rtx (HImode);
+    emit_move_insn(divisor, operands[2]);
+    emit_insn(gen_abshi2(divisor, divisor));
+
+    /* Use temp for operand1, get absolute value and extend to SI.  We don't
+     * have abssi2 so do abs on a tmp before extend  */
+    rtx dividend = gen_reg_rtx (SImode);
+    rtx tmp = gen_reg_rtx (HImode);
+    emit_move_insn(tmp, operands[1]);
+    emit_insn(gen_abshi2(tmp, tmp));
+    emit_insn(gen_extendhisi2 (dividend, tmp));
+
+    /* Perform division and modulus */
+    emit_insn(gen_udivmodsihi3(dividend, dividend, divisor));
+    emit_move_insn (operands[0], gen_highpart (HImode, dividend));
+    emit_move_insn (operands[3], gen_lowpart (HImode, dividend));
+
+    /* Correct sign of quotient */
+    emit_insn(gen_divfixuphi2(operands[0], sign));
+
+    DONE;
+  }
+)
+
+
+;;-------------------------------------------------------------------
+;; Divide and Modulus
+;; native method HI = SI / HI , HI = SI % HI
+;;-------------------------------------
+(define_insn "udivmodsihi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (ior:SI
+          (ashift:SI
+            (zero_extend:SI
+              (div:HI (match_operand:SI 1 "register_operand" "0,0")
+                      (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))
+            (const_int 16))
+          (zero_extend:SI 
+            (mod:HI (match_dup 1)
+                    (match_dup 2)))))]
+  ""
+  {
+    tms9900_debug_operands ("udivmodsihi3", insn, operands, 3);
+    output_asm_insn ("div  %2, %0", operands);
+    return("");
+  }
+  [(set_attr "length" "2,4")])
+
+
+
+(define_insn "divfixuphi2"
+  [(set (match_operand:HI 1 "register_operand" "=r")
+        (not:HI (match_dup 1)))
+   (set (match_operand:HI 0 "register_operand" "=r")
+        (if_then_else:HI (lt:HI (match_dup 1) (const_int 0))
+           (neg:HI (match_dup 0)) (match_dup 0)))]
+  ""
+  {
+    tms9900_debug_operands ("divfixuphi2", insn, operands, 2);
+    output_asm_insn("inv  %1", operands);
+    output_asm_insn("jlt  $+4", operands);
+    output_asm_insn("neg  %0", operands);
+    return("");
+  }
+  [(set_attr "length" "6")])
+
+
+;;-------------------------------------------------------------------
+;; Absolute Value
+
+;;-------------------------------------
+(define_insn "abshi2"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
+	(abs:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))]
+  ""
+  {
+    tms9900_debug_operands ("abshi2", insn, operands, 2);
+    output_asm_insn ("abs  %0", operands);
+    return("");
+  }
+  [(set_attr "length" "2,4")])
+
+
+;;-------------------------------------
+;; register only as abs is 16-bit
+(define_insn "absqi2"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+	(abs:QI (match_operand:QI 1 "register_operand" "0")))]
+  ""
+  {
+    tms9900_debug_operands ("absqi2", insn, operands, 2);
+    output_asm_insn ("abs  %0", operands);
+    return("");
+  }
+  [(set_attr "length" "2")])
+
+
+;;-------------------------------------------------------------------
+;; Negate
+
+;;-------------------------------------
+(define_insn "neghi2"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
+	(neg:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))]
+  ""
+  {
+    tms9900_debug_operands ("neghi2", insn, operands, 2);
+    output_asm_insn("neg  %0", operands);
+    return("");
+  }
+  [(set_attr "length" "2,4")])
+
+
+;;-------------------------------------
+;; TODO andi only reqiured for strict
+(define_insn "negqi2"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+	(neg:QI (match_operand:QI 1 "register_operand" "0")))]
+  ""
+  {
+    tms9900_debug_operands ("negqi2", insn, operands, 2);
+    output_asm_insn("andi %0, 0xFF00", operands);
+    output_asm_insn("neg  %0", operands);
+    return("");
+  }
+  [(set_attr "length" "6")])
+
+
+;;-------------------------------------------------------------------
+;; Other Instructions
+;;-------------------------------------------------------------------
+
+
+;;-------------------------------------------------------------------
+;; No-op
+(define_insn "nop"
+  [(const_int 0)]
+  ""
+  "nop"
+  [(set_attr "length" "2")])
+
+
+;;-------------------------------------------------------------------
+;;  Optimizations For Byte Compares
+;;-------------------------------------------------------------------
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (unsigned char)X > N
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "=r")
+        (match_operand:QI 1 "const_int_operand" "i"))
+   (set (cc0)
+        (compare (match_operand:QI 2 "register_operand" "r")
+                 (match_dup 0)))
+   (set (pc) (if_then_else (gtu (cc0) (const_int 0))
+                           (label_ref (match_operand 3 "" ""))
+                           (pc)))]
+  "peep2_reg_dead_p(3, operands[0])"
+  [(set (cc0)
+        (compare (match_dup 2)
+                 (plus:HI (const_int 255)
+                          (mult:HI (match_dup 1)
+                                   (const_int 256)))))
+   (set (pc) (if_then_else (gtu (cc0) (const_int 0))
+                           (label_ref (match_dup 3))
+                           (pc)))]
+  {
+    tms9900_debug_operands ("peep-A", NULL_RTX, operands, 4);
+  }
+)
+
+;; TODO assume this can be deleted
+(define_insn "*cmpqi_as_hi"
+  [(set (cc0)
+      (compare (match_operand:QI 0 "register_operand" "r")
+         (plus:HI (match_operand:HI 1 "const_int_operand" "i")
+            (mult:HI (match_operand:HI 2 "const_int_operand" "i")
+               (match_operand:HI 3 "const_int_operand" "i")))))]
+  "INTVAL(operands[3]) == 256 && (INTVAL(operands[1]) == 0 || INTVAL(operands[1]) == 255)"
+  {
+    tms9900_debug_operands ("*cmpqi_as_hi", insn, operands, 3);
+    operands[1] = GEN_INT(INTVAL(operands[2]) * 256 + INTVAL(operands[1]));
+    return("ci   %0, %1");
+  }
+  [(set_attr "length" "4")])
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (unsigned char)X < N
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "=r")
+        (match_operand:QI 1 "const_int_operand" "i"))
+   (set (cc0)
+        (compare (match_operand:QI 2 "register_operand" "r")
+                 (match_dup 0)))
+   (set (pc) (if_then_else (ltu (cc0) (const_int 0))
+                           (label_ref (match_operand 3 "" ""))
+                           (pc)))]
+  "peep2_reg_dead_p(3, operands[0])"
+  [(set (cc0)
+        (compare (match_dup 2)
+                 (plus:HI (const_int 0)
+                          (mult:HI (match_dup 1)
+                                   (const_int 256)))))
+   (set (pc) (if_then_else (ltu (cc0) (const_int 0))
+                           (label_ref (match_dup 3))
+                           (pc)))]
+  {
+    tms9900_debug_operands ("peep-cmpqi_lt_hi", NULL_RTX, operands, 4);
+  }
+)
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (unsigned char)X >= N
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "=r")
+        (match_operand:QI 1 "const_int_operand" "i"))
+   (set (cc0)
+        (compare (match_operand:QI 2 "register_operand" "r")
+                 (match_dup 0)))
+   (set (pc) (if_then_else (geu (cc0) (const_int 0))
+                           (label_ref (match_operand 3 "" ""))
+                           (pc)))]
+  "peep2_reg_dead_p(3, operands[0])"
+  [(set (cc0)
+        (compare (match_dup 2)
+                 (plus:HI (const_int 0)
+                          (mult:HI (match_dup 1)
+                                   (const_int 256)))))
+   (set (pc) (if_then_else (geu (cc0) (const_int 0))
+                           (label_ref (match_dup 3))
+                           (pc)))]
+  {
+    tms9900_debug_operands ("peep-cmpqi_ge_hi", NULL_RTX, operands, 3);
+  }
+)
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (unsigned char)X <= N
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "=r")
+        (match_operand:QI 1 "const_int_operand" "i"))
+   (set (cc0)
+        (compare (match_operand:QI 2 "register_operand" "r")
+                 (match_dup 0)))
+   (set (pc) (if_then_else (leu (cc0) (const_int 0))
+                           (label_ref (match_operand 3 "" ""))
+                           (pc)))]
+  "peep2_reg_dead_p(3, operands[0])"
+  [(set (cc0)
+        (compare (match_dup 2)
+                 (plus:HI (const_int 255)
+                          (mult:HI (match_dup 1)
+                                   (const_int 256)))))
+   (set (pc) (if_then_else (leu (cc0) (const_int 0))
+                           (label_ref (match_dup 3))
+                           (pc)))]
+  {
+    tms9900_debug_operands ("peep-cmpqi_le_hi", NULL_RTX, operands, 3);
+  }
+)
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (char)X > N
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "=r")
+        (match_operand:QI 1 "const_int_operand" "i"))
+   (set (cc0)
+        (compare (match_operand:QI 2 "register_operand" "r")
+                 (match_dup 0)))
+   (set (pc) (if_then_else (gt (cc0) (const_int 0))
+                           (label_ref (match_operand 3 "" ""))
+                           (pc)))]
+  "peep2_reg_dead_p(3, operands[0])"
+  [(set (cc0)
+        (compare (match_dup 2)
+                 (plus:HI (const_int 255)
+                          (mult:HI (match_dup 1)
+                                  (const_int 256)))))
+   (set (pc) (if_then_else (gt (cc0) (const_int 0))
+                           (label_ref (match_dup 3))
+                           (pc)))]
+  {
+    tms9900_debug_operands ("peep-cmpqi_gt_hi", NULL_RTX, operands, 3);
+  }
+)
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (char)X < N
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "=r")
+        (match_operand:QI 1 "const_int_operand" "i"))
+   (set (cc0)
+        (compare (match_operand:QI 2 "register_operand" "r")
+                 (match_dup 0)))
+   (set (pc) (if_then_else (lt (cc0) (const_int 0))
+                           (label_ref (match_operand 3 "" ""))
+                           (pc)))]
+  "peep2_reg_dead_p(3, operands[0])"
+  [(set (cc0)
+        (compare (match_dup 2)
+                 (plus:HI (const_int 0)
+                          (mult:HI (match_dup 1)
+                                   (const_int 256)))))
+   (set (pc) (if_then_else (lt (cc0) (const_int 0))
+                           (label_ref (match_dup 3))
+                           (pc)))]
+  {
+    tms9900_debug_operands ("peep-cmpsqi_lt_hi", NULL_RTX, operands, 3);
+  }
+)
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (char)X >= N
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "=r")
+        (match_operand:QI 1 "const_int_operand" "i"))
+   (set (cc0)
+        (compare (match_operand:QI 2 "register_operand" "r")
+                 (match_dup 0)))
+   (set (pc) (if_then_else (ge (cc0) (const_int 0))
+                           (label_ref (match_operand 3 "" ""))
+                           (pc)))]
+  "peep2_reg_dead_p(3, operands[0])"
+  [(set (cc0)
+        (compare (match_dup 2)
+                 (plus:HI (const_int 0)
+                          (mult:HI (match_dup 1)
+                                   (const_int 256)))))
+   (set (pc) (if_then_else (ge (cc0) (const_int 0))
+                           (label_ref (match_dup 3))
+                           (pc)))]
+  {
+    tms9900_debug_operands ("peep-cmpsqi_ge_hi", NULL_RTX, operands, 3);
+  }
+)
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (char)X <= N
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "=r")
+        (match_operand:QI 1 "const_int_operand" "i"))
+   (set (cc0)
+        (compare (match_operand:QI 2 "register_operand" "r")
+                 (match_dup 0)))
+   (set (pc) (if_then_else (le (cc0) (const_int 0))
+                           (label_ref (match_operand 3 "" ""))
+                           (pc)))]
+  "peep2_reg_dead_p(3, operands[0])"
+  [(set (cc0)
+        (compare (match_dup 2)
+                 (plus:HI (const_int 255)
+                          (mult:HI (match_dup 1)
+                                   (const_int 256)))))
+   (set (pc) (if_then_else (le (cc0) (const_int 0))
+                           (label_ref (match_dup 3))
+                           (pc)))]
+  {
+    tms9900_debug_operands ("peep-cmpsqi_le_hi", NULL_RTX, operands, 3);
+  }
+)
+
+
+;;-------------------------------------------------------------------
+;;  Optimizations For Bit Shift And Cast
+;;-------------------------------------------------------------------
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (char)X = (int X) >> N
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (ashiftrt:HI (match_dup 0)
+            (match_operand:HI 1 "const_int_operand" "i")))
+   (set (match_operand:QI 2 "register_operand" "=r")
+        (subreg:QI (match_dup 0) 1))]
+  "REGNO(operands[0]) == REGNO(operands[2])"
+  [(set (match_dup 0)
+        (ashiftrt:HI (match_dup 0)
+            (minus:HI (match_dup 1) 
+                      (const_int 8))))]
+  {
+    tms9900_debug_operands ("peep-movqi_hi_sh", NULL_RTX, operands, 3);
+  }
+)
+
+(define_insn "*ashiftrt_hi_to_qi"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (ashiftrt:HI (match_dup 0)
+            (minus:HI (match_operand:HI 1 "const_int_operand" "i") 
+                      (match_operand:HI 2 "const_int_operand" "i"))))]
+  ""
+  {
+    tms9900_debug_operands ("*ashiftrt_hi_to_qi", insn, operands, 3);
+    int shift = INTVAL (operands[1]);
+    if(shift < 8)
+    {
+      operands[1] = GEN_INT(8 - shift);
+      output_asm_insn("sla  %0, %1", operands);
+    }
+    else if(shift > 8)
+    {
+      operands[1] = GEN_INT(shift - 8);
+      output_asm_insn("sra  %0, %1", operands);
+    }
+    return "";
+  }
+  [(set_attr "length" "2")])
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (unsigned char)X = (unsigned int X) >> N
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (lshiftrt:HI (match_dup 0)
+            (match_operand:HI 1 "const_int_operand" "i")))
+   (set (match_operand:QI 2 "register_operand" "=r")
+        (subreg:QI (match_dup 0) 1))]
+  "REGNO(operands[0]) == REGNO(operands[2])"
+  [(set (match_dup 0)
+        (lshiftrt:HI (match_dup 0)
+            (minus:HI (match_dup 1) 
+                      (const_int 8))))]
+  {
+    tms9900_debug_operands ("peep-movqi_uhi_sh", NULL_RTX, operands, 3);
+  }
+)
+
+
+(define_insn "*lshiftrt_hi_to_qi"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (lshiftrt:HI (match_dup 0)
+            (minus:HI (match_operand:HI 1 "const_int_operand" "i") 
+                      (match_operand:HI 2 "const_int_operand" "i"))))]
+  ""
+  {
+    tms9900_debug_operands ("*lshiftrt_hi_to_qi", insn, operands, 3);
+    int shift = INTVAL (operands[1]);
+    if(shift < 8)
+    {
+      operands[1] = GEN_INT(8 - shift);
+      output_asm_insn("sla  %0, %1", operands);
+    }
+    else if(shift > 8)
+    {
+      operands[1] = GEN_INT(shift - 8);
+      output_asm_insn("srl  %0, %1", operands);
+    }
+    return "";
+  }
+  [(set_attr "length" "2")])
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (char)X = (int X) << N
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (ashift:HI (match_dup 0)
+            (match_operand:HI 1 "const_int_operand" "i")))
+   (set (match_operand:QI 2 "register_operand" "=r")
+        (subreg:QI (match_dup 0) 1))]
+  "REGNO(operands[0]) == REGNO(operands[2])"
+  [(set (match_dup 0)
+        (ashift:HI (match_dup 0)
+            (plus:HI (match_dup 1) 
+                      (const_int 8))))]
+  {
+    tms9900_debug_operands ("peep-movqi_hi_lsh", NULL_RTX, operands, 3);
+  }
+)
+
+
+(define_insn "*ashift_hi_to_qi"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (ashift:HI (match_dup 0)
+            (plus:HI (match_operand:HI 1 "const_int_operand" "i") 
+                      (match_operand:HI 2 "const_int_operand" "i"))))]
+  ""
+  {
+    tms9900_debug_operands ("*ashift_hi_to_qi", insn, operands, 3);
+    operands[1] = GEN_INT(8 + INTVAL (operands[1]));
+    output_asm_insn("sla  %0, %1", operands);
+    return("");
+  }
+  [(set_attr "length" "2")])
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (int)X = (char X) >> N
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "=r")
+        (ashiftrt:QI (match_dup 0)
+            (match_operand:HI 1 "const_int_operand" "i")))
+   (set (match_operand:HI 2 "register_operand" "=r")
+        (sign_extend:HI (match_dup 0)))]
+  "REGNO(operands[0]) == REGNO(operands[2])"
+  [(set (match_dup 2)
+        (ashiftrt:HI (match_dup 2)
+            (plus:HI (match_dup 1) 
+                      (const_int 8))))]
+  {
+    tms9900_debug_operands ("peep-movhi_qi_rsh", NULL_RTX, operands, 3);
+  }
+)
+
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(sign_extend:HI (match_operand:QI 1 "register_operand" "0")))
+   (set (match_operand:HI 2 "register_operand" "=r")
+        (ashiftrt:HI (match_dup 2)
+            (match_operand:HI 3 "const_int_operand" "i")))]
+  "REGNO(operands[0]) == REGNO(operands[2])"
+  [(set (match_dup 2)
+        (ashiftrt:HI (match_dup 2)
+            (plus:HI (match_dup 3) 
+                      (const_int 8))))]
+  {
+    tms9900_debug_operands ("peep-sign-ext", NULL_RTX, operands, 4);
+  }
+)
+
+
+(define_insn "*ashiftrt_qi_to_hi"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (ashiftrt:HI (match_dup 0)
+            (plus:HI (match_operand:HI 1 "const_int_operand" "i") 
+                      (match_operand:HI 2 "const_int_operand" "i"))))]
+  ""
+  {
+    tms9900_debug_operands ("*ashiftrt_qi_to_hi", insn, operands, 3);
+    int shift = INTVAL (operands[1]) + 8;
+    if(shift > 15) shift = 15;
+    operands[1] = GEN_INT(shift);
+    output_asm_insn("sra  %0, %1", operands);
+    return("");
+  }
+  [(set_attr "length" "2")])
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (int)X = (unsigned char X) >> N
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (lshiftrt:HI (match_operand:HI 1 "register_operand" "0")
+            (match_operand:HI 2 "const_int_operand" "i")))
+   (set (match_operand:HI 3 "register_operand" "=r")
+        (and:HI (match_operand:HI 4 "const_int_operand" "2")
+                (match_operand:HI 5 "const_int_operand" "i")))]
+  "(REGNO(operands[0]) == REGNO(operands[3])) && (INTVAL(operands[5]) == (1<<(8-INTVAL(operands[2])))-1)"
+  [(set (match_dup 0)
+        (lshiftrt:HI (match_dup 0)
+            (plus:HI (match_dup 2) 
+                      (const_int 8))))]
+  {
+    tms9900_debug_operands ("peep-lsh-and", NULL_RTX, operands, 6);
+  }
+)
+
+
+(define_insn "*lshiftrt_qi_to_hi"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (lshiftrt:HI (match_dup 0)
+            (plus:HI (match_operand:HI 1 "const_int_operand" "i") 
+                      (match_operand:HI 2 "const_int_operand" "i"))))]
+  ""
+  {
+    tms9900_debug_operands ("*lshiftrt_qi_to_hi", insn, operands, 3);
+    int shift = INTVAL (operands[1]) + 8;
+    if(shift > 15) shift = 15;
+    operands[1] = GEN_INT(shift);
+    output_asm_insn("srl  %0, %1", operands);
+    return("");
+  }
+  [(set_attr "length" "2")])
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (int)X = ((int)(char X)) << N
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (sign_extend:HI (match_operand:QI 1 "register_operand" "0")))
+   (set (match_operand:HI 3 "register_operand" "=r")
+        (ashift:HI (match_operand:HI 4 "register_operand" "3")
+                   (match_operand:HI 5 "const_int_operand" "i")))]
+  "(REGNO(operands[0]) == REGNO(operands[3]))"
+  [(set (match_dup 0)
+        (ashiftrt:HI (const_int 8)
+            (ashift:HI (match_dup 0) 
+                       (match_dup 5))))]
+  {
+    tms9900_debug_operands ("peep-sign-ext-ash", NULL_RTX, operands, 6);
+  }
+)
+
+(define_insn "*qi_hi_shift"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (ashiftrt:HI (match_operand:HI 1 "const_int_operand" "i")
+            (ashift:HI (match_operand:HI 2 "register_operand" "0") 
+                       (match_operand:HI 3 "const_int_operand" "i"))))]
+  ""
+  {
+    tms9900_debug_operands ("*qi_hi_shift", insn, operands, 3);
+    int shift = INTVAL(operands[3]);
+    if(shift == 0) {
+      output_asm_insn("swpb %0", operands);
+      }
+    else if(shift >= 1 && shift <= 7) { 
+      operands[3] = GEN_INT(8-shift);
+      output_asm_insn("sra  %0, %3", operands);
+      }
+    else if(shift >= 9 && shift <= 15) {
+      operands[3] = GEN_INT(shift-8);
+      output_asm_insn("sla  %0, %3", operands);
+      }
+
+    operands[3] = GEN_INT(0x00FF << shift);
+    output_asm_insn("andi %0, %3", operands);
+   
+    return("");
+  }
+  [(set_attr "length" "6")])
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (unsigned int)X = ((unsigned int)(unsigned char X)) << N
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (zero_extend:HI (match_operand:QI 1 "register_operand" "0")))
+   (set (match_operand:HI 3 "register_operand" "=r")
+        (ashift:HI (match_operand:HI 4 "register_operand" "3")
+                   (match_operand:HI 5 "const_int_operand" "i")))]
+  "(REGNO(operands[0]) == REGNO(operands[3]))"
+  [(set (match_dup 0)
+        (lshiftrt:HI (const_int 8)
+            (ashift:HI (match_dup 0) 
+                       (match_dup 5))))]
+  {
+    tms9900_debug_operands ("peep-zero-ext-ash", NULL_RTX, operands, 6);
+  }
+)
+
+
+(define_insn "*unsigned_qi_hi_shift"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (lshiftrt:HI (match_operand:HI 1 "const_int_operand" "i")
+            (ashift:HI (match_operand:HI 2 "register_operand" "0") 
+                       (match_operand:HI 3 "const_int_operand" "i"))))]
+  ""
+  {
+    tms9900_debug_operands ("*unsigned_qi_hi_shift", insn, operands, 3);
+    int shift = INTVAL(operands[3]);
+    if(shift >= 0 && shift <= 7) { 
+      operands[3] = GEN_INT(8-shift);
+      output_asm_insn("srl  %0, %3", operands);
+      }
+    else if(shift >= 9 && shift <= 15) {
+      operands[3] = GEN_INT(shift-8);
+      output_asm_insn("sla  %0, %3", operands);
+      }
+
+    operands[3] = GEN_INT(0xFFFF << shift);
+    output_asm_insn("andi %0, %3", operands);
+   
+    return("");
+  }
+  [(set_attr "length" "6")])
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (unsigned long)X = (unsigned long Y) >> 16
+;;   Original code:
+;;     mov  r3, r6
+;;     mov  r4, r7
+;;     mov  r6, r7
+;;     clr  r6
+;;
+;;   Optimized:
+;;     mov r3, r7
+;;     clr r6
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (match_operand:HI 1 "register_operand" "r"))
+   (set (match_operand:HI 2 "register_operand" "=r")
+        (match_operand:HI 3 "register_operand" "r"))
+   (parallel[
+    (clobber (match_operand:HI 4 "register_operand" "r"))
+    (set (match_operand:SI 5 "register_operand" "=r")
+         (lshiftrt:SI (match_operand:SI 6 "register_operand" "5")
+                      (match_operand:HI 7 "const_int_operand" "i")))
+   ])]
+  "((REGNO(operands[0]) == REGNO(operands[5])) &&
+    (REGNO(operands[2]) == (REGNO(operands[0])+1)) &&
+    (INTVAL(operands[7]) == 16)
+   )"
+  [(set (match_dup 2) (match_dup 1))
+   (set (match_dup 0) (const_int 0))]
+  {
+    tms9900_debug_operands ("peep-mov-squash", NULL_RTX, operands, 8);
+  }
+)
+
+
+(define_insn "*set_consthi2"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (match_operand:HI 1 "const_int_operand" "i"))]
+  ""
+  {
+    tms9900_debug_operands ("*set_consthi2", insn, operands, 3);
+    if(INTVAL(operands[1]) == 0) {
+      output_asm_insn("clr  %0", operands);
+    } else if((INTVAL(operands[1]) & 0xFFFF) == 0xFFFF) {
+      output_asm_insn("seto  %0", operands);
+    } else {
+      output_asm_insn("li   %0, %1", operands);
+    }
+    return("");
+  }
+  [(set_attr "length" "4")])
+
+
+;;-------------------------------------------------------------------
+;; Optimization for X = Y << 16
+;;   Original code:
+;;     mov  r4, r6
+;;     mov  r5, r7
+;;     mov  r7, r6
+;;     clr  r7
+;;
+;;   Optimized:
+;;     mov r5, r6
+;;     clr r7
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (match_operand:HI 1 "register_operand" "r"))
+   (set (match_operand:HI 2 "register_operand" "=r")
+        (match_operand:HI 3 "register_operand" "r"))
+   (parallel[
+    (clobber (match_operand:HI 4 "register_operand" "r"))
+    (set (match_operand:SI 5 "register_operand" "=r")
+         (ashift:SI (match_operand:SI 6 "register_operand" "5")
+                      (match_operand:HI 7 "const_int_operand" "i")))
+   ])]
+  "((REGNO(operands[0]) == REGNO(operands[5])) &&
+    (REGNO(operands[2]) == (REGNO(operands[0])+1)) &&
+    (INTVAL(operands[7]) == 16)
+   )"
+  [(set (match_dup 0) (match_dup 3))
+   (set (match_dup 2) (const_int 0))]
+  {
+    tms9900_debug_operands ("peep-movsi-squash", NULL_RTX, operands, 8);
+  }
+)
+
+
+;-------------------------------------------------------------------
+;; Optimization for byte array initializations
+; This handles sequences like:
+;   li   r1, >1200
+;   movb r1, *r2
+;   li   r1, >3400
+;   movb r1, @1(r2)
+;
+; and converts to:
+;   li   r1, >1234
+;   movb r1, *r2
+;   swpb r1
+;   movb r1, @1(r2)
+;
+; This saves two bytes and is slightly faster
+(define_peephole2
+  [(match_scratch:HI 6 "r,r")
+   (set (match_operand:QI 0 "register_operand" "=r,r")
+        (match_operand:QI 1 "const_int_operand" "i,i"))
+   (set (match_operand:QI 2 "nonimmediate_operand" "=R>,Q")
+        (match_dup 0))
+   (set (match_operand:QI 3 "register_operand" "=r,r")
+        (match_operand:QI 4 "const_int_operand" "i,i"))
+   (set (match_operand:QI 5 "nonimmediate_operand" "=R>,Q")
+        (match_dup 3))]
+  "peep2_reg_dead_p(4, operands[0]) && peep2_reg_dead_p(4, operands[3])"
+  [(set (match_dup 6)
+        (ior:HI (ashift:HI (match_dup 1) 
+                     (const_int 8))
+             (match_dup 4)))
+   (set (match_dup 2)
+        (subreg:QI (ashiftrt:HI (match_dup 6) (const_int 8)) 1))
+   (set (match_dup 5)
+        (subreg:QI (ashiftrt:HI (match_dup 6) (const_int 0)) 1))]
+  {
+    tms9900_debug_operands ("peep-hi-swpb-mov", NULL_RTX, operands, 6);
+  }
+)
+
+
+(define_insn "*movhi_combine_consts"
+  [(set (match_operand:HI 0 "register_operand" "")
+        (ior:HI (ashift:HI (match_operand:QI 1 "const_int_operand" "")
+                           (match_operand:QI 2 "const_int_operand" ""))
+                (match_operand:QI 3 "const_int_operand" "")))]
+  ""
+  {
+    tms9900_debug_operands ("*movhi_combine_consts", insn, operands, 3);
+    operands[1] = GEN_INT(((INTVAL(operands[1]) & 0xFF) << 8) |
+                           (INTVAL(operands[3]) & 0xFF));
+    return "li   %0, %1";
+  }
+  [(set_attr "length" "4")])
+
+
+;; TODO will this help the case where char c = (int) x >> 8; ??
+
+(define_insn "*movqi_for_initializer"
+  [(set (match_operand:QI 0 "memory_operand" "=rR>,Q")
+        (subreg:QI (ashiftrt:HI (match_operand:HI 1 "register_operand" "r,r")
+                              (match_operand:HI 2 "const_int_operand" "i,i")) 1))]
+  ""
+  {
+    tms9900_debug_operands ("*movqi_for_initializer", insn, operands, 3);
+    if(INTVAL(operands[2]) == 8)
+    {
+      output_asm_insn("movb %1, %0", operands);
+    }
+    else if(INTVAL(operands[2]) == 0)
+    {
+      output_asm_insn("swpb %1", operands);
+      output_asm_insn("movb %1, %0", operands);
+    }
+   return("");
+  }
+  [(set_attr "length" "2,4")])
+
+
+;;-------------------------------------------------------------------
+;; Optimization for memory-to-memory copies
+;; Combine a mem-reg-mem copy into a mem-mem copy
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "")
+        (match_operand:HI 1 "memory_operand" ""))
+   (set (match_operand:HI 2 "memory_operand" "")
+        (match_dup 0))]
+  "peep2_reg_dead_p(2, operands[0])"
+  [(set (match_operand:HI 2 "memory_operand" "")
+        (match_operand:HI 1 "memory_operand" ""))]
+  {
+    tms9900_debug_operands ("peep-mov-mem-mem", NULL_RTX, operands, 3);
+  }
+)
+
+   
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "")
+        (match_operand:QI 1 "memory_operand" ""))
+   (set (match_operand:QI 2 "memory_operand" "")
+        (match_dup 0))]
+  "peep2_reg_dead_p(2, operands[0])"
+  [(set (match_operand:QI 2 "memory_operand" "")
+        (match_operand:QI 1 "memory_operand" ""))]
+  {
+    tms9900_debug_operands ("peep-movqi-mem-mem", NULL_RTX, operands, 3);
+  }
+)
+
+
+(define_insn "*andi_const"
+  [(set (match_operand:HI 0 "register_operand" "")
+        (and:HI (match_dup 0)
+                (match_operand:HI 1 "const_int_operand" "")))]
+  ""
+  {
+    tms9900_debug_operands ("*andi_const", insn, operands, 3);
+    int val = INTVAL(operands[1]) & 0xFFFF;
+    if(val == 0)
+      return "clr  %0";
+    else if(val == 0xFFFF)
+      return "";
+    else
+      return "andi %0, %1";
+  }
+  [(set_attr "length" "4")])
+
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/tms9900.opt gcc-4.4.0/gcc/config/tms9900/tms9900.opt
--- gcc-4.4.0-orig/gcc/config/tms9900/tms9900.opt	2023-12-23 10:48:53.513244386 +0000
+++ gcc-4.4.0/gcc/config/tms9900/tms9900.opt	2024-02-14 17:32:37.244912643 +0000
@@ -0,0 +1,34 @@
+; Options for the TMS9900 port of the compiler.
+
+; Copyright (C) 2005, 2007 Free Software Foundation, Inc.
+;
+; Copyright 2023 Mark Burkley (MGB)
+;
+; This file is part of GCC.
+;
+; GCC is free software; you can redistribute it and/or modify it under
+; the terms of the GNU General Public License as published by the Free
+; Software Foundation; either version 3, or (at your option) any later
+; version.
+;
+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+; WARRANTY; without even the implied warranty of MERCHANTABILITY or
+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+; for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with GCC; see the file COPYING3.  If not see
+; <http://www.gnu.org/licenses/>.
+
+mno-ti99-float
+Target RejectNegative Report Mask(NO_TI99_FLOAT)
+Generate IEEE compatible doubles and floats
+
+mti99-float
+Target RejectNegative Report InverseMask(NO_TI99_FLOAT)
+Generate TI console ROM compatible doubles and floats
+
+minline_rtl
+Target RejectNegative Report Mask(TI99_INLINE_RTL)
+Generate RTL dumps as inline comments in assembly output
+
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/tms9900-protos.h gcc-4.4.0/gcc/config/tms9900/tms9900-protos.h
--- gcc-4.4.0-orig/gcc/config/tms9900/tms9900-protos.h	2023-12-23 10:48:53.513244386 +0000
+++ gcc-4.4.0/gcc/config/tms9900/tms9900-protos.h	2024-02-22 15:06:06.608220569 +0000
@@ -0,0 +1,65 @@
+/* Definitions of target machine for GNU compiler, for the TMS9900
+
+Copyright 2009 Eric Welser (EMW)
+Copyright 2023 Mark Burkley (MGB)
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* declarations */
+#ifdef RTX_CODE
+extern int simple_memory_operand (rtx, enum machine_mode);
+extern void print_operand_address (FILE *, rtx);
+extern int legitimate_address_p (enum machine_mode, rtx);
+extern void notice_update_cc_on_set (rtx, rtx);
+#endif /* RTX_CODE */
+
+extern const char *output_branch (const char *, const char *, int);
+extern const char *output_jump (int);
+
+extern int tms9900_function_arg_padding (enum machine_mode mode, 
+                                         const_tree type);
+
+extern void tms9900_function_arg_advance (CUMULATIVE_ARGS *cum, 
+                                          enum machine_mode mode,
+                                          tree type,
+                                          int named ATTRIBUTE_UNUSED);
+
+extern void tms9900_init_cumulative_args (CUMULATIVE_ARGS *cum,
+                                          tree fntype ATTRIBUTE_UNUSED,
+                                          rtx libname ATTRIBUTE_UNUSED);
+
+extern rtx tms9900_function_arg (CUMULATIVE_ARGS *cum, 
+                                 enum machine_mode mode,
+                                 tree type ATTRIBUTE_UNUSED,
+                                 int named);
+
+extern int tms9900_initial_elimination_offset (int from, int to);
+extern rtx tms9900_function_value (const_tree valtype);
+extern void tms9900_output_ascii(FILE* stream, const char* ptr, int len);
+extern void tms9900_expand_prologue (void);
+extern void tms9900_expand_epilogue (bool is_sibcall);
+extern int tms9900_starting_frame_offset(void);
+extern int tms9900_reg_ok_for_base(int strict, rtx reg);
+extern int tms9900_go_if_legitimate_address(enum machine_mode mode ATTRIBUTE_UNUSED, rtx operand, int strict);
+
+extern void tms9900_register_mode_set (rtx operand, int mode);
+extern void tms9900_register_convert (rtx operand, int mode, int sign);
+extern bool tms9900_legitimate_constant_p (rtx x);
+extern bool tms9900_constant_address_p (rtx x);
+extern bool tms9900_operand_subreg_offset (rtx operand, int mode);
+extern void tms9900_inline_debug (const char *fmt,...);
+extern void tms9900_debug_operands (const char *name, rtx insn, rtx ops[], int count);
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/t-tms9900 gcc-4.4.0/gcc/config/tms9900/t-tms9900
--- gcc-4.4.0-orig/gcc/config/tms9900/t-tms9900	2023-12-23 10:48:53.513244386 +0000
+++ gcc-4.4.0/gcc/config/tms9900/t-tms9900	2024-02-24 13:49:12.881677822 +0000
@@ -0,0 +1,43 @@
+LIB1ASMSRC    = tms9900/lib1funcs.asm
+LIB1ASMFUNCS  = _divsi3 _udivsi3 _modsi3 _umodsi3 _divmod_common \
+_ashrsi3 _ashlsi3 _lshrsi3
+
+# Exclude funcs from libgcc2.c that we implement using calls to TI99/4A console
+# ROM
+LIB2FUNCS_EXCLUDE = __adddf3 __subdf3 __muldf3 __divdf3 __eqdf2 \
+ __gedf2 __gtdf2 __ledf2 __ltdf2
+
+# Exclude funcs where we provide our own C implementation
+LIB2FUNCS_EXCLUDE += _divdi3 _moddi3 _udivdi3 _umoddi3
+
+# Exclude other 64-bit functions we don't need (yet)
+LIB2FUNCS_EXCLUDE += _muldi3 _negdi2  _cmpdi2 _ucmpdi2 _lshrdi3 _ashldi3 \
+_ashrdi3 _addvDI3 _subvDI3 \
+__udivmoddi4
+
+LIB2FUNCS_EXTRA = \
+ $(srcdir)/config/tms9900/ftoa.c \
+ $(srcdir)/config/tms9900/atof.c \
+ $(srcdir)/config/tms9900/double.c\
+ $(srcdir)/config/tms9900/d_adj_neg_pos.c \
+ $(srcdir)/config/tms9900/d_compare.c \
+ $(srcdir)/config/tms9900/eqdf2.c \
+ $(srcdir)/config/tms9900/gedf2.c \
+ $(srcdir)/config/tms9900/gtdf2.c \
+ $(srcdir)/config/tms9900/ledf2.c \
+ $(srcdir)/config/tms9900/ltdf2.c \
+ $(srcdir)/config/tms9900/longdivmod.c \
+ $(srcdir)/config/tms9900/ulongdivmod.c
+
+# Tell make where to find headers for above
+LIBGCC2_INCLUDES += -I$(srcdir)/config/tms9900
+
+# Assemble startup files.  TODO Do we need these?
+$(T)crti.o: $(srcdir)/config/tms9900/crti.asm $(GCC_PASSES)
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \
+	-c -o $(T)crti.o -x assembler-with-cpp $(srcdir)/config/tms9900/crti.asm
+
+$(T)crtn.o: $(srcdir)/config/tms9900/crtn.asm $(GCC_PASSES)
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \
+	-c -o $(T)crtn.o -x assembler-with-cpp $(srcdir)/config/tms9900/crtn.asm
+
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/ulongdivmod.c gcc-4.4.0/gcc/config/tms9900/ulongdivmod.c
--- gcc-4.4.0-orig/gcc/config/tms9900/ulongdivmod.c	2024-02-14 17:32:37.236912601 +0000
+++ gcc-4.4.0/gcc/config/tms9900/ulongdivmod.c	2024-02-14 17:32:37.244912643 +0000
@@ -0,0 +1,51 @@
+/* ulongdivmod.c
+   These methods provide unsigned long division and modulus.
+   change log:
+   12/26/2023 initial version
+*/
+
+// #include <ulongdivmod.h>
+
+unsigned long numerator_u32_cache = 0;
+unsigned long denominator_u32_cache = 0;
+volatile unsigned long quotient_u32_cache;
+volatile unsigned long remainder_u32_cache;
+
+void divmod_u32 (long numerator, long denominator) {
+
+   unsigned long t;
+
+   quotient_u32_cache  = 0;
+   remainder_u32_cache = 0;
+
+   int i;
+   for (i = 31 ; i >= 0; i--) {
+      remainder_u32_cache = remainder_u32_cache << 1;
+      t                   = (long) 1 << i;
+      t                   = t & numerator;
+      t                   = t >> i;
+      remainder_u32_cache = remainder_u32_cache | t;
+      if (remainder_u32_cache >= denominator) {
+         remainder_u32_cache = remainder_u32_cache - denominator;
+         quotient_u32_cache  = quotient_u32_cache | ((long) 1 << i);
+      }
+   }
+}
+
+long __udivsi3 (unsigned long numerator, unsigned long denominator) {
+   if (numerator != numerator_u32_cache || denominator != denominator_u32_cache) {
+      numerator_u32_cache   = numerator;
+      denominator_u32_cache = denominator;
+      divmod_u32 (numerator_u32_cache, denominator_u32_cache);
+   }
+   return quotient_u32_cache;
+}
+
+unsigned long __umodsi3 (unsigned long numerator, unsigned long denominator) {
+   if (numerator != numerator_u32_cache || denominator != denominator_u32_cache) {
+      numerator_u32_cache   = numerator;
+      denominator_u32_cache = denominator;
+      divmod_u32 (numerator_u32_cache, denominator_u32_cache);
+   }
+   return remainder_u32_cache;
+}
diff -ru gcc-4.4.0-orig/gcc/config.gcc gcc-4.4.0/gcc/config.gcc
--- gcc-4.4.0-orig/gcc/config.gcc	2023-12-23 10:48:53.509244401 +0000
+++ gcc-4.4.0/gcc/config.gcc	2023-12-23 10:48:53.521244352 +0000
@@ -2314,6 +2314,9 @@
 	c_target_objs="${c_target_objs} spu-c.o"
 	cxx_target_objs="${cxx_target_objs} spu-c.o"
 	;;
+tms9900-*-*)
+	tmake_file=tms9900/t-tms9900
+	;;
 v850e1-*-*)
 	target_cpu_default="TARGET_CPU_v850e1"
 	tm_file="dbxelf.h elfos.h svr4.h v850/v850.h"
diff -ru gcc-4.4.0-orig/gcc/cp/cfns.h gcc-4.4.0/gcc/cp/cfns.h
--- gcc-4.4.0-orig/gcc/cp/cfns.h	2023-12-23 10:48:53.513244386 +0000
+++ gcc-4.4.0/gcc/cp/cfns.h	2023-12-23 10:48:53.525244337 +0000
@@ -1,4 +1,4 @@
-/* ANSI-C code produced by gperf version 3.0.1 */
+/* ANSI-C code produced by gperf version 3.0.4 */
 /* Command-line: gperf -o -C -E -k '1-6,$' -j1 -D -N libc_name_p -L ANSI-C ../../gcc/cp/cfns.gperf  */
 
 #if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
@@ -36,6 +36,7 @@
 static unsigned int hash (const char *, unsigned int);
 #ifdef __GNUC__
 __inline
+__attribute__ ((__gnu_inline__))
 #endif
 const char * libc_name_p (const char *, unsigned int);
 /* maximum key range = 391, duplicates = 0 */
@@ -57,13 +58,13 @@
       400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
       400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
       400, 400, 400, 400, 400, 400, 400, 400,   0,   0,
-	1, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+        1, 400, 400, 400, 400, 400, 400, 400, 400, 400,
       400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
       400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
       400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
       400, 400, 400, 400, 400, 400, 400,  28,  90,   0,
        95,   0,  51,  93, 114,  26, 109, 124,   5,   1,
-	6,  13,  37, 128,   3,   0,   0,  49,  38,   0,
+        6,  13,  37, 128,   3,   0,   0,  49,  38,   0,
       104,  45,   0, 400, 400, 400, 400, 400, 400, 400,
       400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
       400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
@@ -84,29 +85,32 @@
   switch (hval)
     {
       default:
-	hval += asso_values[(unsigned char)str[5]+1];
+        hval += asso_values[(unsigned char)str[5]+1];
       /*FALLTHROUGH*/
       case 5:
-	hval += asso_values[(unsigned char)str[4]];
+        hval += asso_values[(unsigned char)str[4]];
       /*FALLTHROUGH*/
       case 4:
-	hval += asso_values[(unsigned char)str[3]];
+        hval += asso_values[(unsigned char)str[3]];
       /*FALLTHROUGH*/
       case 3:
-	hval += asso_values[(unsigned char)str[2]];
+        hval += asso_values[(unsigned char)str[2]];
       /*FALLTHROUGH*/
       case 2:
-	hval += asso_values[(unsigned char)str[1]];
+        hval += asso_values[(unsigned char)str[1]];
       /*FALLTHROUGH*/
       case 1:
-	hval += asso_values[(unsigned char)str[0]];
-	break;
+        hval += asso_values[(unsigned char)str[0]];
+        break;
     }
   return hval + asso_values[(unsigned char)str[len - 1]];
 }
 
 #ifdef __GNUC__
 __inline
+#if defined __GNUC_STDC_INLINE__ || defined __GNUC_GNU_INLINE__
+__attribute__ ((__gnu_inline__))
+#endif
 #endif
 const char *
 libc_name_p (register const char *str, register unsigned int len)
@@ -329,17 +333,17 @@
       register int key = hash (str, len);
 
       if (key <= MAX_HASH_VALUE && key >= 0)
-	{
-	  register int index = lookup[key];
+        {
+          register int index = lookup[key];
 
-	  if (index >= 0)
-	    {
-	      register const char *s = wordlist[index];
-
-	      if (*str == *s && !strcmp (str + 1, s + 1))
-		return s;
-	    }
-	}
+          if (index >= 0)
+            {
+              register const char *s = wordlist[index];
+
+              if (*str == *s && !strcmp (str + 1, s + 1))
+                return s;
+            }
+        }
     }
   return 0;
 }
diff -ru gcc-4.4.0-orig/gcc/DATESTAMP gcc-4.4.0/gcc/DATESTAMP
--- gcc-4.4.0-orig/gcc/DATESTAMP	2024-01-06 17:22:05.286873814 +0000
+++ gcc-4.4.0/gcc/DATESTAMP	2024-02-25 12:08:46.158931184 +0000
@@ -1 +1 @@
-20090421
+20240225
diff -ru gcc-4.4.0-orig/gcc/DEV-PHASE gcc-4.4.0/gcc/DEV-PHASE
--- gcc-4.4.0-orig/gcc/DEV-PHASE	2023-12-23 10:48:53.509244401 +0000
+++ gcc-4.4.0/gcc/DEV-PHASE	2024-02-25 12:08:46.158931184 +0000
@@ -0,0 +1 @@
+TMS9900 patch
diff -ru gcc-4.4.0-orig/gcc/dfp.c gcc-4.4.0/gcc/dfp.c
--- gcc-4.4.0-orig/gcc/dfp.c	2023-12-23 10:48:53.513244386 +0000
+++ gcc-4.4.0/gcc/dfp.c	2023-12-23 10:54:39.839871629 +0000
@@ -355,6 +355,10 @@
 
 /* Helper to round_for_format, handling decimal float types.  */
 
+#ifdef TMS9900
+extern const struct real_format tms9900_real_format;
+#endif
+
 void
 decimal_round_for_format (const struct real_format *fmt, REAL_VALUE_TYPE *r)
 {
@@ -392,7 +396,12 @@
       decimal64FromNumber (&d64, &dn, &set);
       decimal64ToNumber (&d64, &dn);
     }
-  else
+#ifdef TMS9900
+  else if (fmt == &tms9900_real_format)
+    {
+      return;
+    }
+#endif
     gcc_unreachable ();
 
   decimal_from_decnumber (r, &dn, &set);
diff -ru gcc-4.4.0-orig/gcc/libgcc2.c gcc-4.4.0/gcc/libgcc2.c
--- gcc-4.4.0-orig/gcc/libgcc2.c	2023-12-23 10:48:53.513244386 +0000
+++ gcc-4.4.0/gcc/libgcc2.c	2023-12-23 10:48:53.525244337 +0000
@@ -4,6 +4,7 @@
    2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009
    Free Software Foundation, Inc.
 
+
 This file is part of GCC.
 
 GCC is free software; you can redistribute it and/or modify it under
@@ -1049,6 +1050,9 @@
 	      udiv_qrnnd (q0, n1, n2, n1, d1);
 	      umul_ppmm (m1, m0, q0, d0);
 
+// TODO something in this disabled code block causes a compiler segfault
+// gdb bt says invalid hash in ../../libiberty/hashtab.c:678
+#if 0
 	      if (m1 > n1 || (m1 == n1 && m0 > n0))
 		{
 		  q0--;
@@ -1065,6 +1069,7 @@
 		  rr.s.high = n1 >> bm;
 		  *rp = rr.ll;
 		}
+#endif
 	    }
 	}
     }
diff -ru gcc-4.4.0-orig/gcc/passes.c gcc-4.4.0/gcc/passes.c
--- gcc-4.4.0-orig/gcc/passes.c	2023-12-23 10:48:53.513244386 +0000
+++ gcc-4.4.0/gcc/passes.c	2023-12-23 10:48:53.525244337 +0000
@@ -102,6 +102,11 @@
 				   declarations for e.g. AIX 4.x.  */
 #endif
 
+#ifdef TMS9900
+extern struct rtl_opt_pass pass_tms9900_subreg;
+extern struct rtl_opt_pass pass_tms9900_postinc;
+#endif
+
 /* This is used for debugging.  It allows the current pass to printed
    from anywhere in compilation.  */
 struct opt_pass *current_pass;
@@ -767,6 +772,10 @@
       NEXT_PASS (pass_match_asm_constraints);
       NEXT_PASS (pass_sms);
       NEXT_PASS (pass_sched);
+#ifdef TMS9900
+      NEXT_PASS (pass_tms9900_subreg);
+      NEXT_PASS (pass_tms9900_postinc);
+#endif
       NEXT_PASS (pass_subregs_of_mode_init);
       NEXT_PASS (pass_ira);
       NEXT_PASS (pass_subregs_of_mode_finish);
diff -ru gcc-4.4.0-orig/gcc/reload.c gcc-4.4.0/gcc/reload.c
--- gcc-4.4.0-orig/gcc/reload.c	2023-12-23 10:48:53.513244386 +0000
+++ gcc-4.4.0/gcc/reload.c	2023-12-23 10:48:53.529244319 +0000
@@ -5475,7 +5475,7 @@
 	    code0 = GET_CODE (op0);
 	    if (code0 == REG && REGNO (op0) < FIRST_PSEUDO_REGISTER)
 	      op0 = gen_rtx_REG (word_mode,
-				 (REGNO (op0) +
+				 (REGNO (op0)+
 				  subreg_regno_offset (REGNO (SUBREG_REG (orig_op0)),
 						       GET_MODE (SUBREG_REG (orig_op0)),
 						       SUBREG_BYTE (orig_op0),
@@ -5490,7 +5490,7 @@
 	      /* ??? Why is this given op1's mode and above for
 		 ??? op0 SUBREGs we use word_mode?  */
 	      op1 = gen_rtx_REG (GET_MODE (op1),
-				 (REGNO (op1) +
+				 (REGNO (op1)+
 				  subreg_regno_offset (REGNO (SUBREG_REG (orig_op1)),
 						       GET_MODE (SUBREG_REG (orig_op1)),
 						       SUBREG_BYTE (orig_op1),
@@ -6362,7 +6362,7 @@
 
 	  if (REG_P (reloadreg))
 	    return gen_rtx_REG (GET_MODE (*loc),
-				(REGNO (reloadreg) +
+				(REGNO (reloadreg)+
 				 subreg_regno_offset (REGNO (SUBREG_REG (*loc)),
 						      GET_MODE (SUBREG_REG (*loc)),
 						      SUBREG_BYTE (*loc),
diff -ru gcc-4.4.0-orig/gcc/REVISION gcc-4.4.0/gcc/REVISION
--- gcc-4.4.0-orig/gcc/REVISION	2024-01-06 17:22:05.286873814 +0000
+++ gcc-4.4.0/gcc/REVISION	2024-02-25 12:08:46.158931184 +0000
@@ -0,0 +1 @@
+1.30
diff -ru gcc-4.4.0-orig/gcc/toplev.h gcc-4.4.0/gcc/toplev.h
--- gcc-4.4.0-orig/gcc/toplev.h	2023-12-23 10:48:53.513244386 +0000
+++ gcc-4.4.0/gcc/toplev.h	2023-12-23 10:48:53.529244319 +0000
@@ -186,6 +186,7 @@
 #  define CTZ_HWI __builtin_ctz
 # endif
 
+#ifdef __cplusplus
 extern inline int
 floor_log2 (unsigned HOST_WIDE_INT x)
 {
@@ -197,6 +198,7 @@
 {
   return x == (x & -x) && x ? (int) CTZ_HWI (x) : -1;
 }
+#endif /* __cplusplus */
 #endif /* GCC_VERSION >= 3004 */
 
 /* Functions used to get and set GCC's notion of in what directory
diff -ru gcc-4.4.0-orig/gcc/version.c gcc-4.4.0/gcc/version.c
--- gcc-4.4.0-orig/gcc/version.c	2024-01-06 17:22:05.286873814 +0000
+++ gcc-4.4.0/gcc/version.c	2024-01-06 17:22:05.290873797 +0000
@@ -15,3 +15,4 @@
 
 const char version_string[] = BASEVER DATESTAMP DEVPHASE REVISION;
 const char pkgversion_string[] = PKGVERSION;
+const char revision_string[] = REVISION;
diff -ru gcc-4.4.0-orig/gcc/version.h gcc-4.4.0/gcc/version.h
--- gcc-4.4.0-orig/gcc/version.h	2024-01-06 17:22:05.286873814 +0000
+++ gcc-4.4.0/gcc/version.h	2024-01-06 17:22:05.290873797 +0000
@@ -2,5 +2,6 @@
 #define GCC_VERSION_H
 extern const char version_string[];
 extern const char pkgversion_string[];
+extern const char revision_string[];
 extern const char bug_report_url[];
 #endif /* ! GCC_VERSION_H */
diff -ru gcc-4.4.0-orig/libgcc/config.host gcc-4.4.0/libgcc/config.host
--- gcc-4.4.0-orig/libgcc/config.host	2023-12-23 10:48:53.513244386 +0000
+++ gcc-4.4.0/libgcc/config.host	2023-12-23 10:48:53.529244319 +0000
@@ -127,6 +127,9 @@
 sh[123456789lbe]*-*-*)
 	cpu_type=sh
 	;;
+tms9900-*-*)
+	cpu_type=tms9900
+	;;
 esac
 
 # Common parts for widely ported systems.
@@ -551,6 +554,8 @@
 	;;
 spu-*-elf*)
 	;;
+tms9900-*-*)
+	;;
 v850e1-*-*)
 	;;
 v850e-*-*)
