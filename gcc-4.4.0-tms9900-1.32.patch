diff -ru gcc-4.4.0-orig/config.guess gcc-4.4.0/config.guess
--- gcc-4.4.0-orig/config.guess	2024-10-06 08:31:26.862724800 +0100
+++ gcc-4.4.0/config.guess	2024-10-06 08:31:26.922724406 +0100
@@ -1,14 +1,14 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
-#   Free Software Foundation, Inc.
+#   Copyright 1992-2024 Free Software Foundation, Inc.
 
-timestamp='2008-12-18'
+# shellcheck disable=SC2006,SC2268 # see below for rationale
+
+timestamp='2024-07-27'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
+# the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful, but
@@ -17,35 +17,39 @@
 # General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
-# 02110-1301, USA.
+# along with this program; if not, see <https://www.gnu.org/licenses/>.
 #
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
-
-
-# Originally written by Per Bothner <per@bothner.com>.
-# Please send patches to <config-patches@gnu.org>.  Submit a context
-# diff and a properly formatted ChangeLog entry.
+# the same distribution terms that you use for the rest of that
+# program.  This Exception is an additional permission under section 7
+# of the GNU General Public License, version 3 ("GPLv3").
 #
-# This script attempts to guess a canonical system name similar to
-# config.sub.  If it succeeds, it prints the system name on stdout, and
-# exits with 0.  Otherwise, it exits with 1.
+# Originally written by Per Bothner; maintained since 2000 by Ben Elliston.
 #
-# The plan is that this can be called by configure scripts if you
-# don't specify an explicit build system type.
+# You can get the latest version of this script from:
+# https://git.savannah.gnu.org/cgit/config.git/plain/config.guess
+#
+# Please send patches to <config-patches@gnu.org>.
+
+
+# The "shellcheck disable" line above the timestamp inhibits complaints
+# about features and limitations of the classic Bourne shell that were
+# superseded or lifted in POSIX.  However, this script identifies a wide
+# variety of pre-POSIX systems that do not have POSIX shells at all, and
+# even some reasonably current systems (Solaris 10 as case-in-point) still
+# have a pre-POSIX /bin/sh.
+
 
 me=`echo "$0" | sed -e 's,.*/,,'`
 
 usage="\
 Usage: $0 [OPTION]
 
-Output the configuration name of the system \`$me' is run on.
+Output the configuration name of the system '$me' is run on.
 
-Operation modes:
+Options:
   -h, --help         print this help, then exit
   -t, --time-stamp   print date of last modification, then exit
   -v, --version      print version number, then exit
@@ -56,14 +60,13 @@
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
-2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+Copyright 1992-2024 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
 
 help="
-Try \`$me --help' for more information."
+Try '$me --help' for more information."
 
 # Parse command line
 while test $# -gt 0 ; do
@@ -91,60 +94,112 @@
   exit 1
 fi
 
-trap 'exit 1' 1 2 15
+# Just in case it came from the environment.
+GUESS=
 
 # CC_FOR_BUILD -- compiler used by this script. Note that the use of a
 # compiler to aid in system detection is discouraged as it requires
 # temporary files to be created and, as you can see below, it is a
 # headache to deal with in a portable fashion.
 
-# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still
-# use `HOST_CC' if defined, but it is deprecated.
+# Historically, 'CC_FOR_BUILD' used to be named 'HOST_CC'. We still
+# use 'HOST_CC' if defined, but it is deprecated.
 
 # Portable tmp directory creation inspired by the Autoconf team.
 
-set_cc_for_build='
-trap "exitcode=\$?; (rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null) && exit \$exitcode" 0 ;
-trap "rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null; exit 1" 1 2 13 15 ;
-: ${TMPDIR=/tmp} ;
- { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
- { test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||
- { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo "Warning: creating insecure temp directory" >&2 ; } ||
- { echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; } ;
-dummy=$tmp/dummy ;
-tmpfiles="$dummy.c $dummy.o $dummy.rel $dummy" ;
-case $CC_FOR_BUILD,$HOST_CC,$CC in
- ,,)    echo "int x;" > $dummy.c ;
-	for c in cc gcc c89 c99 ; do
-	  if ($c -c -o $dummy.o $dummy.c) >/dev/null 2>&1 ; then
-	     CC_FOR_BUILD="$c"; break ;
-	  fi ;
-	done ;
-	if test x"$CC_FOR_BUILD" = x ; then
-	  CC_FOR_BUILD=no_compiler_found ;
-	fi
-	;;
- ,,*)   CC_FOR_BUILD=$CC ;;
- ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
-esac ; set_cc_for_build= ;'
+tmp=
+# shellcheck disable=SC2172
+trap 'test -z "$tmp" || rm -fr "$tmp"' 0 1 2 13 15
+
+set_cc_for_build() {
+    # prevent multiple calls if $tmp is already set
+    test "$tmp" && return 0
+    : "${TMPDIR=/tmp}"
+    # shellcheck disable=SC2039,SC3028
+    { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
+	{ test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir "$tmp" 2>/dev/null) ; } ||
+	{ tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir "$tmp" 2>/dev/null) && echo "Warning: creating insecure temp directory" >&2 ; } ||
+	{ echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; }
+    dummy=$tmp/dummy
+    case ${CC_FOR_BUILD-},${HOST_CC-},${CC-} in
+	,,)    echo "int x;" > "$dummy.c"
+	       for driver in cc gcc c17 c99 c89 ; do
+		   if ($driver -c -o "$dummy.o" "$dummy.c") >/dev/null 2>&1 ; then
+		       CC_FOR_BUILD=$driver
+		       break
+		   fi
+	       done
+	       if test x"$CC_FOR_BUILD" = x ; then
+		   CC_FOR_BUILD=no_compiler_found
+	       fi
+	       ;;
+	,,*)   CC_FOR_BUILD=$CC ;;
+	,*,*)  CC_FOR_BUILD=$HOST_CC ;;
+    esac
+}
 
 # This is needed to find uname on a Pyramid OSx when run in the BSD universe.
 # (ghazi@noc.rutgers.edu 1994-08-24)
-if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
+if test -f /.attbin/uname ; then
 	PATH=$PATH:/.attbin ; export PATH
 fi
 
 UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
 UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
-UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
+UNAME_SYSTEM=`(uname -s) 2>/dev/null` || UNAME_SYSTEM=unknown
 UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
 
+case $UNAME_SYSTEM in
+Linux|GNU|GNU/*)
+	LIBC=unknown
+
+	set_cc_for_build
+	cat <<-EOF > "$dummy.c"
+	#if defined(__ANDROID__)
+	LIBC=android
+	#else
+	#include <features.h>
+	#if defined(__UCLIBC__)
+	LIBC=uclibc
+	#elif defined(__dietlibc__)
+	LIBC=dietlibc
+	#elif defined(__GLIBC__)
+	LIBC=gnu
+	#elif defined(__LLVM_LIBC__)
+	LIBC=llvm
+	#else
+	#include <stdarg.h>
+	/* First heuristic to detect musl libc.  */
+	#ifdef __DEFINED_va_list
+	LIBC=musl
+	#endif
+	#endif
+	#endif
+	EOF
+	cc_set_libc=`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`
+	eval "$cc_set_libc"
+
+	# Second heuristic to detect musl libc.
+	if [ "$LIBC" = unknown ] &&
+	   command -v ldd >/dev/null &&
+	   ldd --version 2>&1 | grep -q ^musl; then
+		LIBC=musl
+	fi
+
+	# If the system lacks a compiler, then just pick glibc.
+	# We could probably try harder.
+	if [ "$LIBC" = unknown ]; then
+		LIBC=gnu
+	fi
+	;;
+esac
+
 # Note: order is significant - the case branches are not exclusive.
 
-case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
+case $UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION in
     *:NetBSD:*:*)
 	# NetBSD (nbsd) targets should (where applicable) match one or
-	# more of the tupples: *-*-netbsdelf*, *-*-netbsdaout*,
+	# more of the tuples: *-*-netbsdelf*, *-*-netbsdaout*,
 	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
 	# switched to ELF, *-*-netbsd* would select the old
 	# object file format.  This provides both forward
@@ -153,24 +208,34 @@
 	#
 	# Note: NetBSD doesn't particularly care about the vendor
 	# portion of the name.  We always set it to "unknown".
-	sysctl="sysctl -n hw.machine_arch"
-	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \
-	    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`
-	case "${UNAME_MACHINE_ARCH}" in
+	UNAME_MACHINE_ARCH=`(uname -p 2>/dev/null || \
+	    /sbin/sysctl -n hw.machine_arch 2>/dev/null || \
+	    /usr/sbin/sysctl -n hw.machine_arch 2>/dev/null || \
+	    echo unknown)`
+	case $UNAME_MACHINE_ARCH in
+	    aarch64eb) machine=aarch64_be-unknown ;;
 	    armeb) machine=armeb-unknown ;;
 	    arm*) machine=arm-unknown ;;
 	    sh3el) machine=shl-unknown ;;
 	    sh3eb) machine=sh-unknown ;;
 	    sh5el) machine=sh5le-unknown ;;
-	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
+	    earmv*)
+		arch=`echo "$UNAME_MACHINE_ARCH" | sed -e 's,^e\(armv[0-9]\).*$,\1,'`
+		endian=`echo "$UNAME_MACHINE_ARCH" | sed -ne 's,^.*\(eb\)$,\1,p'`
+		machine=${arch}${endian}-unknown
+		;;
+	    *) machine=$UNAME_MACHINE_ARCH-unknown ;;
 	esac
 	# The Operating System including object format, if it has switched
-	# to ELF recently, or will in the future.
-	case "${UNAME_MACHINE_ARCH}" in
+	# to ELF recently (or will in the future) and ABI.
+	case $UNAME_MACHINE_ARCH in
+	    earm*)
+		os=netbsdelf
+		;;
 	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
-		eval $set_cc_for_build
+		set_cc_for_build
 		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
-			| grep __ELF__ >/dev/null
+			| grep -q __ELF__
 		then
 		    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).
 		    # Return netbsd for either.  FIX?
@@ -180,7 +245,14 @@
 		fi
 		;;
 	    *)
-	        os=netbsd
+		os=netbsd
+		;;
+	esac
+	# Determine ABI tags.
+	case $UNAME_MACHINE_ARCH in
+	    earm*)
+		expr='s/^earmv[0-9]/-eabi/;s/eb$//'
+		abi=`echo "$UNAME_MACHINE_ARCH" | sed -e "$expr"`
 		;;
 	esac
 	# The OS release
@@ -188,42 +260,74 @@
 	# thus, need a distinct triplet. However, they do not need
 	# kernel version information, so it can be replaced with a
 	# suitable tag, in the style of linux-gnu.
-	case "${UNAME_VERSION}" in
+	case $UNAME_VERSION in
 	    Debian*)
 		release='-gnu'
 		;;
 	    *)
-		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+		release=`echo "$UNAME_RELEASE" | sed -e 's/[-_].*//' | cut -d. -f1,2`
 		;;
 	esac
 	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
 	# contains redundant information, the shorter form:
 	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
-	echo "${machine}-${os}${release}"
-	exit ;;
+	GUESS=$machine-${os}${release}${abi-}
+	;;
+    *:Bitrig:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
+	GUESS=$UNAME_MACHINE_ARCH-unknown-bitrig$UNAME_RELEASE
+	;;
     *:OpenBSD:*:*)
 	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
-	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
-	exit ;;
+	GUESS=$UNAME_MACHINE_ARCH-unknown-openbsd$UNAME_RELEASE
+	;;
+    *:SecBSD:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/SecBSD.//'`
+	GUESS=$UNAME_MACHINE_ARCH-unknown-secbsd$UNAME_RELEASE
+	;;
+    *:LibertyBSD:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/^.*BSD\.//'`
+	GUESS=$UNAME_MACHINE_ARCH-unknown-libertybsd$UNAME_RELEASE
+	;;
+    *:MidnightBSD:*:*)
+	GUESS=$UNAME_MACHINE-unknown-midnightbsd$UNAME_RELEASE
+	;;
     *:ekkoBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-ekkobsd$UNAME_RELEASE
+	;;
     *:SolidBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-solidbsd${UNAME_RELEASE}
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-solidbsd$UNAME_RELEASE
+	;;
+    *:OS108:*:*)
+	GUESS=$UNAME_MACHINE-unknown-os108_$UNAME_RELEASE
+	;;
     macppc:MirBSD:*:*)
-	echo powerpc-unknown-mirbsd${UNAME_RELEASE}
-	exit ;;
+	GUESS=powerpc-unknown-mirbsd$UNAME_RELEASE
+	;;
     *:MirBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-mirbsd$UNAME_RELEASE
+	;;
+    *:Sortix:*:*)
+	GUESS=$UNAME_MACHINE-unknown-sortix
+	;;
+    *:Twizzler:*:*)
+	GUESS=$UNAME_MACHINE-unknown-twizzler
+	;;
+    *:Redox:*:*)
+	GUESS=$UNAME_MACHINE-unknown-redox
+	;;
+    mips:OSF1:*.*)
+	GUESS=mips-dec-osf1
+	;;
     alpha:OSF1:*:*)
+	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
+	trap '' 0
 	case $UNAME_RELEASE in
 	*4.0)
 		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
 		;;
 	*5.*)
-	        UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
+		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
 		;;
 	esac
 	# According to Compaq, /usr/sbin/psrinfo has been available on
@@ -231,154 +335,158 @@
 	# covers most systems running today.  This code pipes the CPU
 	# types through head -n 1, so we only detect the type of CPU 0.
 	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
-	case "$ALPHA_CPU_TYPE" in
+	case $ALPHA_CPU_TYPE in
 	    "EV4 (21064)")
-		UNAME_MACHINE="alpha" ;;
+		UNAME_MACHINE=alpha ;;
 	    "EV4.5 (21064)")
-		UNAME_MACHINE="alpha" ;;
+		UNAME_MACHINE=alpha ;;
 	    "LCA4 (21066/21068)")
-		UNAME_MACHINE="alpha" ;;
+		UNAME_MACHINE=alpha ;;
 	    "EV5 (21164)")
-		UNAME_MACHINE="alphaev5" ;;
+		UNAME_MACHINE=alphaev5 ;;
 	    "EV5.6 (21164A)")
-		UNAME_MACHINE="alphaev56" ;;
+		UNAME_MACHINE=alphaev56 ;;
 	    "EV5.6 (21164PC)")
-		UNAME_MACHINE="alphapca56" ;;
+		UNAME_MACHINE=alphapca56 ;;
 	    "EV5.7 (21164PC)")
-		UNAME_MACHINE="alphapca57" ;;
+		UNAME_MACHINE=alphapca57 ;;
 	    "EV6 (21264)")
-		UNAME_MACHINE="alphaev6" ;;
+		UNAME_MACHINE=alphaev6 ;;
 	    "EV6.7 (21264A)")
-		UNAME_MACHINE="alphaev67" ;;
+		UNAME_MACHINE=alphaev67 ;;
 	    "EV6.8CB (21264C)")
-		UNAME_MACHINE="alphaev68" ;;
+		UNAME_MACHINE=alphaev68 ;;
 	    "EV6.8AL (21264B)")
-		UNAME_MACHINE="alphaev68" ;;
+		UNAME_MACHINE=alphaev68 ;;
 	    "EV6.8CX (21264D)")
-		UNAME_MACHINE="alphaev68" ;;
+		UNAME_MACHINE=alphaev68 ;;
 	    "EV6.9A (21264/EV69A)")
-		UNAME_MACHINE="alphaev69" ;;
+		UNAME_MACHINE=alphaev69 ;;
 	    "EV7 (21364)")
-		UNAME_MACHINE="alphaev7" ;;
+		UNAME_MACHINE=alphaev7 ;;
 	    "EV7.9 (21364A)")
-		UNAME_MACHINE="alphaev79" ;;
+		UNAME_MACHINE=alphaev79 ;;
 	esac
 	# A Pn.n version is a patched version.
 	# A Vn.n version is a released version.
 	# A Tn.n version is a released field test version.
 	# A Xn.n version is an unreleased experimental baselevel.
 	# 1.2 uses "1.2" for uname -r.
-	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-	exit ;;
-    Alpha\ *:Windows_NT*:*)
-	# How do we know it's Interix rather than the generic POSIX subsystem?
-	# Should we change UNAME_MACHINE based on the output of uname instead
-	# of the specific Alpha model?
-	echo alpha-pc-interix
-	exit ;;
-    21064:Windows_NT:50:3)
-	echo alpha-dec-winnt3.5
-	exit ;;
+	OSF_REL=`echo "$UNAME_RELEASE" | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
+	GUESS=$UNAME_MACHINE-dec-osf$OSF_REL
+	;;
     Amiga*:UNIX_System_V:4.0:*)
-	echo m68k-unknown-sysv4
-	exit ;;
+	GUESS=m68k-unknown-sysv4
+	;;
     *:[Aa]miga[Oo][Ss]:*:*)
-	echo ${UNAME_MACHINE}-unknown-amigaos
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-amigaos
+	;;
     *:[Mm]orph[Oo][Ss]:*:*)
-	echo ${UNAME_MACHINE}-unknown-morphos
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-morphos
+	;;
     *:OS/390:*:*)
-	echo i370-ibm-openedition
-	exit ;;
+	GUESS=i370-ibm-openedition
+	;;
     *:z/VM:*:*)
-	echo s390-ibm-zvmoe
-	exit ;;
+	GUESS=s390-ibm-zvmoe
+	;;
     *:OS400:*:*)
-        echo powerpc-ibm-os400
-	exit ;;
+	GUESS=powerpc-ibm-os400
+	;;
     arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
-	echo arm-acorn-riscix${UNAME_RELEASE}
-	exit ;;
-    arm:riscos:*:*|arm:RISCOS:*:*)
-	echo arm-unknown-riscos
-	exit ;;
+	GUESS=arm-acorn-riscix$UNAME_RELEASE
+	;;
+    arm*:riscos:*:*|arm*:RISCOS:*:*)
+	GUESS=arm-unknown-riscos
+	;;
     SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
-	echo hppa1.1-hitachi-hiuxmpp
-	exit ;;
+	GUESS=hppa1.1-hitachi-hiuxmpp
+	;;
     Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
 	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
-	if test "`(/bin/universe) 2>/dev/null`" = att ; then
-		echo pyramid-pyramid-sysv3
-	else
-		echo pyramid-pyramid-bsd
-	fi
-	exit ;;
+	case `(/bin/universe) 2>/dev/null` in
+	    att) GUESS=pyramid-pyramid-sysv3 ;;
+	    *)   GUESS=pyramid-pyramid-bsd   ;;
+	esac
+	;;
     NILE*:*:*:dcosx)
-	echo pyramid-pyramid-svr4
-	exit ;;
+	GUESS=pyramid-pyramid-svr4
+	;;
     DRS?6000:unix:4.0:6*)
-	echo sparc-icl-nx6
-	exit ;;
+	GUESS=sparc-icl-nx6
+	;;
     DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
 	case `/usr/bin/uname -p` in
-	    sparc) echo sparc-icl-nx7; exit ;;
-	esac ;;
+	    sparc) GUESS=sparc-icl-nx7 ;;
+	esac
+	;;
+    s390x:SunOS:*:*)
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=$UNAME_MACHINE-ibm-solaris2$SUN_REL
+	;;
     sun4H:SunOS:5.*:*)
-	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit ;;
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=sparc-hal-solaris2$SUN_REL
+	;;
     sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
-	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit ;;
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=sparc-sun-solaris2$SUN_REL
+	;;
+    i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)
+	GUESS=i386-pc-auroraux$UNAME_RELEASE
+	;;
     i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
-	eval $set_cc_for_build
-	SUN_ARCH="i386"
+	set_cc_for_build
+	SUN_ARCH=i386
 	# If there is a compiler, see if it is configured for 64-bit objects.
 	# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.
 	# This test works for both compilers.
-	if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
+	if test "$CC_FOR_BUILD" != no_compiler_found; then
 	    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \
-		(CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
+		(CCOPTS="" $CC_FOR_BUILD -m64 -E - 2>/dev/null) | \
 		grep IS_64BIT_ARCH >/dev/null
 	    then
-		SUN_ARCH="x86_64"
+		SUN_ARCH=x86_64
 	    fi
 	fi
-	echo ${SUN_ARCH}-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit ;;
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=$SUN_ARCH-pc-solaris2$SUN_REL
+	;;
     sun4*:SunOS:6*:*)
 	# According to config.sub, this is the proper way to canonicalize
 	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
 	# it's likely to be more like Solaris than SunOS4.
-	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit ;;
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=sparc-sun-solaris3$SUN_REL
+	;;
     sun4*:SunOS:*:*)
-	case "`/usr/bin/arch -k`" in
+	case `/usr/bin/arch -k` in
 	    Series*|S4*)
 		UNAME_RELEASE=`uname -v`
 		;;
 	esac
-	# Japanese Language versions have a version number like `4.1.3-JL'.
-	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
-	exit ;;
+	# Japanese Language versions have a version number like '4.1.3-JL'.
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/-/_/'`
+	GUESS=sparc-sun-sunos$SUN_REL
+	;;
     sun3*:SunOS:*:*)
-	echo m68k-sun-sunos${UNAME_RELEASE}
-	exit ;;
+	GUESS=m68k-sun-sunos$UNAME_RELEASE
+	;;
     sun*:*:4.2BSD:*)
 	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
-	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
-	case "`/bin/arch`" in
+	test "x$UNAME_RELEASE" = x && UNAME_RELEASE=3
+	case `/bin/arch` in
 	    sun3)
-		echo m68k-sun-sunos${UNAME_RELEASE}
+		GUESS=m68k-sun-sunos$UNAME_RELEASE
 		;;
 	    sun4)
-		echo sparc-sun-sunos${UNAME_RELEASE}
+		GUESS=sparc-sun-sunos$UNAME_RELEASE
 		;;
 	esac
-	exit ;;
+	;;
     aushp:SunOS:*:*)
-	echo sparc-auspex-sunos${UNAME_RELEASE}
-	exit ;;
+	GUESS=sparc-auspex-sunos$UNAME_RELEASE
+	;;
     # The situation for MiNT is a little confusing.  The machine name
     # can be virtually everything (everything which is not
     # "atarist" or "atariste" at least should have a processor
@@ -388,44 +496,44 @@
     # MiNT.  But MiNT is downward compatible to TOS, so this should
     # be no problem.
     atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
-        echo m68k-atari-mint${UNAME_RELEASE}
-	exit ;;
+	GUESS=m68k-atari-mint$UNAME_RELEASE
+	;;
     atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
-	echo m68k-atari-mint${UNAME_RELEASE}
-        exit ;;
+	GUESS=m68k-atari-mint$UNAME_RELEASE
+	;;
     *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
-        echo m68k-atari-mint${UNAME_RELEASE}
-	exit ;;
+	GUESS=m68k-atari-mint$UNAME_RELEASE
+	;;
     milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
-        echo m68k-milan-mint${UNAME_RELEASE}
-        exit ;;
+	GUESS=m68k-milan-mint$UNAME_RELEASE
+	;;
     hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
-        echo m68k-hades-mint${UNAME_RELEASE}
-        exit ;;
+	GUESS=m68k-hades-mint$UNAME_RELEASE
+	;;
     *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
-        echo m68k-unknown-mint${UNAME_RELEASE}
-        exit ;;
+	GUESS=m68k-unknown-mint$UNAME_RELEASE
+	;;
     m68k:machten:*:*)
-	echo m68k-apple-machten${UNAME_RELEASE}
-	exit ;;
+	GUESS=m68k-apple-machten$UNAME_RELEASE
+	;;
     powerpc:machten:*:*)
-	echo powerpc-apple-machten${UNAME_RELEASE}
-	exit ;;
+	GUESS=powerpc-apple-machten$UNAME_RELEASE
+	;;
     RISC*:Mach:*:*)
-	echo mips-dec-mach_bsd4.3
-	exit ;;
+	GUESS=mips-dec-mach_bsd4.3
+	;;
     RISC*:ULTRIX:*:*)
-	echo mips-dec-ultrix${UNAME_RELEASE}
-	exit ;;
+	GUESS=mips-dec-ultrix$UNAME_RELEASE
+	;;
     VAX*:ULTRIX*:*:*)
-	echo vax-dec-ultrix${UNAME_RELEASE}
-	exit ;;
+	GUESS=vax-dec-ultrix$UNAME_RELEASE
+	;;
     2020:CLIX:*:* | 2430:CLIX:*:*)
-	echo clipper-intergraph-clix${UNAME_RELEASE}
-	exit ;;
+	GUESS=clipper-intergraph-clix$UNAME_RELEASE
+	;;
     mips:*:*:UMIPS | mips:*:*:RISCos)
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
+	set_cc_for_build
+	sed 's/^	//' << EOF > "$dummy.c"
 #ifdef __cplusplus
 #include <stdio.h>  /* for printf() prototype */
 	int main (int argc, char *argv[]) {
@@ -434,98 +542,100 @@
 #endif
 	#if defined (host_mips) && defined (MIPSEB)
 	#if defined (SYSTYPE_SYSV)
-	  printf ("mips-mips-riscos%ssysv\n", argv[1]); exit (0);
+	  printf ("mips-mips-riscos%ssysv\\n", argv[1]); exit (0);
 	#endif
 	#if defined (SYSTYPE_SVR4)
-	  printf ("mips-mips-riscos%ssvr4\n", argv[1]); exit (0);
+	  printf ("mips-mips-riscos%ssvr4\\n", argv[1]); exit (0);
 	#endif
 	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
-	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
+	  printf ("mips-mips-riscos%sbsd\\n", argv[1]); exit (0);
 	#endif
 	#endif
 	  exit (-1);
 	}
 EOF
-	$CC_FOR_BUILD -o $dummy $dummy.c &&
-	  dummyarg=`echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` &&
-	  SYSTEM_NAME=`$dummy $dummyarg` &&
+	$CC_FOR_BUILD -o "$dummy" "$dummy.c" &&
+	  dummyarg=`echo "$UNAME_RELEASE" | sed -n 's/\([0-9]*\).*/\1/p'` &&
+	  SYSTEM_NAME=`"$dummy" "$dummyarg"` &&
 	    { echo "$SYSTEM_NAME"; exit; }
-	echo mips-mips-riscos${UNAME_RELEASE}
-	exit ;;
+	GUESS=mips-mips-riscos$UNAME_RELEASE
+	;;
     Motorola:PowerMAX_OS:*:*)
-	echo powerpc-motorola-powermax
-	exit ;;
+	GUESS=powerpc-motorola-powermax
+	;;
     Motorola:*:4.3:PL8-*)
-	echo powerpc-harris-powermax
-	exit ;;
+	GUESS=powerpc-harris-powermax
+	;;
     Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
-	echo powerpc-harris-powermax
-	exit ;;
+	GUESS=powerpc-harris-powermax
+	;;
     Night_Hawk:Power_UNIX:*:*)
-	echo powerpc-harris-powerunix
-	exit ;;
+	GUESS=powerpc-harris-powerunix
+	;;
     m88k:CX/UX:7*:*)
-	echo m88k-harris-cxux7
-	exit ;;
+	GUESS=m88k-harris-cxux7
+	;;
     m88k:*:4*:R4*)
-	echo m88k-motorola-sysv4
-	exit ;;
+	GUESS=m88k-motorola-sysv4
+	;;
     m88k:*:3*:R3*)
-	echo m88k-motorola-sysv3
-	exit ;;
+	GUESS=m88k-motorola-sysv3
+	;;
     AViiON:dgux:*:*)
-        # DG/UX returns AViiON for all architectures
-        UNAME_PROCESSOR=`/usr/bin/uname -p`
-	if [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]
+	# DG/UX returns AViiON for all architectures
+	UNAME_PROCESSOR=`/usr/bin/uname -p`
+	if test "$UNAME_PROCESSOR" = mc88100 || test "$UNAME_PROCESSOR" = mc88110
 	then
-	    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \
-	       [ ${TARGET_BINARY_INTERFACE}x = x ]
+	    if test "$TARGET_BINARY_INTERFACE"x = m88kdguxelfx || \
+	       test "$TARGET_BINARY_INTERFACE"x = x
 	    then
-		echo m88k-dg-dgux${UNAME_RELEASE}
+		GUESS=m88k-dg-dgux$UNAME_RELEASE
 	    else
-		echo m88k-dg-dguxbcs${UNAME_RELEASE}
+		GUESS=m88k-dg-dguxbcs$UNAME_RELEASE
 	    fi
 	else
-	    echo i586-dg-dgux${UNAME_RELEASE}
+	    GUESS=i586-dg-dgux$UNAME_RELEASE
 	fi
- 	exit ;;
+	;;
     M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
-	echo m88k-dolphin-sysv3
-	exit ;;
+	GUESS=m88k-dolphin-sysv3
+	;;
     M88*:*:R3*:*)
 	# Delta 88k system running SVR3
-	echo m88k-motorola-sysv3
-	exit ;;
+	GUESS=m88k-motorola-sysv3
+	;;
     XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
-	echo m88k-tektronix-sysv3
-	exit ;;
+	GUESS=m88k-tektronix-sysv3
+	;;
     Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
-	echo m68k-tektronix-bsd
-	exit ;;
+	GUESS=m68k-tektronix-bsd
+	;;
     *:IRIX*:*:*)
-	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
-	exit ;;
+	IRIX_REL=`echo "$UNAME_RELEASE" | sed -e 's/-/_/g'`
+	GUESS=mips-sgi-irix$IRIX_REL
+	;;
     ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
-	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
-	exit ;;               # Note that: echo "'`uname -s`'" gives 'AIX '
+	GUESS=romp-ibm-aix    # uname -m gives an 8 hex-code CPU id
+	;;                    # Note that: echo "'`uname -s`'" gives 'AIX '
     i*86:AIX:*:*)
-	echo i386-ibm-aix
-	exit ;;
+	GUESS=i386-ibm-aix
+	;;
     ia64:AIX:*:*)
-	if [ -x /usr/bin/oslevel ] ; then
+	if test -x /usr/bin/oslevel ; then
 		IBM_REV=`/usr/bin/oslevel`
 	else
-		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
+		IBM_REV=$UNAME_VERSION.$UNAME_RELEASE
 	fi
-	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
-	exit ;;
+	GUESS=$UNAME_MACHINE-ibm-aix$IBM_REV
+	;;
     *:AIX:2:3)
 	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
-		eval $set_cc_for_build
-		sed 's/^		//' << EOF >$dummy.c
+		set_cc_for_build
+		sed 's/^		//' << EOF > "$dummy.c"
 		#include <sys/systemcfg.h>
 
-		main()
+		int
+		main ()
 			{
 			if (!__power_pc())
 				exit(1);
@@ -533,115 +643,117 @@
 			exit(0);
 			}
 EOF
-		if $CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy`
+		if $CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=`"$dummy"`
 		then
-			echo "$SYSTEM_NAME"
+			GUESS=$SYSTEM_NAME
 		else
-			echo rs6000-ibm-aix3.2.5
+			GUESS=rs6000-ibm-aix3.2.5
 		fi
 	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
-		echo rs6000-ibm-aix3.2.4
+		GUESS=rs6000-ibm-aix3.2.4
 	else
-		echo rs6000-ibm-aix3.2
+		GUESS=rs6000-ibm-aix3.2
 	fi
-	exit ;;
-    *:AIX:*:[456])
+	;;
+    *:AIX:*:[4567])
 	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
-	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
+	if /usr/sbin/lsattr -El "$IBM_CPU_ID" | grep ' POWER' >/dev/null 2>&1; then
 		IBM_ARCH=rs6000
 	else
 		IBM_ARCH=powerpc
 	fi
-	if [ -x /usr/bin/oslevel ] ; then
-		IBM_REV=`/usr/bin/oslevel`
+	if test -x /usr/bin/lslpp ; then
+		IBM_REV=`/usr/bin/lslpp -Lqc bos.rte.libc | \
+			   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/`
 	else
-		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
+		IBM_REV=$UNAME_VERSION.$UNAME_RELEASE
 	fi
-	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
-	exit ;;
+	GUESS=$IBM_ARCH-ibm-aix$IBM_REV
+	;;
     *:AIX:*:*)
-	echo rs6000-ibm-aix
-	exit ;;
-    ibmrt:4.4BSD:*|romp-ibm:BSD:*)
-	echo romp-ibm-bsd4.4
-	exit ;;
+	GUESS=rs6000-ibm-aix
+	;;
+    ibmrt:4.4BSD:*|romp-ibm:4.4BSD:*)
+	GUESS=romp-ibm-bsd4.4
+	;;
     ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
-	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
-	exit ;;                             # report: romp-ibm BSD 4.3
+	GUESS=romp-ibm-bsd$UNAME_RELEASE    # 4.3 with uname added to
+	;;                                  # report: romp-ibm BSD 4.3
     *:BOSX:*:*)
-	echo rs6000-bull-bosx
-	exit ;;
+	GUESS=rs6000-bull-bosx
+	;;
     DPX/2?00:B.O.S.:*:*)
-	echo m68k-bull-sysv3
-	exit ;;
+	GUESS=m68k-bull-sysv3
+	;;
     9000/[34]??:4.3bsd:1.*:*)
-	echo m68k-hp-bsd
-	exit ;;
+	GUESS=m68k-hp-bsd
+	;;
     hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
-	echo m68k-hp-bsd4.4
-	exit ;;
+	GUESS=m68k-hp-bsd4.4
+	;;
     9000/[34678]??:HP-UX:*:*)
-	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
-	case "${UNAME_MACHINE}" in
-	    9000/31? )            HP_ARCH=m68000 ;;
-	    9000/[34]?? )         HP_ARCH=m68k ;;
+	HPUX_REV=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*.[0B]*//'`
+	case $UNAME_MACHINE in
+	    9000/31?)            HP_ARCH=m68000 ;;
+	    9000/[34]??)         HP_ARCH=m68k ;;
 	    9000/[678][0-9][0-9])
-		if [ -x /usr/bin/getconf ]; then
+		if test -x /usr/bin/getconf; then
 		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
-                    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
-                    case "${sc_cpu_version}" in
-                      523) HP_ARCH="hppa1.0" ;; # CPU_PA_RISC1_0
-                      528) HP_ARCH="hppa1.1" ;; # CPU_PA_RISC1_1
-                      532)                      # CPU_PA_RISC2_0
-                        case "${sc_kernel_bits}" in
-                          32) HP_ARCH="hppa2.0n" ;;
-                          64) HP_ARCH="hppa2.0w" ;;
-			  '') HP_ARCH="hppa2.0" ;;   # HP-UX 10.20
-                        esac ;;
-                    esac
+		    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
+		    case $sc_cpu_version in
+		      523) HP_ARCH=hppa1.0 ;; # CPU_PA_RISC1_0
+		      528) HP_ARCH=hppa1.1 ;; # CPU_PA_RISC1_1
+		      532)                      # CPU_PA_RISC2_0
+			case $sc_kernel_bits in
+			  32) HP_ARCH=hppa2.0n ;;
+			  64) HP_ARCH=hppa2.0w ;;
+			  '') HP_ARCH=hppa2.0 ;;   # HP-UX 10.20
+			esac ;;
+		    esac
 		fi
-		if [ "${HP_ARCH}" = "" ]; then
-		    eval $set_cc_for_build
-		    sed 's/^              //' << EOF >$dummy.c
-
-              #define _HPUX_SOURCE
-              #include <stdlib.h>
-              #include <unistd.h>
-
-              int main ()
-              {
-              #if defined(_SC_KERNEL_BITS)
-                  long bits = sysconf(_SC_KERNEL_BITS);
-              #endif
-                  long cpu  = sysconf (_SC_CPU_VERSION);
-
-                  switch (cpu)
-              	{
-              	case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
-              	case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
-              	case CPU_PA_RISC2_0:
-              #if defined(_SC_KERNEL_BITS)
-              	    switch (bits)
-              		{
-              		case 64: puts ("hppa2.0w"); break;
-              		case 32: puts ("hppa2.0n"); break;
-              		default: puts ("hppa2.0"); break;
-              		} break;
-              #else  /* !defined(_SC_KERNEL_BITS) */
-              	    puts ("hppa2.0"); break;
-              #endif
-              	default: puts ("hppa1.0"); break;
-              	}
-                  exit (0);
-              }
+		if test "$HP_ARCH" = ""; then
+		    set_cc_for_build
+		    sed 's/^		//' << EOF > "$dummy.c"
+
+		#define _HPUX_SOURCE
+		#include <stdlib.h>
+		#include <unistd.h>
+
+		int
+		main ()
+		{
+		#if defined(_SC_KERNEL_BITS)
+		    long bits = sysconf(_SC_KERNEL_BITS);
+		#endif
+		    long cpu  = sysconf (_SC_CPU_VERSION);
+
+		    switch (cpu)
+			{
+			case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
+			case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
+			case CPU_PA_RISC2_0:
+		#if defined(_SC_KERNEL_BITS)
+			    switch (bits)
+				{
+				case 64: puts ("hppa2.0w"); break;
+				case 32: puts ("hppa2.0n"); break;
+				default: puts ("hppa2.0"); break;
+				} break;
+		#else  /* !defined(_SC_KERNEL_BITS) */
+			    puts ("hppa2.0"); break;
+		#endif
+			default: puts ("hppa1.0"); break;
+			}
+		    exit (0);
+		}
 EOF
-		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
+		    (CCOPTS="" $CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null) && HP_ARCH=`"$dummy"`
 		    test -z "$HP_ARCH" && HP_ARCH=hppa
 		fi ;;
 	esac
-	if [ ${HP_ARCH} = "hppa2.0w" ]
+	if test "$HP_ARCH" = hppa2.0w
 	then
-	    eval $set_cc_for_build
+	    set_cc_for_build
 
 	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
 	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
@@ -652,23 +764,23 @@
 	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
 	    # => hppa64-hp-hpux11.23
 
-	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
-		grep __LP64__ >/dev/null
+	    if echo __LP64__ | (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) |
+		grep -q __LP64__
 	    then
-		HP_ARCH="hppa2.0w"
+		HP_ARCH=hppa2.0w
 	    else
-		HP_ARCH="hppa64"
+		HP_ARCH=hppa64
 	    fi
 	fi
-	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
-	exit ;;
+	GUESS=$HP_ARCH-hp-hpux$HPUX_REV
+	;;
     ia64:HP-UX:*:*)
-	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
-	echo ia64-hp-hpux${HPUX_REV}
-	exit ;;
+	HPUX_REV=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*.[0B]*//'`
+	GUESS=ia64-hp-hpux$HPUX_REV
+	;;
     3050*:HI-UX:*:*)
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
+	set_cc_for_build
+	sed 's/^	//' << EOF > "$dummy.c"
 	#include <unistd.h>
 	int
 	main ()
@@ -693,411 +805,475 @@
 	  exit (0);
 	}
 EOF
-	$CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy` &&
+	$CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=`"$dummy"` &&
 		{ echo "$SYSTEM_NAME"; exit; }
-	echo unknown-hitachi-hiuxwe2
-	exit ;;
-    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
-	echo hppa1.1-hp-bsd
-	exit ;;
+	GUESS=unknown-hitachi-hiuxwe2
+	;;
+    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:*)
+	GUESS=hppa1.1-hp-bsd
+	;;
     9000/8??:4.3bsd:*:*)
-	echo hppa1.0-hp-bsd
-	exit ;;
+	GUESS=hppa1.0-hp-bsd
+	;;
     *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
-	echo hppa1.0-hp-mpeix
-	exit ;;
-    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
-	echo hppa1.1-hp-osf
-	exit ;;
+	GUESS=hppa1.0-hp-mpeix
+	;;
+    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:*)
+	GUESS=hppa1.1-hp-osf
+	;;
     hp8??:OSF1:*:*)
-	echo hppa1.0-hp-osf
-	exit ;;
+	GUESS=hppa1.0-hp-osf
+	;;
     i*86:OSF1:*:*)
-	if [ -x /usr/sbin/sysversion ] ; then
-	    echo ${UNAME_MACHINE}-unknown-osf1mk
+	if test -x /usr/sbin/sysversion ; then
+	    GUESS=$UNAME_MACHINE-unknown-osf1mk
 	else
-	    echo ${UNAME_MACHINE}-unknown-osf1
+	    GUESS=$UNAME_MACHINE-unknown-osf1
 	fi
-	exit ;;
+	;;
     parisc*:Lites*:*:*)
-	echo hppa1.1-hp-lites
-	exit ;;
+	GUESS=hppa1.1-hp-lites
+	;;
     C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
-	echo c1-convex-bsd
-        exit ;;
+	GUESS=c1-convex-bsd
+	;;
     C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
 	if getsysinfo -f scalar_acc
 	then echo c32-convex-bsd
 	else echo c2-convex-bsd
 	fi
-        exit ;;
+	exit ;;
     C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
-	echo c34-convex-bsd
-        exit ;;
+	GUESS=c34-convex-bsd
+	;;
     C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
-	echo c38-convex-bsd
-        exit ;;
+	GUESS=c38-convex-bsd
+	;;
     C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
-	echo c4-convex-bsd
-        exit ;;
+	GUESS=c4-convex-bsd
+	;;
     CRAY*Y-MP:*:*:*)
-	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
+	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
+	GUESS=ymp-cray-unicos$CRAY_REL
+	;;
     CRAY*[A-Z]90:*:*:*)
-	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
+	echo "$UNAME_MACHINE"-cray-unicos"$UNAME_RELEASE" \
 	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
 	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
 	      -e 's/\.[^.]*$/.X/'
 	exit ;;
     CRAY*TS:*:*:*)
-	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
+	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
+	GUESS=t90-cray-unicos$CRAY_REL
+	;;
     CRAY*T3E:*:*:*)
-	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
+	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
+	GUESS=alphaev5-cray-unicosmk$CRAY_REL
+	;;
     CRAY*SV1:*:*:*)
-	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
+	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
+	GUESS=sv1-cray-unicos$CRAY_REL
+	;;
     *:UNICOS/mp:*:*)
-	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
+	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
+	GUESS=craynv-cray-unicosmp$CRAY_REL
+	;;
     F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
-	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
-        FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
-        echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
-        exit ;;
+	FUJITSU_PROC=`uname -m | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
+	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
+	FUJITSU_REL=`echo "$UNAME_RELEASE" | sed -e 's/ /_/'`
+	GUESS=${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}
+	;;
     5000:UNIX_System_V:4.*:*)
-        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
-        FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
-        echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
-	exit ;;
+	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
+	FUJITSU_REL=`echo "$UNAME_RELEASE" | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/ /_/'`
+	GUESS=sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}
+	;;
     i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
-	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-bsdi$UNAME_RELEASE
+	;;
     sparc*:BSD/OS:*:*)
-	echo sparc-unknown-bsdi${UNAME_RELEASE}
-	exit ;;
+	GUESS=sparc-unknown-bsdi$UNAME_RELEASE
+	;;
     *:BSD/OS:*:*)
-	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-bsdi$UNAME_RELEASE
+	;;
+    arm:FreeBSD:*:*)
+	UNAME_PROCESSOR=`uname -p`
+	set_cc_for_build
+	if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
+	    | grep -q __ARM_PCS_VFP
+	then
+	    FREEBSD_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
+	    GUESS=$UNAME_PROCESSOR-unknown-freebsd$FREEBSD_REL-gnueabi
+	else
+	    FREEBSD_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
+	    GUESS=$UNAME_PROCESSOR-unknown-freebsd$FREEBSD_REL-gnueabihf
+	fi
+	;;
     *:FreeBSD:*:*)
-	case ${UNAME_MACHINE} in
-	    pc98)
-		echo i386-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+	UNAME_PROCESSOR=`uname -p`
+	case $UNAME_PROCESSOR in
 	    amd64)
-		echo x86_64-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
-	    *)
-		echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+		UNAME_PROCESSOR=x86_64 ;;
+	    i386)
+		UNAME_PROCESSOR=i586 ;;
 	esac
-	exit ;;
+	FREEBSD_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
+	GUESS=$UNAME_PROCESSOR-unknown-freebsd$FREEBSD_REL
+	;;
     i*:CYGWIN*:*)
-	echo ${UNAME_MACHINE}-pc-cygwin
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-cygwin
+	;;
+    *:MINGW64*:*)
+	GUESS=$UNAME_MACHINE-pc-mingw64
+	;;
     *:MINGW*:*)
-	echo ${UNAME_MACHINE}-pc-mingw32
-	exit ;;
-    i*:windows32*:*)
-    	# uname -m includes "-pc" on this system.
-    	echo ${UNAME_MACHINE}-mingw32
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-mingw32
+	;;
+    *:MSYS*:*)
+	GUESS=$UNAME_MACHINE-pc-msys
+	;;
     i*:PW*:*)
-	echo ${UNAME_MACHINE}-pc-pw32
-	exit ;;
-    *:Interix*:[3456]*)
-    	case ${UNAME_MACHINE} in
+	GUESS=$UNAME_MACHINE-pc-pw32
+	;;
+    *:SerenityOS:*:*)
+        GUESS=$UNAME_MACHINE-pc-serenity
+        ;;
+    *:Interix*:*)
+	case $UNAME_MACHINE in
 	    x86)
-		echo i586-pc-interix${UNAME_RELEASE}
-		exit ;;
-	    EM64T | authenticamd | genuineintel)
-		echo x86_64-unknown-interix${UNAME_RELEASE}
-		exit ;;
+		GUESS=i586-pc-interix$UNAME_RELEASE
+		;;
+	    authenticamd | genuineintel | EM64T)
+		GUESS=x86_64-unknown-interix$UNAME_RELEASE
+		;;
 	    IA64)
-		echo ia64-unknown-interix${UNAME_RELEASE}
-		exit ;;
+		GUESS=ia64-unknown-interix$UNAME_RELEASE
+		;;
 	esac ;;
-    [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
-	echo i${UNAME_MACHINE}-pc-mks
-	exit ;;
-    i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
-	# How do we know it's Interix rather than the generic POSIX subsystem?
-	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
-	# UNAME_MACHINE based on the output of uname instead of i386?
-	echo i586-pc-interix
-	exit ;;
     i*:UWIN*:*)
-	echo ${UNAME_MACHINE}-pc-uwin
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-uwin
+	;;
     amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
-	echo x86_64-unknown-cygwin
-	exit ;;
-    p*:CYGWIN*:*)
-	echo powerpcle-unknown-cygwin
-	exit ;;
+	GUESS=x86_64-pc-cygwin
+	;;
     prep*:SunOS:5.*:*)
-	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit ;;
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=powerpcle-unknown-solaris2$SUN_REL
+	;;
     *:GNU:*:*)
 	# the GNU system
-	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
-	exit ;;
+	GNU_ARCH=`echo "$UNAME_MACHINE" | sed -e 's,[-/].*$,,'`
+	GNU_REL=`echo "$UNAME_RELEASE" | sed -e 's,/.*$,,'`
+	GUESS=$GNU_ARCH-unknown-$LIBC$GNU_REL
+	;;
     *:GNU/*:*:*)
 	# other systems with GNU libc and userland
-	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
-	exit ;;
-    i*86:Minix:*:*)
-	echo ${UNAME_MACHINE}-pc-minix
-	exit ;;
+	GNU_SYS=`echo "$UNAME_SYSTEM" | sed 's,^[^/]*/,,' | tr "[:upper:]" "[:lower:]"`
+	GNU_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
+	GUESS=$UNAME_MACHINE-unknown-$GNU_SYS$GNU_REL-$LIBC
+	;;
+    x86_64:[Mm]anagarm:*:*|i?86:[Mm]anagarm:*:*)
+	GUESS="$UNAME_MACHINE-pc-managarm-mlibc"
+	;;
+    *:[Mm]anagarm:*:*)
+	GUESS="$UNAME_MACHINE-unknown-managarm-mlibc"
+	;;
+    *:Minix:*:*)
+	GUESS=$UNAME_MACHINE-unknown-minix
+	;;
+    aarch64:Linux:*:*)
+	set_cc_for_build
+	CPU=$UNAME_MACHINE
+	LIBCABI=$LIBC
+	if test "$CC_FOR_BUILD" != no_compiler_found; then
+	    ABI=64
+	    sed 's/^	    //' << EOF > "$dummy.c"
+	    #ifdef __ARM_EABI__
+	    #ifdef __ARM_PCS_VFP
+	    ABI=eabihf
+	    #else
+	    ABI=eabi
+	    #endif
+	    #endif
+EOF
+	    cc_set_abi=`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^ABI' | sed 's, ,,g'`
+	    eval "$cc_set_abi"
+	    case $ABI in
+		eabi | eabihf) CPU=armv8l; LIBCABI=$LIBC$ABI ;;
+	    esac
+	fi
+	GUESS=$CPU-unknown-linux-$LIBCABI
+	;;
+    aarch64_be:Linux:*:*)
+	UNAME_MACHINE=aarch64_be
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    alpha:Linux:*:*)
+	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' /proc/cpuinfo 2>/dev/null` in
+	  EV5)   UNAME_MACHINE=alphaev5 ;;
+	  EV56)  UNAME_MACHINE=alphaev56 ;;
+	  PCA56) UNAME_MACHINE=alphapca56 ;;
+	  PCA57) UNAME_MACHINE=alphapca56 ;;
+	  EV6)   UNAME_MACHINE=alphaev6 ;;
+	  EV67)  UNAME_MACHINE=alphaev67 ;;
+	  EV68*) UNAME_MACHINE=alphaev68 ;;
+	esac
+	objdump --private-headers /bin/sh | grep -q ld.so.1
+	if test "$?" = 0 ; then LIBC=gnulibc1 ; fi
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    arc:Linux:*:* | arceb:Linux:*:* | arc32:Linux:*:* | arc64:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     arm*:Linux:*:*)
-	eval $set_cc_for_build
+	set_cc_for_build
 	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
 	    | grep -q __ARM_EABI__
 	then
-	    echo ${UNAME_MACHINE}-unknown-linux-gnu
+	    GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
 	else
-	    echo ${UNAME_MACHINE}-unknown-linux-gnueabi
+	    if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
+		| grep -q __ARM_PCS_VFP
+	    then
+		GUESS=$UNAME_MACHINE-unknown-linux-${LIBC}eabi
+	    else
+		GUESS=$UNAME_MACHINE-unknown-linux-${LIBC}eabihf
+	    fi
 	fi
-	exit ;;
+	;;
     avr32*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     cris:Linux:*:*)
-	echo cris-axis-linux-gnu
-	exit ;;
+	GUESS=$UNAME_MACHINE-axis-linux-$LIBC
+	;;
     crisv32:Linux:*:*)
-	echo crisv32-axis-linux-gnu
-	exit ;;
+	GUESS=$UNAME_MACHINE-axis-linux-$LIBC
+	;;
+    e2k:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     frv:Linux:*:*)
-    	echo frv-unknown-linux-gnu
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    hexagon:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    i*86:Linux:*:*)
+	GUESS=$UNAME_MACHINE-pc-linux-$LIBC
+	;;
     ia64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    k1om:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    kvx:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    kvx:cos:*:*)
+	GUESS=$UNAME_MACHINE-unknown-cos
+	;;
+    kvx:mbr:*:*)
+	GUESS=$UNAME_MACHINE-unknown-mbr
+	;;
+    loongarch32:Linux:*:* | loongarch64:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     m32r*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     m68*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
-    mips:Linux:*:*)
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    mips:Linux:*:* | mips64:Linux:*:*)
+	set_cc_for_build
+	IS_GLIBC=0
+	test x"${LIBC}" = xgnu && IS_GLIBC=1
+	sed 's/^	//' << EOF > "$dummy.c"
 	#undef CPU
 	#undef mips
 	#undef mipsel
-	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
-	CPU=mipsel
+	#undef mips64
+	#undef mips64el
+	#if ${IS_GLIBC} && defined(_ABI64)
+	LIBCABI=gnuabi64
 	#else
-	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
-	CPU=mips
+	#if ${IS_GLIBC} && defined(_ABIN32)
+	LIBCABI=gnuabin32
 	#else
-	CPU=
+	LIBCABI=${LIBC}
 	#endif
 	#endif
-EOF
-	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
-	    /^CPU/{
-		s: ::g
-		p
-	    }'`"
-	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
-	;;
-    mips64:Linux:*:*)
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#undef CPU
-	#undef mips64
-	#undef mips64el
+
+	#if ${IS_GLIBC} && defined(__mips64) && defined(__mips_isa_rev) && __mips_isa_rev>=6
+	CPU=mipsisa64r6
+	#else
+	#if ${IS_GLIBC} && !defined(__mips64) && defined(__mips_isa_rev) && __mips_isa_rev>=6
+	CPU=mipsisa32r6
+	#else
+	#if defined(__mips64)
+	CPU=mips64
+	#else
+	CPU=mips
+	#endif
+	#endif
+	#endif
+
 	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
-	CPU=mips64el
+	MIPS_ENDIAN=el
 	#else
 	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
-	CPU=mips64
+	MIPS_ENDIAN=
 	#else
-	CPU=
+	MIPS_ENDIAN=
 	#endif
 	#endif
 EOF
-	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
-	    /^CPU/{
-		s: ::g
-		p
-	    }'`"
-	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
+	cc_set_vars=`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^CPU\|^MIPS_ENDIAN\|^LIBCABI'`
+	eval "$cc_set_vars"
+	test "x$CPU" != x && { echo "$CPU${MIPS_ENDIAN}-unknown-linux-$LIBCABI"; exit; }
+	;;
+    mips64el:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    openrisc*:Linux:*:*)
+	GUESS=or1k-unknown-linux-$LIBC
+	;;
+    or32:Linux:*:* | or1k*:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
 	;;
-    or32:Linux:*:*)
-	echo or32-unknown-linux-gnu
-	exit ;;
-    ppc:Linux:*:*)
-	echo powerpc-unknown-linux-gnu
-	exit ;;
-    ppc64:Linux:*:*)
-	echo powerpc64-unknown-linux-gnu
-	exit ;;
-    alpha:Linux:*:*)
-	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
-	  EV5)   UNAME_MACHINE=alphaev5 ;;
-	  EV56)  UNAME_MACHINE=alphaev56 ;;
-	  PCA56) UNAME_MACHINE=alphapca56 ;;
-	  PCA57) UNAME_MACHINE=alphapca56 ;;
-	  EV6)   UNAME_MACHINE=alphaev6 ;;
-	  EV67)  UNAME_MACHINE=alphaev67 ;;
-	  EV68*) UNAME_MACHINE=alphaev68 ;;
-        esac
-	objdump --private-headers /bin/sh | grep ld.so.1 >/dev/null
-	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
-	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
-	exit ;;
     padre:Linux:*:*)
-	echo sparc-unknown-linux-gnu
-	exit ;;
+	GUESS=sparc-unknown-linux-$LIBC
+	;;
+    parisc64:Linux:*:* | hppa64:Linux:*:*)
+	GUESS=hppa64-unknown-linux-$LIBC
+	;;
     parisc:Linux:*:* | hppa:Linux:*:*)
 	# Look for CPU level
 	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
-	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
-	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
-	  *)    echo hppa-unknown-linux-gnu ;;
+	  PA7*) GUESS=hppa1.1-unknown-linux-$LIBC ;;
+	  PA8*) GUESS=hppa2.0-unknown-linux-$LIBC ;;
+	  *)    GUESS=hppa-unknown-linux-$LIBC ;;
 	esac
-	exit ;;
-    parisc64:Linux:*:* | hppa64:Linux:*:*)
-	echo hppa64-unknown-linux-gnu
-	exit ;;
+	;;
+    ppc64:Linux:*:*)
+	GUESS=powerpc64-unknown-linux-$LIBC
+	;;
+    ppc:Linux:*:*)
+	GUESS=powerpc-unknown-linux-$LIBC
+	;;
+    ppc64le:Linux:*:*)
+	GUESS=powerpc64le-unknown-linux-$LIBC
+	;;
+    ppcle:Linux:*:*)
+	GUESS=powerpcle-unknown-linux-$LIBC
+	;;
+    riscv32:Linux:*:* | riscv32be:Linux:*:* | riscv64:Linux:*:* | riscv64be:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     s390:Linux:*:* | s390x:Linux:*:*)
-	echo ${UNAME_MACHINE}-ibm-linux
-	exit ;;
+	GUESS=$UNAME_MACHINE-ibm-linux-$LIBC
+	;;
     sh64*:Linux:*:*)
-    	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     sh*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     sparc:Linux:*:* | sparc64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    tile*:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     vax:Linux:*:*)
-	echo ${UNAME_MACHINE}-dec-linux-gnu
-	exit ;;
+	GUESS=$UNAME_MACHINE-dec-linux-$LIBC
+	;;
     x86_64:Linux:*:*)
-	echo x86_64-unknown-linux-gnu
-	exit ;;
-    xtensa*:Linux:*:*)
-    	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit ;;
-    i*86:Linux:*:*)
-	# The BFD linker knows what the default object file format is, so
-	# first see if it will tell us. cd to the root directory to prevent
-	# problems with other programs or directories called `ld' in the path.
-	# Set LC_ALL=C to ensure ld outputs messages in English.
-	ld_supported_targets=`cd /; LC_ALL=C ld --help 2>&1 \
-			 | sed -ne '/supported targets:/!d
-				    s/[ 	][ 	]*/ /g
-				    s/.*supported targets: *//
-				    s/ .*//
-				    p'`
-        case "$ld_supported_targets" in
-	  elf32-i386)
-		TENTATIVE="${UNAME_MACHINE}-pc-linux-gnu"
-		;;
-	  a.out-i386-linux)
-		echo "${UNAME_MACHINE}-pc-linux-gnuaout"
-		exit ;;
-	  "")
-		# Either a pre-BFD a.out linker (linux-gnuoldld) or
-		# one that does not give us useful --help.
-		echo "${UNAME_MACHINE}-pc-linux-gnuoldld"
-		exit ;;
-	esac
-	# Determine whether the default compiler is a.out or elf
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#include <features.h>
-	#ifdef __ELF__
-	# ifdef __GLIBC__
-	#  if __GLIBC__ >= 2
-	LIBC=gnu
-	#  else
-	LIBC=gnulibc1
-	#  endif
-	# else
-	LIBC=gnulibc1
-	# endif
-	#else
-	#if defined(__INTEL_COMPILER) || defined(__PGI) || defined(__SUNPRO_C) || defined(__SUNPRO_CC)
-	LIBC=gnu
-	#else
-	LIBC=gnuaout
-	#endif
-	#endif
-	#ifdef __dietlibc__
-	LIBC=dietlibc
-	#endif
+	set_cc_for_build
+	CPU=$UNAME_MACHINE
+	LIBCABI=$LIBC
+	if test "$CC_FOR_BUILD" != no_compiler_found; then
+	    ABI=64
+	    sed 's/^	    //' << EOF > "$dummy.c"
+	    #ifdef __i386__
+	    ABI=x86
+	    #else
+	    #ifdef __ILP32__
+	    ABI=x32
+	    #endif
+	    #endif
 EOF
-	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
-	    /^LIBC/{
-		s: ::g
-		p
-	    }'`"
-	test x"${LIBC}" != x && {
-		echo "${UNAME_MACHINE}-pc-linux-${LIBC}"
-		exit
-	}
-	test x"${TENTATIVE}" != x && { echo "${TENTATIVE}"; exit; }
+	    cc_set_abi=`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^ABI' | sed 's, ,,g'`
+	    eval "$cc_set_abi"
+	    case $ABI in
+		x86) CPU=i686 ;;
+		x32) LIBCABI=${LIBC}x32 ;;
+	    esac
+	fi
+	GUESS=$CPU-pc-linux-$LIBCABI
+	;;
+    xtensa*:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
 	;;
     i*86:DYNIX/ptx:4*:*)
 	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
 	# earlier versions are messed up and put the nodename in both
 	# sysname and nodename.
-	echo i386-sequent-sysv4
-	exit ;;
+	GUESS=i386-sequent-sysv4
+	;;
     i*86:UNIX_SV:4.2MP:2.*)
-        # Unixware is an offshoot of SVR4, but it has its own version
-        # number series starting with 2...
-        # I am not positive that other SVR4 systems won't match this,
+	# Unixware is an offshoot of SVR4, but it has its own version
+	# number series starting with 2...
+	# I am not positive that other SVR4 systems won't match this,
 	# I just have to hope.  -- rms.
-        # Use sysv4.2uw... so that sysv4* matches it.
-	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
-	exit ;;
+	# Use sysv4.2uw... so that sysv4* matches it.
+	GUESS=$UNAME_MACHINE-pc-sysv4.2uw$UNAME_VERSION
+	;;
     i*86:OS/2:*:*)
-	# If we were able to find `uname', then EMX Unix compatibility
+	# If we were able to find 'uname', then EMX Unix compatibility
 	# is probably installed.
-	echo ${UNAME_MACHINE}-pc-os2-emx
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-os2-emx
+	;;
     i*86:XTS-300:*:STOP)
-	echo ${UNAME_MACHINE}-unknown-stop
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-stop
+	;;
     i*86:atheos:*:*)
-	echo ${UNAME_MACHINE}-unknown-atheos
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-atheos
+	;;
     i*86:syllable:*:*)
-	echo ${UNAME_MACHINE}-pc-syllable
-	exit ;;
-    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.0*:*)
-	echo i386-unknown-lynxos${UNAME_RELEASE}
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-syllable
+	;;
+    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.[02]*:*)
+	GUESS=i386-unknown-lynxos$UNAME_RELEASE
+	;;
     i*86:*DOS:*:*)
-	echo ${UNAME_MACHINE}-pc-msdosdjgpp
-	exit ;;
-    i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
-	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
+	GUESS=$UNAME_MACHINE-pc-msdosdjgpp
+	;;
+    i*86:*:4.*:*)
+	UNAME_REL=`echo "$UNAME_RELEASE" | sed 's/\/MP$//'`
 	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
-		echo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}
+		GUESS=$UNAME_MACHINE-univel-sysv$UNAME_REL
 	else
-		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
+		GUESS=$UNAME_MACHINE-pc-sysv$UNAME_REL
 	fi
-	exit ;;
+	;;
     i*86:*:5:[678]*)
-    	# UnixWare 7.x, OpenUNIX and OpenServer 6.
+	# UnixWare 7.x, OpenUNIX and OpenServer 6.
 	case `/bin/uname -X | grep "^Machine"` in
 	    *486*)	     UNAME_MACHINE=i486 ;;
 	    *Pentium)	     UNAME_MACHINE=i586 ;;
 	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
 	esac
-	echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
+	;;
     i*86:*:3.2:*)
 	if test -f /usr/options/cb.name; then
 		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
-		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
+		GUESS=$UNAME_MACHINE-pc-isc$UNAME_REL
 	elif /bin/uname -X 2>/dev/null >/dev/null ; then
 		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
 		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
@@ -1107,40 +1283,43 @@
 			&& UNAME_MACHINE=i686
 		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
 			&& UNAME_MACHINE=i686
-		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
+		GUESS=$UNAME_MACHINE-pc-sco$UNAME_REL
 	else
-		echo ${UNAME_MACHINE}-pc-sysv32
+		GUESS=$UNAME_MACHINE-pc-sysv32
 	fi
-	exit ;;
+	;;
     pc:*:*:*)
 	# Left here for compatibility:
-        # uname -m prints for DJGPP always 'pc', but it prints nothing about
-        # the processor, so we play safe by assuming i386.
-	echo i386-pc-msdosdjgpp
-        exit ;;
+	# uname -m prints for DJGPP always 'pc', but it prints nothing about
+	# the processor, so we play safe by assuming i586.
+	# Note: whatever this is, it MUST be the same as what config.sub
+	# prints for the "djgpp" host, or else GDB configure will decide that
+	# this is a cross-build.
+	GUESS=i586-pc-msdosdjgpp
+	;;
     Intel:Mach:3*:*)
-	echo i386-pc-mach3
-	exit ;;
+	GUESS=i386-pc-mach3
+	;;
     paragon:*:*:*)
-	echo i860-intel-osf1
-	exit ;;
+	GUESS=i860-intel-osf1
+	;;
     i860:*:4.*:*) # i860-SVR4
 	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
-	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
+	  GUESS=i860-stardent-sysv$UNAME_RELEASE    # Stardent Vistra i860-SVR4
 	else # Add other i860-SVR4 vendors below as they are discovered.
-	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
+	  GUESS=i860-unknown-sysv$UNAME_RELEASE     # Unknown i860-SVR4
 	fi
-	exit ;;
+	;;
     mini*:CTIX:SYS*5:*)
 	# "miniframe"
-	echo m68010-convergent-sysv
-	exit ;;
+	GUESS=m68010-convergent-sysv
+	;;
     mc68k:UNIX:SYSTEM5:3.51m)
-	echo m68k-convergent-sysv
-	exit ;;
+	GUESS=m68k-convergent-sysv
+	;;
     M680?0:D-NIX:5.3:*)
-	echo m68k-diab-dnix
-	exit ;;
+	GUESS=m68k-diab-dnix
+	;;
     M68*:*:R3V[5678]*:*)
 	test -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;
     3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
@@ -1148,209 +1327,303 @@
 	test -r /etc/.relid \
 	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
 	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-	  && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
+	  && { echo i486-ncr-sysv4.3"$OS_REL"; exit; }
 	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
-	  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
+	  && { echo i586-ncr-sysv4.3"$OS_REL"; exit; } ;;
     3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
-        /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-          && { echo i486-ncr-sysv4; exit; } ;;
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	  && { echo i486-ncr-sysv4; exit; } ;;
+    NCR*:*:4.2:* | MPRAS*:*:4.2:*)
+	OS_REL='.3'
+	test -r /etc/.relid \
+	    && OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	    && { echo i486-ncr-sysv4.3"$OS_REL"; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
+	    && { echo i586-ncr-sysv4.3"$OS_REL"; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep pteron >/dev/null \
+	    && { echo i586-ncr-sysv4.3"$OS_REL"; exit; } ;;
     m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
-	echo m68k-unknown-lynxos${UNAME_RELEASE}
-	exit ;;
+	GUESS=m68k-unknown-lynxos$UNAME_RELEASE
+	;;
     mc68030:UNIX_System_V:4.*:*)
-	echo m68k-atari-sysv4
-	exit ;;
+	GUESS=m68k-atari-sysv4
+	;;
     TSUNAMI:LynxOS:2.*:*)
-	echo sparc-unknown-lynxos${UNAME_RELEASE}
-	exit ;;
+	GUESS=sparc-unknown-lynxos$UNAME_RELEASE
+	;;
     rs6000:LynxOS:2.*:*)
-	echo rs6000-unknown-lynxos${UNAME_RELEASE}
-	exit ;;
-    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.0*:*)
-	echo powerpc-unknown-lynxos${UNAME_RELEASE}
-	exit ;;
+	GUESS=rs6000-unknown-lynxos$UNAME_RELEASE
+	;;
+    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.[02]*:*)
+	GUESS=powerpc-unknown-lynxos$UNAME_RELEASE
+	;;
     SM[BE]S:UNIX_SV:*:*)
-	echo mips-dde-sysv${UNAME_RELEASE}
-	exit ;;
+	GUESS=mips-dde-sysv$UNAME_RELEASE
+	;;
     RM*:ReliantUNIX-*:*:*)
-	echo mips-sni-sysv4
-	exit ;;
+	GUESS=mips-sni-sysv4
+	;;
     RM*:SINIX-*:*:*)
-	echo mips-sni-sysv4
-	exit ;;
+	GUESS=mips-sni-sysv4
+	;;
     *:SINIX-*:*:*)
 	if uname -p 2>/dev/null >/dev/null ; then
 		UNAME_MACHINE=`(uname -p) 2>/dev/null`
-		echo ${UNAME_MACHINE}-sni-sysv4
+		GUESS=$UNAME_MACHINE-sni-sysv4
 	else
-		echo ns32k-sni-sysv
+		GUESS=ns32k-sni-sysv
 	fi
-	exit ;;
-    PENTIUM:*:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
-                      # says <Richard.M.Bartel@ccMail.Census.GOV>
-        echo i586-unisys-sysv4
-        exit ;;
+	;;
+    PENTIUM:*:4.0*:*)	# Unisys 'ClearPath HMP IX 4000' SVR4/MP effort
+			# says <Richard.M.Bartel@ccMail.Census.GOV>
+	GUESS=i586-unisys-sysv4
+	;;
     *:UNIX_System_V:4*:FTX*)
 	# From Gerald Hewes <hewes@openmarket.com>.
 	# How about differentiating between stratus architectures? -djm
-	echo hppa1.1-stratus-sysv4
-	exit ;;
+	GUESS=hppa1.1-stratus-sysv4
+	;;
     *:*:*:FTX*)
 	# From seanf@swdc.stratus.com.
-	echo i860-stratus-sysv4
-	exit ;;
+	GUESS=i860-stratus-sysv4
+	;;
     i*86:VOS:*:*)
 	# From Paul.Green@stratus.com.
-	echo ${UNAME_MACHINE}-stratus-vos
-	exit ;;
+	GUESS=$UNAME_MACHINE-stratus-vos
+	;;
     *:VOS:*:*)
 	# From Paul.Green@stratus.com.
-	echo hppa1.1-stratus-vos
-	exit ;;
+	GUESS=hppa1.1-stratus-vos
+	;;
     mc68*:A/UX:*:*)
-	echo m68k-apple-aux${UNAME_RELEASE}
-	exit ;;
+	GUESS=m68k-apple-aux$UNAME_RELEASE
+	;;
     news*:NEWS-OS:6*:*)
-	echo mips-sony-newsos6
-	exit ;;
+	GUESS=mips-sony-newsos6
+	;;
     R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
-	if [ -d /usr/nec ]; then
-	        echo mips-nec-sysv${UNAME_RELEASE}
+	if test -d /usr/nec; then
+		GUESS=mips-nec-sysv$UNAME_RELEASE
 	else
-	        echo mips-unknown-sysv${UNAME_RELEASE}
+		GUESS=mips-unknown-sysv$UNAME_RELEASE
 	fi
-        exit ;;
+	;;
     BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
-	echo powerpc-be-beos
-	exit ;;
+	GUESS=powerpc-be-beos
+	;;
     BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
-	echo powerpc-apple-beos
-	exit ;;
+	GUESS=powerpc-apple-beos
+	;;
     BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
-	echo i586-pc-beos
-	exit ;;
+	GUESS=i586-pc-beos
+	;;
     BePC:Haiku:*:*)	# Haiku running on Intel PC compatible.
-	echo i586-pc-haiku
-	exit ;;
+	GUESS=i586-pc-haiku
+	;;
+    ppc:Haiku:*:*)	# Haiku running on Apple PowerPC
+	GUESS=powerpc-apple-haiku
+	;;
+    *:Haiku:*:*)	# Haiku modern gcc (not bound by BeOS compat)
+	GUESS=$UNAME_MACHINE-unknown-haiku
+	;;
     SX-4:SUPER-UX:*:*)
-	echo sx4-nec-superux${UNAME_RELEASE}
-	exit ;;
+	GUESS=sx4-nec-superux$UNAME_RELEASE
+	;;
     SX-5:SUPER-UX:*:*)
-	echo sx5-nec-superux${UNAME_RELEASE}
-	exit ;;
+	GUESS=sx5-nec-superux$UNAME_RELEASE
+	;;
     SX-6:SUPER-UX:*:*)
-	echo sx6-nec-superux${UNAME_RELEASE}
-	exit ;;
+	GUESS=sx6-nec-superux$UNAME_RELEASE
+	;;
     SX-7:SUPER-UX:*:*)
-	echo sx7-nec-superux${UNAME_RELEASE}
-	exit ;;
+	GUESS=sx7-nec-superux$UNAME_RELEASE
+	;;
     SX-8:SUPER-UX:*:*)
-	echo sx8-nec-superux${UNAME_RELEASE}
-	exit ;;
+	GUESS=sx8-nec-superux$UNAME_RELEASE
+	;;
     SX-8R:SUPER-UX:*:*)
-	echo sx8r-nec-superux${UNAME_RELEASE}
-	exit ;;
+	GUESS=sx8r-nec-superux$UNAME_RELEASE
+	;;
+    SX-ACE:SUPER-UX:*:*)
+	GUESS=sxace-nec-superux$UNAME_RELEASE
+	;;
     Power*:Rhapsody:*:*)
-	echo powerpc-apple-rhapsody${UNAME_RELEASE}
-	exit ;;
+	GUESS=powerpc-apple-rhapsody$UNAME_RELEASE
+	;;
     *:Rhapsody:*:*)
-	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
-	exit ;;
+	GUESS=$UNAME_MACHINE-apple-rhapsody$UNAME_RELEASE
+	;;
+    arm64:Darwin:*:*)
+	GUESS=aarch64-apple-darwin$UNAME_RELEASE
+	;;
     *:Darwin:*:*)
-	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
+	UNAME_PROCESSOR=`uname -p`
 	case $UNAME_PROCESSOR in
 	    unknown) UNAME_PROCESSOR=powerpc ;;
 	esac
-	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
-	exit ;;
+	if command -v xcode-select > /dev/null 2> /dev/null && \
+		! xcode-select --print-path > /dev/null 2> /dev/null ; then
+	    # Avoid executing cc if there is no toolchain installed as
+	    # cc will be a stub that puts up a graphical alert
+	    # prompting the user to install developer tools.
+	    CC_FOR_BUILD=no_compiler_found
+	else
+	    set_cc_for_build
+	fi
+	if test "$CC_FOR_BUILD" != no_compiler_found; then
+	    if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
+		   (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		   grep IS_64BIT_ARCH >/dev/null
+	    then
+		case $UNAME_PROCESSOR in
+		    i386) UNAME_PROCESSOR=x86_64 ;;
+		    powerpc) UNAME_PROCESSOR=powerpc64 ;;
+		esac
+	    fi
+	    # On 10.4-10.6 one might compile for PowerPC via gcc -arch ppc
+	    if (echo '#ifdef __POWERPC__'; echo IS_PPC; echo '#endif') | \
+		   (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		   grep IS_PPC >/dev/null
+	    then
+		UNAME_PROCESSOR=powerpc
+	    fi
+	elif test "$UNAME_PROCESSOR" = i386 ; then
+	    # uname -m returns i386 or x86_64
+	    UNAME_PROCESSOR=$UNAME_MACHINE
+	fi
+	GUESS=$UNAME_PROCESSOR-apple-darwin$UNAME_RELEASE
+	;;
     *:procnto*:*:* | *:QNX:[0123456789]*:*)
 	UNAME_PROCESSOR=`uname -p`
-	if test "$UNAME_PROCESSOR" = "x86"; then
+	if test "$UNAME_PROCESSOR" = x86; then
 		UNAME_PROCESSOR=i386
 		UNAME_MACHINE=pc
 	fi
-	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
-	exit ;;
+	GUESS=$UNAME_PROCESSOR-$UNAME_MACHINE-nto-qnx$UNAME_RELEASE
+	;;
     *:QNX:*:4*)
-	echo i386-pc-qnx
-	exit ;;
-    NSE-?:NONSTOP_KERNEL:*:*)
-	echo nse-tandem-nsk${UNAME_RELEASE}
-	exit ;;
-    NSR-?:NONSTOP_KERNEL:*:*)
-	echo nsr-tandem-nsk${UNAME_RELEASE}
-	exit ;;
+	GUESS=i386-pc-qnx
+	;;
+    NEO-*:NONSTOP_KERNEL:*:*)
+	GUESS=neo-tandem-nsk$UNAME_RELEASE
+	;;
+    NSE-*:NONSTOP_KERNEL:*:*)
+	GUESS=nse-tandem-nsk$UNAME_RELEASE
+	;;
+    NSR-*:NONSTOP_KERNEL:*:*)
+	GUESS=nsr-tandem-nsk$UNAME_RELEASE
+	;;
+    NSV-*:NONSTOP_KERNEL:*:*)
+	GUESS=nsv-tandem-nsk$UNAME_RELEASE
+	;;
+    NSX-*:NONSTOP_KERNEL:*:*)
+	GUESS=nsx-tandem-nsk$UNAME_RELEASE
+	;;
     *:NonStop-UX:*:*)
-	echo mips-compaq-nonstopux
-	exit ;;
+	GUESS=mips-compaq-nonstopux
+	;;
     BS2000:POSIX*:*:*)
-	echo bs2000-siemens-sysv
-	exit ;;
+	GUESS=bs2000-siemens-sysv
+	;;
     DS/*:UNIX_System_V:*:*)
-	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
-	exit ;;
+	GUESS=$UNAME_MACHINE-$UNAME_SYSTEM-$UNAME_RELEASE
+	;;
     *:Plan9:*:*)
 	# "uname -m" is not consistent, so use $cputype instead. 386
 	# is converted to i386 for consistency with other x86
 	# operating systems.
-	if test "$cputype" = "386"; then
+	if test "${cputype-}" = 386; then
 	    UNAME_MACHINE=i386
-	else
-	    UNAME_MACHINE="$cputype"
+	elif test "x${cputype-}" != x; then
+	    UNAME_MACHINE=$cputype
 	fi
-	echo ${UNAME_MACHINE}-unknown-plan9
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-plan9
+	;;
     *:TOPS-10:*:*)
-	echo pdp10-unknown-tops10
-	exit ;;
+	GUESS=pdp10-unknown-tops10
+	;;
     *:TENEX:*:*)
-	echo pdp10-unknown-tenex
-	exit ;;
+	GUESS=pdp10-unknown-tenex
+	;;
     KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
-	echo pdp10-dec-tops20
-	exit ;;
+	GUESS=pdp10-dec-tops20
+	;;
     XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
-	echo pdp10-xkl-tops20
-	exit ;;
+	GUESS=pdp10-xkl-tops20
+	;;
     *:TOPS-20:*:*)
-	echo pdp10-unknown-tops20
-	exit ;;
+	GUESS=pdp10-unknown-tops20
+	;;
     *:ITS:*:*)
-	echo pdp10-unknown-its
-	exit ;;
+	GUESS=pdp10-unknown-its
+	;;
     SEI:*:*:SEIUX)
-        echo mips-sei-seiux${UNAME_RELEASE}
-	exit ;;
+	GUESS=mips-sei-seiux$UNAME_RELEASE
+	;;
     *:DragonFly:*:*)
-	echo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
-	exit ;;
+	DRAGONFLY_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
+	GUESS=$UNAME_MACHINE-unknown-dragonfly$DRAGONFLY_REL
+	;;
     *:*VMS:*:*)
-    	UNAME_MACHINE=`(uname -p) 2>/dev/null`
-	case "${UNAME_MACHINE}" in
-	    A*) echo alpha-dec-vms ; exit ;;
-	    I*) echo ia64-dec-vms ; exit ;;
-	    V*) echo vax-dec-vms ; exit ;;
+	UNAME_MACHINE=`(uname -p) 2>/dev/null`
+	case $UNAME_MACHINE in
+	    A*) GUESS=alpha-dec-vms ;;
+	    I*) GUESS=ia64-dec-vms ;;
+	    V*) GUESS=vax-dec-vms ;;
 	esac ;;
     *:XENIX:*:SysV)
-	echo i386-pc-xenix
-	exit ;;
+	GUESS=i386-pc-xenix
+	;;
     i*86:skyos:*:*)
-	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
-	exit ;;
+	SKYOS_REL=`echo "$UNAME_RELEASE" | sed -e 's/ .*$//'`
+	GUESS=$UNAME_MACHINE-pc-skyos$SKYOS_REL
+	;;
     i*86:rdos:*:*)
-	echo ${UNAME_MACHINE}-pc-rdos
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-rdos
+	;;
+    i*86:Fiwix:*:*)
+	GUESS=$UNAME_MACHINE-pc-fiwix
+	;;
+    *:AROS:*:*)
+	GUESS=$UNAME_MACHINE-unknown-aros
+	;;
+    x86_64:VMkernel:*:*)
+	GUESS=$UNAME_MACHINE-unknown-esx
+	;;
+    amd64:Isilon\ OneFS:*:*)
+	GUESS=x86_64-unknown-onefs
+	;;
+    *:Unleashed:*:*)
+	GUESS=$UNAME_MACHINE-unknown-unleashed$UNAME_RELEASE
+	;;
+    *:Ironclad:*:*)
+	GUESS=$UNAME_MACHINE-unknown-ironclad
+	;;
 esac
 
-#echo '(No uname command or uname output not recognized.)' 1>&2
-#echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
+# Do we have a guess based on uname results?
+if test "x$GUESS" != x; then
+    echo "$GUESS"
+    exit
+fi
 
-eval $set_cc_for_build
-cat >$dummy.c <<EOF
+# No uname command or uname output not recognized.
+set_cc_for_build
+cat > "$dummy.c" <<EOF
 #ifdef _SEQUENT_
-# include <sys/types.h>
-# include <sys/utsname.h>
+#include <sys/types.h>
+#include <sys/utsname.h>
 #endif
+#if defined(ultrix) || defined(_ultrix) || defined(__ultrix) || defined(__ultrix__)
+#if defined (vax) || defined (__vax) || defined (__vax__) || defined(mips) || defined(__mips) || defined(__mips__) || defined(MIPS) || defined(__MIPS__)
+#include <signal.h>
+#if defined(_SIZE_T_) || defined(SIGLOST)
+#include <sys/utsname.h>
+#endif
+#endif
+#endif
+int
 main ()
 {
 #if defined (sony)
@@ -1362,20 +1635,12 @@
 #include <sys/param.h>
   printf ("m68k-sony-newsos%s\n",
 #ifdef NEWSOS4
-          "4"
+  "4"
 #else
-	  ""
-#endif
-         ); exit (0);
+  ""
 #endif
+  ); exit (0);
 #endif
-
-#if defined (__arm) && defined (__acorn) && defined (__unix)
-  printf ("arm-acorn-riscix\n"); exit (0);
-#endif
-
-#if defined (hp300) && !defined (hpux)
-  printf ("m68k-hp-bsd\n"); exit (0);
 #endif
 
 #if defined (NeXT)
@@ -1417,39 +1682,54 @@
 #endif
 
 #if defined (_SEQUENT_)
-    struct utsname un;
-
-    uname(&un);
-
-    if (strncmp(un.version, "V2", 2) == 0) {
-	printf ("i386-sequent-ptx2\n"); exit (0);
-    }
-    if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
-	printf ("i386-sequent-ptx1\n"); exit (0);
-    }
-    printf ("i386-sequent-ptx\n"); exit (0);
+  struct utsname un;
 
+  uname(&un);
+  if (strncmp(un.version, "V2", 2) == 0) {
+    printf ("i386-sequent-ptx2\n"); exit (0);
+  }
+  if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
+    printf ("i386-sequent-ptx1\n"); exit (0);
+  }
+  printf ("i386-sequent-ptx\n"); exit (0);
 #endif
 
 #if defined (vax)
-# if !defined (ultrix)
-#  include <sys/param.h>
-#  if defined (BSD)
-#   if BSD == 43
-      printf ("vax-dec-bsd4.3\n"); exit (0);
-#   else
-#    if BSD == 199006
-      printf ("vax-dec-bsd4.3reno\n"); exit (0);
-#    else
-      printf ("vax-dec-bsd\n"); exit (0);
-#    endif
-#   endif
-#  else
-    printf ("vax-dec-bsd\n"); exit (0);
-#  endif
-# else
-    printf ("vax-dec-ultrix\n"); exit (0);
-# endif
+#if !defined (ultrix)
+#include <sys/param.h>
+#if defined (BSD)
+#if BSD == 43
+  printf ("vax-dec-bsd4.3\n"); exit (0);
+#else
+#if BSD == 199006
+  printf ("vax-dec-bsd4.3reno\n"); exit (0);
+#else
+  printf ("vax-dec-bsd\n"); exit (0);
+#endif
+#endif
+#else
+  printf ("vax-dec-bsd\n"); exit (0);
+#endif
+#else
+#if defined(_SIZE_T_) || defined(SIGLOST)
+  struct utsname un;
+  uname (&un);
+  printf ("vax-dec-ultrix%s\n", un.release); exit (0);
+#else
+  printf ("vax-dec-ultrix\n"); exit (0);
+#endif
+#endif
+#endif
+#if defined(ultrix) || defined(_ultrix) || defined(__ultrix) || defined(__ultrix__)
+#if defined(mips) || defined(__mips) || defined(__mips__) || defined(MIPS) || defined(__MIPS__)
+#if defined(_SIZE_T_) || defined(SIGLOST)
+  struct utsname *un;
+  uname (&un);
+  printf ("mips-dec-ultrix%s\n", un.release); exit (0);
+#else
+  printf ("mips-dec-ultrix\n"); exit (0);
+#endif
+#endif
 #endif
 
 #if defined (alliant) && defined (i860)
@@ -1460,54 +1740,46 @@
 }
 EOF
 
-$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && SYSTEM_NAME=`$dummy` &&
+$CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null && SYSTEM_NAME=`"$dummy"` &&
 	{ echo "$SYSTEM_NAME"; exit; }
 
 # Apollos put the system type in the environment.
+test -d /usr/apollo && { echo "$ISP-apollo-$SYSTYPE"; exit; }
 
-test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }
+echo "$0: unable to guess system type" >&2
 
-# Convex versions that predate uname can use getsysinfo(1)
+case $UNAME_MACHINE:$UNAME_SYSTEM in
+    mips:Linux | mips64:Linux)
+	# If we got here on MIPS GNU/Linux, output extra information.
+	cat >&2 <<EOF
 
-if [ -x /usr/convex/getsysinfo ]
-then
-    case `getsysinfo -f cpu_type` in
-    c1*)
-	echo c1-convex-bsd
-	exit ;;
-    c2*)
-	if getsysinfo -f scalar_acc
-	then echo c32-convex-bsd
-	else echo c2-convex-bsd
-	fi
-	exit ;;
-    c34*)
-	echo c34-convex-bsd
-	exit ;;
-    c38*)
-	echo c38-convex-bsd
-	exit ;;
-    c4*)
-	echo c4-convex-bsd
-	exit ;;
-    esac
-fi
+NOTE: MIPS GNU/Linux systems require a C compiler to fully recognize
+the system type. Please install a C compiler and try again.
+EOF
+	;;
+esac
 
 cat >&2 <<EOF
-$0: unable to guess system type
 
-This script, last modified $timestamp, has failed to recognize
-the operating system you are using. It is advised that you
-download the most up to date version of the config scripts from
+This script (version $timestamp), has failed to recognize the
+operating system you are using. If your script is old, overwrite *all*
+copies of config.guess and config.sub with the latest versions from:
 
-  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
+  https://git.savannah.gnu.org/cgit/config.git/plain/config.guess
 and
-  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD
+  https://git.savannah.gnu.org/cgit/config.git/plain/config.sub
+EOF
 
-If the version you run ($0) is already up to date, please
-send the following data and any information you think might be
-pertinent to <config-patches@gnu.org> in order to provide the needed
-information to handle your system.
+our_year=`echo $timestamp | sed 's,-.*,,'`
+thisyear=`date +%Y`
+# shellcheck disable=SC2003
+script_age=`expr "$thisyear" - "$our_year"`
+if test "$script_age" -lt 3 ; then
+   cat >&2 <<EOF
+
+If $0 has already been updated, send the following data and any
+information you think might be pertinent to config-patches@gnu.org to
+provide the necessary information to handle your system.
 
 config.guess timestamp = $timestamp
 
@@ -1526,16 +1798,17 @@
 /usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`
 /usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`
 
-UNAME_MACHINE = ${UNAME_MACHINE}
-UNAME_RELEASE = ${UNAME_RELEASE}
-UNAME_SYSTEM  = ${UNAME_SYSTEM}
-UNAME_VERSION = ${UNAME_VERSION}
+UNAME_MACHINE = "$UNAME_MACHINE"
+UNAME_RELEASE = "$UNAME_RELEASE"
+UNAME_SYSTEM  = "$UNAME_SYSTEM"
+UNAME_VERSION = "$UNAME_VERSION"
 EOF
+fi
 
 exit 1
 
 # Local variables:
-# eval: (add-hook 'write-file-hooks 'time-stamp)
+# eval: (add-hook 'before-save-hook 'time-stamp)
 # time-stamp-start: "timestamp='"
 # time-stamp-format: "%:y-%02m-%02d"
 # time-stamp-end: "'"
diff -ru gcc-4.4.0-orig/config.sub gcc-4.4.0/config.sub
--- gcc-4.4.0-orig/config.sub	2008-12-18 03:27:27.000000000 +0000
+++ gcc-4.4.0/config.sub	2024-10-06 08:31:26.930724354 +0100
@@ -1,44 +1,42 @@
 #! /bin/sh
 # Configuration validation subroutine script.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
-#   Free Software Foundation, Inc.
-
-timestamp='2008-12-11'
-
-# This file is (in principle) common to ALL GNU software.
-# The presence of a machine in this file suggests that SOME GNU software
-# can handle that machine.  It does not imply ALL GNU software can.
-#
-# This file is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
+#   Copyright 1992-2024 Free Software Foundation, Inc.
+
+# shellcheck disable=SC2006,SC2268,SC2162 # see below for rationale
+
+timestamp='2024-05-27'
+
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 #
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
-# 02110-1301, USA.
+# along with this program; if not, see <https://www.gnu.org/licenses/>.
 #
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
+# the same distribution terms that you use for the rest of that
+# program.  This Exception is an additional permission under section 7
+# of the GNU General Public License, version 3 ("GPLv3").
 
 
-# Please send patches to <config-patches@gnu.org>.  Submit a context
-# diff and a properly formatted ChangeLog entry.
+# Please send patches to <config-patches@gnu.org>.
 #
 # Configuration subroutine to validate and canonicalize a configuration type.
 # Supply the specified configuration type as an argument.
 # If it is invalid, we print an error message on stderr and exit with code 1.
 # Otherwise, we print the canonical config type on stdout and succeed.
 
+# You can get the latest version of this script from:
+# https://git.savannah.gnu.org/cgit/config.git/plain/config.sub
+
 # This file is supposed to be the same for all GNU packages
 # and recognize all the CPU types, system types and aliases
 # that are meaningful with *any* GNU software.
@@ -54,15 +52,21 @@
 #	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
 # It is wrong to echo any other type of specification.
 
+# The "shellcheck disable" line above the timestamp inhibits complaints
+# about features and limitations of the classic Bourne shell that were
+# superseded or lifted in POSIX.  However, this script identifies a wide
+# variety of pre-POSIX systems that do not have POSIX shells at all, and
+# even some reasonably current systems (Solaris 10 as case-in-point) still
+# have a pre-POSIX /bin/sh.
+
 me=`echo "$0" | sed -e 's,.*/,,'`
 
 usage="\
-Usage: $0 [OPTION] CPU-MFR-OPSYS
-       $0 [OPTION] ALIAS
+Usage: $0 [OPTION] CPU-MFR-OPSYS or ALIAS
 
 Canonicalize a configuration name.
 
-Operation modes:
+Options:
   -h, --help         print this help, then exit
   -t, --time-stamp   print date of last modification, then exit
   -v, --version      print version number, then exit
@@ -72,14 +76,13 @@
 version="\
 GNU config.sub ($timestamp)
 
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
-2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+Copyright 1992-2024 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
 
 help="
-Try \`$me --help' for more information."
+Try '$me --help' for more information."
 
 # Parse command line
 while test $# -gt 0 ; do
@@ -95,12 +98,12 @@
     - )	# Use stdin as input.
        break ;;
     -* )
-       echo "$me: invalid option $1$help"
+       echo "$me: invalid option $1$help" >&2
        exit 1 ;;
 
     *local*)
        # First pass through any local machine types.
-       echo $1
+       echo "$1"
        exit ;;
 
     * )
@@ -116,1111 +119,1375 @@
     exit 1;;
 esac
 
-# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
-# Here we must recognize all the valid KERNEL-OS combinations.
-maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
-case $maybe_os in
-  nto-qnx* | linux-gnu* | linux-dietlibc | linux-newlib* | linux-uclibc* | \
-  uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* | \
-  storm-chaos* | os2-emx* | rtmk-nova*)
-    os=-$maybe_os
-    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
-    ;;
-  *)
-    basic_machine=`echo $1 | sed 's/-[^-]*$//'`
-    if [ $basic_machine != $1 ]
-    then os=`echo $1 | sed 's/.*-/-/'`
-    else os=; fi
-    ;;
-esac
-
-### Let's recognize common machines as not being operating systems so
-### that things like config.sub decstation-3100 work.  We also
-### recognize some manufacturers as not being operating systems, so we
-### can provide default operating systems below.
-case $os in
-	-sun*os*)
-		# Prevent following clause from handling this invalid input.
-		;;
-	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
-	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
-	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
-	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
-	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
-	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
-	-apple | -axis | -knuth | -cray)
-		os=
-		basic_machine=$1
-		;;
-	-sim | -cisco | -oki | -wec | -winbond)
-		os=
-		basic_machine=$1
-		;;
-	-scout)
-		;;
-	-wrs)
-		os=-vxworks
-		basic_machine=$1
-		;;
-	-chorusos*)
-		os=-chorusos
-		basic_machine=$1
-		;;
- 	-chorusrdb)
- 		os=-chorusrdb
-		basic_machine=$1
- 		;;
-	-hiux*)
-		os=-hiuxwe2
-		;;
-	-sco6)
-		os=-sco5v6
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco5)
-		os=-sco3.2v5
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco4)
-		os=-sco3.2v4
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco3.2.[4-9]*)
-		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco3.2v[4-9]*)
-		# Don't forget version if it is 3.2v4 or newer.
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco5v6*)
-		# Don't forget version if it is 3.2v4 or newer.
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco*)
-		os=-sco3.2v2
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-udk*)
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-isc)
-		os=-isc2.2
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-clix*)
-		basic_machine=clipper-intergraph
-		;;
-	-isc*)
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-lynx*)
-		os=-lynxos
+# Split fields of configuration type
+saved_IFS=$IFS
+IFS="-" read field1 field2 field3 field4 <<EOF
+$1
+EOF
+IFS=$saved_IFS
+
+# Separate into logical components for further validation
+case $1 in
+	*-*-*-*-*)
+		echo "Invalid configuration '$1': more than four components" >&2
+		exit 1
 		;;
-	-ptx*)
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`
+	*-*-*-*)
+		basic_machine=$field1-$field2
+		basic_os=$field3-$field4
 		;;
-	-windowsnt*)
-		os=`echo $os | sed -e 's/windowsnt/winnt/'`
+	*-*-*)
+		# Ambiguous whether COMPANY is present, or skipped and KERNEL-OS is two
+		# parts
+		maybe_os=$field2-$field3
+		case $maybe_os in
+			  cloudabi*-eabi* \
+			| kfreebsd*-gnu* \
+			| knetbsd*-gnu* \
+			| kopensolaris*-gnu* \
+			| linux-* \
+			| managarm-* \
+			| netbsd*-eabi* \
+			| netbsd*-gnu* \
+			| nto-qnx* \
+			| os2-emx* \
+			| rtmk-nova* \
+			| storm-chaos* \
+			| uclinux-gnu* \
+			| uclinux-uclibc* \
+			| windows-* )
+				basic_machine=$field1
+				basic_os=$maybe_os
+				;;
+			android-linux)
+				basic_machine=$field1-unknown
+				basic_os=linux-android
+				;;
+			*)
+				basic_machine=$field1-$field2
+				basic_os=$field3
+				;;
+		esac
 		;;
-	-psos*)
-		os=-psos
+	*-*)
+		case $field1-$field2 in
+			# Shorthands that happen to contain a single dash
+			convex-c[12] | convex-c3[248])
+				basic_machine=$field2-convex
+				basic_os=
+				;;
+			decstation-3100)
+				basic_machine=mips-dec
+				basic_os=
+				;;
+			*-*)
+				# Second component is usually, but not always the OS
+				case $field2 in
+					# Do not treat sunos as a manufacturer
+					sun*os*)
+						basic_machine=$field1
+						basic_os=$field2
+						;;
+					# Manufacturers
+					  3100* \
+					| 32* \
+					| 3300* \
+					| 3600* \
+					| 7300* \
+					| acorn \
+					| altos* \
+					| apollo \
+					| apple \
+					| atari \
+					| att* \
+					| axis \
+					| be \
+					| bull \
+					| cbm \
+					| ccur \
+					| cisco \
+					| commodore \
+					| convergent* \
+					| convex* \
+					| cray \
+					| crds \
+					| dec* \
+					| delta* \
+					| dg \
+					| digital \
+					| dolphin \
+					| encore* \
+					| gould \
+					| harris \
+					| highlevel \
+					| hitachi* \
+					| hp \
+					| ibm* \
+					| intergraph \
+					| isi* \
+					| knuth \
+					| masscomp \
+					| microblaze* \
+					| mips* \
+					| motorola* \
+					| ncr* \
+					| news \
+					| next \
+					| ns \
+					| oki \
+					| omron* \
+					| pc533* \
+					| rebel \
+					| rom68k \
+					| rombug \
+					| semi \
+					| sequent* \
+					| siemens \
+					| sgi* \
+					| siemens \
+					| sim \
+					| sni \
+					| sony* \
+					| stratus \
+					| sun \
+					| sun[234]* \
+					| tektronix \
+					| tti* \
+					| ultra \
+					| unicom* \
+					| wec \
+					| winbond \
+					| wrs)
+						basic_machine=$field1-$field2
+						basic_os=
+						;;
+					zephyr*)
+						basic_machine=$field1-unknown
+						basic_os=$field2
+						;;
+					*)
+						basic_machine=$field1
+						basic_os=$field2
+						;;
+				esac
+			;;
+		esac
 		;;
-	-mint | -mint[0-9]*)
-		basic_machine=m68k-atari
-		os=-mint
+	*)
+		# Convert single-component short-hands not valid as part of
+		# multi-component configurations.
+		case $field1 in
+			386bsd)
+				basic_machine=i386-pc
+				basic_os=bsd
+				;;
+			a29khif)
+				basic_machine=a29k-amd
+				basic_os=udi
+				;;
+			adobe68k)
+				basic_machine=m68010-adobe
+				basic_os=scout
+				;;
+			alliant)
+				basic_machine=fx80-alliant
+				basic_os=
+				;;
+			altos | altos3068)
+				basic_machine=m68k-altos
+				basic_os=
+				;;
+			am29k)
+				basic_machine=a29k-none
+				basic_os=bsd
+				;;
+			amdahl)
+				basic_machine=580-amdahl
+				basic_os=sysv
+				;;
+			amiga)
+				basic_machine=m68k-unknown
+				basic_os=
+				;;
+			amigaos | amigados)
+				basic_machine=m68k-unknown
+				basic_os=amigaos
+				;;
+			amigaunix | amix)
+				basic_machine=m68k-unknown
+				basic_os=sysv4
+				;;
+			apollo68)
+				basic_machine=m68k-apollo
+				basic_os=sysv
+				;;
+			apollo68bsd)
+				basic_machine=m68k-apollo
+				basic_os=bsd
+				;;
+			aros)
+				basic_machine=i386-pc
+				basic_os=aros
+				;;
+			aux)
+				basic_machine=m68k-apple
+				basic_os=aux
+				;;
+			balance)
+				basic_machine=ns32k-sequent
+				basic_os=dynix
+				;;
+			blackfin)
+				basic_machine=bfin-unknown
+				basic_os=linux
+				;;
+			cegcc)
+				basic_machine=arm-unknown
+				basic_os=cegcc
+				;;
+			cray)
+				basic_machine=j90-cray
+				basic_os=unicos
+				;;
+			crds | unos)
+				basic_machine=m68k-crds
+				basic_os=
+				;;
+			da30)
+				basic_machine=m68k-da30
+				basic_os=
+				;;
+			decstation | pmax | pmin | dec3100 | decstatn)
+				basic_machine=mips-dec
+				basic_os=
+				;;
+			delta88)
+				basic_machine=m88k-motorola
+				basic_os=sysv3
+				;;
+			dicos)
+				basic_machine=i686-pc
+				basic_os=dicos
+				;;
+			djgpp)
+				basic_machine=i586-pc
+				basic_os=msdosdjgpp
+				;;
+			ebmon29k)
+				basic_machine=a29k-amd
+				basic_os=ebmon
+				;;
+			es1800 | OSE68k | ose68k | ose | OSE)
+				basic_machine=m68k-ericsson
+				basic_os=ose
+				;;
+			gmicro)
+				basic_machine=tron-gmicro
+				basic_os=sysv
+				;;
+			go32)
+				basic_machine=i386-pc
+				basic_os=go32
+				;;
+			h8300hms)
+				basic_machine=h8300-hitachi
+				basic_os=hms
+				;;
+			h8300xray)
+				basic_machine=h8300-hitachi
+				basic_os=xray
+				;;
+			h8500hms)
+				basic_machine=h8500-hitachi
+				basic_os=hms
+				;;
+			harris)
+				basic_machine=m88k-harris
+				basic_os=sysv3
+				;;
+			hp300 | hp300hpux)
+				basic_machine=m68k-hp
+				basic_os=hpux
+				;;
+			hp300bsd)
+				basic_machine=m68k-hp
+				basic_os=bsd
+				;;
+			hppaosf)
+				basic_machine=hppa1.1-hp
+				basic_os=osf
+				;;
+			hppro)
+				basic_machine=hppa1.1-hp
+				basic_os=proelf
+				;;
+			i386mach)
+				basic_machine=i386-mach
+				basic_os=mach
+				;;
+			isi68 | isi)
+				basic_machine=m68k-isi
+				basic_os=sysv
+				;;
+			m68knommu)
+				basic_machine=m68k-unknown
+				basic_os=linux
+				;;
+			magnum | m3230)
+				basic_machine=mips-mips
+				basic_os=sysv
+				;;
+			merlin)
+				basic_machine=ns32k-utek
+				basic_os=sysv
+				;;
+			mingw64)
+				basic_machine=x86_64-pc
+				basic_os=mingw64
+				;;
+			mingw32)
+				basic_machine=i686-pc
+				basic_os=mingw32
+				;;
+			mingw32ce)
+				basic_machine=arm-unknown
+				basic_os=mingw32ce
+				;;
+			monitor)
+				basic_machine=m68k-rom68k
+				basic_os=coff
+				;;
+			morphos)
+				basic_machine=powerpc-unknown
+				basic_os=morphos
+				;;
+			moxiebox)
+				basic_machine=moxie-unknown
+				basic_os=moxiebox
+				;;
+			msdos)
+				basic_machine=i386-pc
+				basic_os=msdos
+				;;
+			msys)
+				basic_machine=i686-pc
+				basic_os=msys
+				;;
+			mvs)
+				basic_machine=i370-ibm
+				basic_os=mvs
+				;;
+			nacl)
+				basic_machine=le32-unknown
+				basic_os=nacl
+				;;
+			ncr3000)
+				basic_machine=i486-ncr
+				basic_os=sysv4
+				;;
+			netbsd386)
+				basic_machine=i386-pc
+				basic_os=netbsd
+				;;
+			netwinder)
+				basic_machine=armv4l-rebel
+				basic_os=linux
+				;;
+			news | news700 | news800 | news900)
+				basic_machine=m68k-sony
+				basic_os=newsos
+				;;
+			news1000)
+				basic_machine=m68030-sony
+				basic_os=newsos
+				;;
+			necv70)
+				basic_machine=v70-nec
+				basic_os=sysv
+				;;
+			nh3000)
+				basic_machine=m68k-harris
+				basic_os=cxux
+				;;
+			nh[45]000)
+				basic_machine=m88k-harris
+				basic_os=cxux
+				;;
+			nindy960)
+				basic_machine=i960-intel
+				basic_os=nindy
+				;;
+			mon960)
+				basic_machine=i960-intel
+				basic_os=mon960
+				;;
+			nonstopux)
+				basic_machine=mips-compaq
+				basic_os=nonstopux
+				;;
+			os400)
+				basic_machine=powerpc-ibm
+				basic_os=os400
+				;;
+			OSE68000 | ose68000)
+				basic_machine=m68000-ericsson
+				basic_os=ose
+				;;
+			os68k)
+				basic_machine=m68k-none
+				basic_os=os68k
+				;;
+			paragon)
+				basic_machine=i860-intel
+				basic_os=osf
+				;;
+			parisc)
+				basic_machine=hppa-unknown
+				basic_os=linux
+				;;
+			psp)
+				basic_machine=mipsallegrexel-sony
+				basic_os=psp
+				;;
+			pw32)
+				basic_machine=i586-unknown
+				basic_os=pw32
+				;;
+			rdos | rdos64)
+				basic_machine=x86_64-pc
+				basic_os=rdos
+				;;
+			rdos32)
+				basic_machine=i386-pc
+				basic_os=rdos
+				;;
+			rom68k)
+				basic_machine=m68k-rom68k
+				basic_os=coff
+				;;
+			sa29200)
+				basic_machine=a29k-amd
+				basic_os=udi
+				;;
+			sei)
+				basic_machine=mips-sei
+				basic_os=seiux
+				;;
+			sequent)
+				basic_machine=i386-sequent
+				basic_os=
+				;;
+			sps7)
+				basic_machine=m68k-bull
+				basic_os=sysv2
+				;;
+			st2000)
+				basic_machine=m68k-tandem
+				basic_os=
+				;;
+			stratus)
+				basic_machine=i860-stratus
+				basic_os=sysv4
+				;;
+			sun2)
+				basic_machine=m68000-sun
+				basic_os=
+				;;
+			sun2os3)
+				basic_machine=m68000-sun
+				basic_os=sunos3
+				;;
+			sun2os4)
+				basic_machine=m68000-sun
+				basic_os=sunos4
+				;;
+			sun3)
+				basic_machine=m68k-sun
+				basic_os=
+				;;
+			sun3os3)
+				basic_machine=m68k-sun
+				basic_os=sunos3
+				;;
+			sun3os4)
+				basic_machine=m68k-sun
+				basic_os=sunos4
+				;;
+			sun4)
+				basic_machine=sparc-sun
+				basic_os=
+				;;
+			sun4os3)
+				basic_machine=sparc-sun
+				basic_os=sunos3
+				;;
+			sun4os4)
+				basic_machine=sparc-sun
+				basic_os=sunos4
+				;;
+			sun4sol2)
+				basic_machine=sparc-sun
+				basic_os=solaris2
+				;;
+			sun386 | sun386i | roadrunner)
+				basic_machine=i386-sun
+				basic_os=
+				;;
+			sv1)
+				basic_machine=sv1-cray
+				basic_os=unicos
+				;;
+			symmetry)
+				basic_machine=i386-sequent
+				basic_os=dynix
+				;;
+			t3e)
+				basic_machine=alphaev5-cray
+				basic_os=unicos
+				;;
+			t90)
+				basic_machine=t90-cray
+				basic_os=unicos
+				;;
+			toad1)
+				basic_machine=pdp10-xkl
+				basic_os=tops20
+				;;
+			tpf)
+				basic_machine=s390x-ibm
+				basic_os=tpf
+				;;
+			udi29k)
+				basic_machine=a29k-amd
+				basic_os=udi
+				;;
+			ultra3)
+				basic_machine=a29k-nyu
+				basic_os=sym1
+				;;
+			v810 | necv810)
+				basic_machine=v810-nec
+				basic_os=none
+				;;
+			vaxv)
+				basic_machine=vax-dec
+				basic_os=sysv
+				;;
+			vms)
+				basic_machine=vax-dec
+				basic_os=vms
+				;;
+			vsta)
+				basic_machine=i386-pc
+				basic_os=vsta
+				;;
+			vxworks960)
+				basic_machine=i960-wrs
+				basic_os=vxworks
+				;;
+			vxworks68)
+				basic_machine=m68k-wrs
+				basic_os=vxworks
+				;;
+			vxworks29k)
+				basic_machine=a29k-wrs
+				basic_os=vxworks
+				;;
+			xbox)
+				basic_machine=i686-pc
+				basic_os=mingw32
+				;;
+			ymp)
+				basic_machine=ymp-cray
+				basic_os=unicos
+				;;
+			*)
+				basic_machine=$1
+				basic_os=
+				;;
+		esac
 		;;
 esac
 
-# Decode aliases for certain CPU-COMPANY combinations.
+# Decode 1-component or ad-hoc basic machines
 case $basic_machine in
-	# Recognize the basic CPU types without company name.
-	# Some are omitted here because they have special meanings below.
-	1750a | 580 \
-	| a29k \
-	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
-	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
-	| am33_2.0 \
-	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr | avr32 \
-	| bfin \
-	| c4x | clipper \
-	| d10v | d30v | dlx | dsp16xx \
-	| fido | fr30 | frv \
-	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
-	| i370 | i860 | i960 | ia64 \
-	| ip2k | iq2000 \
-	| lm32 \
-	| m32c | m32r | m32rle | m68000 | m68k | m88k \
-	| maxq | mb | microblaze | mcore | mep | metag \
-	| mips | mipsbe | mipseb | mipsel | mipsle \
-	| mips16 \
-	| mips64 | mips64el \
-	| mips64octeon | mips64octeonel \
-	| mips64orion | mips64orionel \
-	| mips64r5900 | mips64r5900el \
-	| mips64vr | mips64vrel \
-	| mips64vr4100 | mips64vr4100el \
-	| mips64vr4300 | mips64vr4300el \
-	| mips64vr5000 | mips64vr5000el \
-	| mips64vr5900 | mips64vr5900el \
-	| mipsisa32 | mipsisa32el \
-	| mipsisa32r2 | mipsisa32r2el \
-	| mipsisa64 | mipsisa64el \
-	| mipsisa64r2 | mipsisa64r2el \
-	| mipsisa64sb1 | mipsisa64sb1el \
-	| mipsisa64sr71k | mipsisa64sr71kel \
-	| mipstx39 | mipstx39el \
-	| mn10200 | mn10300 \
-	| mt \
-	| msp430 \
-	| nios | nios2 \
-	| ns16k | ns32k \
-	| or32 \
-	| pdp10 | pdp11 | pj | pjl \
-	| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \
-	| pyramid \
-	| score \
-	| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
-	| sh64 | sh64le \
-	| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \
-	| sparcv8 | sparcv9 | sparcv9b | sparcv9v \
-	| spu | strongarm \
-	| tahoe | thumb | tic4x | tic80 | tron \
-	| v850 | v850e \
-	| we32k \
-	| x86 | xc16x | xscale | xscalee[bl] | xstormy16 | xtensa \
-	| z8k | z80)
-		basic_machine=$basic_machine-unknown
-		;;
-	m6811 | m68hc11 | m6812 | m68hc12)
-		# Motorola 68HC11/12.
-		basic_machine=$basic_machine-unknown
-		os=-none
+	# Here we handle the default manufacturer of certain CPU types.  It is in
+	# some cases the only manufacturer, in others, it is the most popular.
+	w89k)
+		cpu=hppa1.1
+		vendor=winbond
 		;;
-	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)
+	op50n)
+		cpu=hppa1.1
+		vendor=oki
 		;;
-	ms1)
-		basic_machine=mt-unknown
+	op60c)
+		cpu=hppa1.1
+		vendor=oki
 		;;
-
-	# We use `pc' rather than `unknown'
-	# because (1) that's what they normally are, and
-	# (2) the word "unknown" tends to confuse beginning users.
-	i*86 | x86_64)
-	  basic_machine=$basic_machine-pc
-	  ;;
-	# Object if more than one company name word.
-	*-*-*)
-		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
-		exit 1
+	ibm*)
+		cpu=i370
+		vendor=ibm
 		;;
-	# Recognize the basic CPU types with company name.
-	580-* \
-	| a29k-* \
-	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
-	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
-	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
-	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
-	| avr-* | avr32-* \
-	| bfin-* | bs2000-* \
-	| c[123]* | c30-* | [cjt]90-* | c4x-* | c54x-* | c55x-* | c6x-* \
-	| clipper-* | craynv-* | cydra-* \
-	| d10v-* | d30v-* | dlx-* \
-	| elxsi-* \
-	| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \
-	| h8300-* | h8500-* \
-	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
-	| i*86-* | i860-* | i960-* | ia64-* \
-	| ip2k-* | iq2000-* \
-	| lm32-* \
-	| m32c-* | m32r-* | m32rle-* \
-	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
-	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* \
-	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
-	| mips16-* \
-	| mips64-* | mips64el-* \
-	| mips64octeon-* | mips64octeonel-* \
-	| mips64orion-* | mips64orionel-* \
-	| mips64r5900-* | mips64r5900el-* \
-	| mips64vr-* | mips64vrel-* \
-	| mips64vr4100-* | mips64vr4100el-* \
-	| mips64vr4300-* | mips64vr4300el-* \
-	| mips64vr5000-* | mips64vr5000el-* \
-	| mips64vr5900-* | mips64vr5900el-* \
-	| mipsisa32-* | mipsisa32el-* \
-	| mipsisa32r2-* | mipsisa32r2el-* \
-	| mipsisa64-* | mipsisa64el-* \
-	| mipsisa64r2-* | mipsisa64r2el-* \
-	| mipsisa64sb1-* | mipsisa64sb1el-* \
-	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
-	| mipstx39-* | mipstx39el-* \
-	| mmix-* \
-	| mt-* \
-	| msp430-* \
-	| nios-* | nios2-* \
-	| none-* | np1-* | ns16k-* | ns32k-* \
-	| orion-* \
-	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
-	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \
-	| pyramid-* \
-	| romp-* | rs6000-* \
-	| sh-* | sh[1234]-* | sh[24]a-* | sh[24]aeb-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
-	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
-	| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \
-	| sparclite-* \
-	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | strongarm-* | sv1-* | sx?-* \
-	| tahoe-* | thumb-* \
-	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* | tile-* \
-	| tron-* \
-	| v850-* | v850e-* | vax-* \
-	| we32k-* \
-	| x86-* | x86_64-* | xc16x-* | xps100-* | xscale-* | xscalee[bl]-* \
-	| xstormy16-* | xtensa*-* \
-	| ymp-* \
-	| z8k-* | z80-*)
-		;;
-	# Recognize the basic CPU types without company name, with glob match.
-	xtensa*)
-		basic_machine=$basic_machine-unknown
+	orion105)
+		cpu=clipper
+		vendor=highlevel
+		;;
+	mac | mpw | mac-mpw)
+		cpu=m68k
+		vendor=apple
+		;;
+	pmac | pmac-mpw)
+		cpu=powerpc
+		vendor=apple
 		;;
+
 	# Recognize the various machine names and aliases which stand
 	# for a CPU type and a company and sometimes even an OS.
-	386bsd)
-		basic_machine=i386-unknown
-		os=-bsd
-		;;
 	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
-		basic_machine=m68000-att
+		cpu=m68000
+		vendor=att
 		;;
 	3b*)
-		basic_machine=we32k-att
-		;;
-	a29khif)
-		basic_machine=a29k-amd
-		os=-udi
-		;;
-    	abacus)
-		basic_machine=abacus-unknown
-		;;
-	adobe68k)
-		basic_machine=m68010-adobe
-		os=-scout
-		;;
-	alliant | fx80)
-		basic_machine=fx80-alliant
-		;;
-	altos | altos3068)
-		basic_machine=m68k-altos
-		;;
-	am29k)
-		basic_machine=a29k-none
-		os=-bsd
-		;;
-	amd64)
-		basic_machine=x86_64-pc
-		;;
-	amd64-*)
-		basic_machine=x86_64-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	amdahl)
-		basic_machine=580-amdahl
-		os=-sysv
-		;;
-	amiga | amiga-*)
-		basic_machine=m68k-unknown
-		;;
-	amigaos | amigados)
-		basic_machine=m68k-unknown
-		os=-amigaos
-		;;
-	amigaunix | amix)
-		basic_machine=m68k-unknown
-		os=-sysv4
-		;;
-	apollo68)
-		basic_machine=m68k-apollo
-		os=-sysv
-		;;
-	apollo68bsd)
-		basic_machine=m68k-apollo
-		os=-bsd
-		;;
-	aux)
-		basic_machine=m68k-apple
-		os=-aux
-		;;
-	balance)
-		basic_machine=ns32k-sequent
-		os=-dynix
-		;;
-	blackfin)
-		basic_machine=bfin-unknown
-		os=-linux
-		;;
-	blackfin-*)
-		basic_machine=bfin-`echo $basic_machine | sed 's/^[^-]*-//'`
-		os=-linux
-		;;
-	c90)
-		basic_machine=c90-cray
-		os=-unicos
-		;;
-        cegcc)
-		basic_machine=arm-unknown
-		os=-cegcc
-		;;
-	convex-c1)
-		basic_machine=c1-convex
-		os=-bsd
-		;;
-	convex-c2)
-		basic_machine=c2-convex
-		os=-bsd
-		;;
-	convex-c32)
-		basic_machine=c32-convex
-		os=-bsd
-		;;
-	convex-c34)
-		basic_machine=c34-convex
-		os=-bsd
-		;;
-	convex-c38)
-		basic_machine=c38-convex
-		os=-bsd
-		;;
-	cray | j90)
-		basic_machine=j90-cray
-		os=-unicos
-		;;
-	craynv)
-		basic_machine=craynv-cray
-		os=-unicosmp
-		;;
-	cr16)
-		basic_machine=cr16-unknown
-		os=-elf
-		;;
-	crds | unos)
-		basic_machine=m68k-crds
-		;;
-	crisv32 | crisv32-* | etraxfs*)
-		basic_machine=crisv32-axis
-		;;
-	cris | cris-* | etrax*)
-		basic_machine=cris-axis
-		;;
-	crx)
-		basic_machine=crx-unknown
-		os=-elf
+		cpu=we32k
+		vendor=att
 		;;
-	da30 | da30-*)
-		basic_machine=m68k-da30
-		;;
-	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
-		basic_machine=mips-dec
+	bluegene*)
+		cpu=powerpc
+		vendor=ibm
+		basic_os=cnk
 		;;
 	decsystem10* | dec10*)
-		basic_machine=pdp10-dec
-		os=-tops10
+		cpu=pdp10
+		vendor=dec
+		basic_os=tops10
 		;;
 	decsystem20* | dec20*)
-		basic_machine=pdp10-dec
-		os=-tops20
-		;;
-	delta | 3300 | motorola-3300 | motorola-delta \
-	      | 3300-motorola | delta-motorola)
-		basic_machine=m68k-motorola
-		;;
-	delta88)
-		basic_machine=m88k-motorola
-		os=-sysv3
-		;;
-	dicos)
-		basic_machine=i686-pc
-		os=-dicos
-		;;
-	djgpp)
-		basic_machine=i586-pc
-		os=-msdosdjgpp
-		;;
-	dpx20 | dpx20-*)
-		basic_machine=rs6000-bull
-		os=-bosx
-		;;
-	dpx2* | dpx2*-bull)
-		basic_machine=m68k-bull
-		os=-sysv3
-		;;
-	ebmon29k)
-		basic_machine=a29k-amd
-		os=-ebmon
-		;;
-	elxsi)
-		basic_machine=elxsi-elxsi
-		os=-bsd
+		cpu=pdp10
+		vendor=dec
+		basic_os=tops20
+		;;
+	delta | 3300 | delta-motorola | 3300-motorola | motorola-delta | motorola-3300)
+		cpu=m68k
+		vendor=motorola
+		;;
+	# This used to be dpx2*, but that gets the RS6000-based
+	# DPX/20 and the x86-based DPX/2-100 wrong.  See
+	# https://oldskool.silicium.org/stations/bull_dpx20.htm
+	# https://www.feb-patrimoine.com/english/bull_dpx2.htm
+	# https://www.feb-patrimoine.com/english/unix_and_bull.htm
+	dpx2 | dpx2[23]00 | dpx2[23]xx)
+		cpu=m68k
+		vendor=bull
+		;;
+	dpx2100 | dpx21xx)
+		cpu=i386
+		vendor=bull
+		;;
+	dpx20)
+		cpu=rs6000
+		vendor=bull
 		;;
 	encore | umax | mmax)
-		basic_machine=ns32k-encore
+		cpu=ns32k
+		vendor=encore
 		;;
-	es1800 | OSE68k | ose68k | ose | OSE)
-		basic_machine=m68k-ericsson
-		os=-ose
+	elxsi)
+		cpu=elxsi
+		vendor=elxsi
+		basic_os=${basic_os:-bsd}
 		;;
 	fx2800)
-		basic_machine=i860-alliant
+		cpu=i860
+		vendor=alliant
 		;;
 	genix)
-		basic_machine=ns32k-ns
-		;;
-	gmicro)
-		basic_machine=tron-gmicro
-		os=-sysv
-		;;
-	go32)
-		basic_machine=i386-pc
-		os=-go32
+		cpu=ns32k
+		vendor=ns
 		;;
 	h3050r* | hiux*)
-		basic_machine=hppa1.1-hitachi
-		os=-hiuxwe2
-		;;
-	h8300hms)
-		basic_machine=h8300-hitachi
-		os=-hms
-		;;
-	h8300xray)
-		basic_machine=h8300-hitachi
-		os=-xray
-		;;
-	h8500hms)
-		basic_machine=h8500-hitachi
-		os=-hms
-		;;
-	harris)
-		basic_machine=m88k-harris
-		os=-sysv3
-		;;
-	hp300-*)
-		basic_machine=m68k-hp
-		;;
-	hp300bsd)
-		basic_machine=m68k-hp
-		os=-bsd
-		;;
-	hp300hpux)
-		basic_machine=m68k-hp
-		os=-hpux
+		cpu=hppa1.1
+		vendor=hitachi
+		basic_os=hiuxwe2
 		;;
 	hp3k9[0-9][0-9] | hp9[0-9][0-9])
-		basic_machine=hppa1.0-hp
+		cpu=hppa1.0
+		vendor=hp
 		;;
 	hp9k2[0-9][0-9] | hp9k31[0-9])
-		basic_machine=m68000-hp
+		cpu=m68000
+		vendor=hp
 		;;
 	hp9k3[2-9][0-9])
-		basic_machine=m68k-hp
+		cpu=m68k
+		vendor=hp
 		;;
 	hp9k6[0-9][0-9] | hp6[0-9][0-9])
-		basic_machine=hppa1.0-hp
+		cpu=hppa1.0
+		vendor=hp
 		;;
 	hp9k7[0-79][0-9] | hp7[0-79][0-9])
-		basic_machine=hppa1.1-hp
+		cpu=hppa1.1
+		vendor=hp
 		;;
 	hp9k78[0-9] | hp78[0-9])
 		# FIXME: really hppa2.0-hp
-		basic_machine=hppa1.1-hp
+		cpu=hppa1.1
+		vendor=hp
 		;;
 	hp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)
 		# FIXME: really hppa2.0-hp
-		basic_machine=hppa1.1-hp
+		cpu=hppa1.1
+		vendor=hp
 		;;
 	hp9k8[0-9][13679] | hp8[0-9][13679])
-		basic_machine=hppa1.1-hp
+		cpu=hppa1.1
+		vendor=hp
 		;;
 	hp9k8[0-9][0-9] | hp8[0-9][0-9])
-		basic_machine=hppa1.0-hp
-		;;
-	hppa-next)
-		os=-nextstep3
-		;;
-	hppaosf)
-		basic_machine=hppa1.1-hp
-		os=-osf
-		;;
-	hppro)
-		basic_machine=hppa1.1-hp
-		os=-proelf
+		cpu=hppa1.0
+		vendor=hp
 		;;
-	i370-ibm* | ibm*)
-		basic_machine=i370-ibm
-		;;
-# I'm not sure what "Sysv32" means.  Should this be sysv3.2?
 	i*86v32)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
-		os=-sysv32
+		cpu=`echo "$1" | sed -e 's/86.*/86/'`
+		vendor=pc
+		basic_os=sysv32
 		;;
 	i*86v4*)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
-		os=-sysv4
+		cpu=`echo "$1" | sed -e 's/86.*/86/'`
+		vendor=pc
+		basic_os=sysv4
 		;;
 	i*86v)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
-		os=-sysv
+		cpu=`echo "$1" | sed -e 's/86.*/86/'`
+		vendor=pc
+		basic_os=sysv
 		;;
 	i*86sol2)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
-		os=-solaris2
-		;;
-	i386mach)
-		basic_machine=i386-mach
-		os=-mach
-		;;
-	i386-vsta | vsta)
-		basic_machine=i386-unknown
-		os=-vsta
+		cpu=`echo "$1" | sed -e 's/86.*/86/'`
+		vendor=pc
+		basic_os=solaris2
+		;;
+	j90 | j90-cray)
+		cpu=j90
+		vendor=cray
+		basic_os=${basic_os:-unicos}
 		;;
 	iris | iris4d)
-		basic_machine=mips-sgi
-		case $os in
-		    -irix*)
+		cpu=mips
+		vendor=sgi
+		case $basic_os in
+		    irix*)
 			;;
 		    *)
-			os=-irix4
+			basic_os=irix4
 			;;
 		esac
 		;;
-	isi68 | isi)
-		basic_machine=m68k-isi
-		os=-sysv
-		;;
-	m68knommu)
-		basic_machine=m68k-unknown
-		os=-linux
-		;;
-	m68knommu-*)
-		basic_machine=m68k-`echo $basic_machine | sed 's/^[^-]*-//'`
-		os=-linux
-		;;
-	m88k-omron*)
-		basic_machine=m88k-omron
-		;;
-	magnum | m3230)
-		basic_machine=mips-mips
-		os=-sysv
-		;;
-	merlin)
-		basic_machine=ns32k-utek
-		os=-sysv
-		;;
-	mingw32)
-		basic_machine=i386-pc
-		os=-mingw32
-		;;
-	mingw32ce)
-		basic_machine=arm-unknown
-		os=-mingw32ce
-		;;
 	miniframe)
-		basic_machine=m68000-convergent
+		cpu=m68000
+		vendor=convergent
 		;;
-	*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)
-		basic_machine=m68k-atari
-		os=-mint
-		;;
-	mips3*-*)
-		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
-		;;
-	mips3*)
-		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
-		;;
-	monitor)
-		basic_machine=m68k-rom68k
-		os=-coff
-		;;
-	morphos)
-		basic_machine=powerpc-unknown
-		os=-morphos
-		;;
-	msdos)
-		basic_machine=i386-pc
-		os=-msdos
-		;;
-	ms1-*)
-		basic_machine=`echo $basic_machine | sed -e 's/ms1-/mt-/'`
-		;;
-	mvs)
-		basic_machine=i370-ibm
-		os=-mvs
-		;;
-	ncr3000)
-		basic_machine=i486-ncr
-		os=-sysv4
-		;;
-	netbsd386)
-		basic_machine=i386-unknown
-		os=-netbsd
-		;;
-	netwinder)
-		basic_machine=armv4l-rebel
-		os=-linux
-		;;
-	news | news700 | news800 | news900)
-		basic_machine=m68k-sony
-		os=-newsos
-		;;
-	news1000)
-		basic_machine=m68030-sony
-		os=-newsos
+	*mint | mint[0-9]* | *MiNT | *MiNT[0-9]*)
+		cpu=m68k
+		vendor=atari
+		basic_os=mint
 		;;
 	news-3600 | risc-news)
-		basic_machine=mips-sony
-		os=-newsos
-		;;
-	necv70)
-		basic_machine=v70-nec
-		os=-sysv
-		;;
-	next | m*-next )
-		basic_machine=m68k-next
-		case $os in
-		    -nextstep* )
-			;;
-		    -ns2*)
-		      os=-nextstep2
-			;;
-		    *)
-		      os=-nextstep3
-			;;
-		esac
-		;;
-	nh3000)
-		basic_machine=m68k-harris
-		os=-cxux
-		;;
-	nh[45]000)
-		basic_machine=m88k-harris
-		os=-cxux
-		;;
-	nindy960)
-		basic_machine=i960-intel
-		os=-nindy
-		;;
-	mon960)
-		basic_machine=i960-intel
-		os=-mon960
-		;;
-	nonstopux)
-		basic_machine=mips-compaq
-		os=-nonstopux
+		cpu=mips
+		vendor=sony
+		basic_os=newsos
+		;;
+	next | m*-next)
+		cpu=m68k
+		vendor=next
 		;;
 	np1)
-		basic_machine=np1-gould
-		;;
-	nsr-tandem)
-		basic_machine=nsr-tandem
+		cpu=np1
+		vendor=gould
 		;;
 	op50n-* | op60c-*)
-		basic_machine=hppa1.1-oki
-		os=-proelf
-		;;
-	openrisc | openrisc-*)
-		basic_machine=or32-unknown
-		;;
-	os400)
-		basic_machine=powerpc-ibm
-		os=-os400
-		;;
-	OSE68000 | ose68000)
-		basic_machine=m68000-ericsson
-		os=-ose
-		;;
-	os68k)
-		basic_machine=m68k-none
-		os=-os68k
+		cpu=hppa1.1
+		vendor=oki
+		basic_os=proelf
 		;;
 	pa-hitachi)
-		basic_machine=hppa1.1-hitachi
-		os=-hiuxwe2
-		;;
-	paragon)
-		basic_machine=i860-intel
-		os=-osf
-		;;
-	parisc)
-		basic_machine=hppa-unknown
-		os=-linux
-		;;
-	parisc-*)
-		basic_machine=hppa-`echo $basic_machine | sed 's/^[^-]*-//'`
-		os=-linux
+		cpu=hppa1.1
+		vendor=hitachi
+		basic_os=hiuxwe2
 		;;
 	pbd)
-		basic_machine=sparc-tti
+		cpu=sparc
+		vendor=tti
 		;;
 	pbb)
-		basic_machine=m68k-tti
+		cpu=m68k
+		vendor=tti
 		;;
-	pc532 | pc532-*)
-		basic_machine=ns32k-pc532
+	pc532)
+		cpu=ns32k
+		vendor=pc532
 		;;
-	pc98)
-		basic_machine=i386-pc
+	pn)
+		cpu=pn
+		vendor=gould
 		;;
-	pc98-*)
-		basic_machine=i386-`echo $basic_machine | sed 's/^[^-]*-//'`
+	power)
+		cpu=power
+		vendor=ibm
 		;;
-	pentium | p5 | k5 | k6 | nexgen | viac3)
-		basic_machine=i586-pc
+	ps2)
+		cpu=i386
+		vendor=ibm
 		;;
-	pentiumpro | p6 | 6x86 | athlon | athlon_*)
-		basic_machine=i686-pc
+	rm[46]00)
+		cpu=mips
+		vendor=siemens
 		;;
-	pentiumii | pentium2 | pentiumiii | pentium3)
-		basic_machine=i686-pc
+	rtpc | rtpc-*)
+		cpu=romp
+		vendor=ibm
 		;;
-	pentium4)
-		basic_machine=i786-pc
+	sde)
+		cpu=mipsisa32
+		vendor=sde
+		basic_os=${basic_os:-elf}
+		;;
+	simso-wrs)
+		cpu=sparclite
+		vendor=wrs
+		basic_os=vxworks
 		;;
-	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
-		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
+	tower | tower-32)
+		cpu=m68k
+		vendor=ncr
 		;;
-	pentiumpro-* | p6-* | 6x86-* | athlon-*)
-		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
+	vpp*|vx|vx-*)
+		cpu=f301
+		vendor=fujitsu
 		;;
-	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
-		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
+	w65)
+		cpu=w65
+		vendor=wdc
 		;;
-	pentium4-*)
-		basic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`
+	w89k-*)
+		cpu=hppa1.1
+		vendor=winbond
+		basic_os=proelf
 		;;
-	pn)
-		basic_machine=pn-gould
+	none)
+		cpu=none
+		vendor=none
 		;;
-	power)	basic_machine=power-ibm
+	leon|leon[3-9])
+		cpu=sparc
+		vendor=$basic_machine
+		;;
+	leon-*|leon[3-9]-*)
+		cpu=sparc
+		vendor=`echo "$basic_machine" | sed 's/-.*//'`
+		;;
+
+	*-*)
+		saved_IFS=$IFS
+		IFS="-" read cpu vendor <<EOF
+$basic_machine
+EOF
+		IFS=$saved_IFS
 		;;
-	ppc)	basic_machine=powerpc-unknown
+	# We use 'pc' rather than 'unknown'
+	# because (1) that's what they normally are, and
+	# (2) the word "unknown" tends to confuse beginning users.
+	i*86 | x86_64)
+		cpu=$basic_machine
+		vendor=pc
 		;;
-	ppc-*)	basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
+	# These rules are duplicated from below for sake of the special case above;
+	# i.e. things that normalized to x86 arches should also default to "pc"
+	pc98)
+		cpu=i386
+		vendor=pc
 		;;
-	ppcle | powerpclittle | ppc-le | powerpc-little)
-		basic_machine=powerpcle-unknown
+	x64 | amd64)
+		cpu=x86_64
+		vendor=pc
 		;;
-	ppcle-* | powerpclittle-*)
-		basic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`
+	# Recognize the basic CPU types without company name.
+	*)
+		cpu=$basic_machine
+		vendor=unknown
 		;;
-	ppc64)	basic_machine=powerpc64-unknown
+esac
+
+unset -v basic_machine
+
+# Decode basic machines in the full and proper CPU-Company form.
+case $cpu-$vendor in
+	# Here we handle the default manufacturer of certain CPU types in canonical form.
+	# It is in some cases the only manufacturer, in others, it is the most popular.
+	c[12]-convex | c[12]-unknown | c3[248]-convex | c3[248]-unknown)
+		vendor=convex
+		basic_os=${basic_os:-bsd}
 		;;
-	ppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`
+	craynv-unknown)
+		vendor=cray
+		basic_os=${basic_os:-unicosmp}
 		;;
-	ppc64le | powerpc64little | ppc64-le | powerpc64-little)
-		basic_machine=powerpc64le-unknown
+	c90-unknown | c90-cray)
+		vendor=cray
+		basic_os=${basic_os:-unicos}
 		;;
-	ppc64le-* | powerpc64little-*)
-		basic_machine=powerpc64le-`echo $basic_machine | sed 's/^[^-]*-//'`
+	fx80-unknown)
+		vendor=alliant
 		;;
-	ps2)
-		basic_machine=i386-ibm
+	romp-unknown)
+		vendor=ibm
 		;;
-	pw32)
-		basic_machine=i586-unknown
-		os=-pw32
-		;;
-	rdos)
-		basic_machine=i386-pc
-		os=-rdos
-		;;
-	rom68k)
-		basic_machine=m68k-rom68k
-		os=-coff
+	mmix-unknown)
+		vendor=knuth
 		;;
-	rm[46]00)
-		basic_machine=mips-siemens
+	microblaze-unknown | microblazeel-unknown)
+		vendor=xilinx
 		;;
-	rtpc | rtpc-*)
-		basic_machine=romp-ibm
+	rs6000-unknown)
+		vendor=ibm
 		;;
-	s390 | s390-*)
-		basic_machine=s390-ibm
+	vax-unknown)
+		vendor=dec
 		;;
-	s390x | s390x-*)
-		basic_machine=s390x-ibm
+	pdp11-unknown)
+		vendor=dec
 		;;
-	sa29200)
-		basic_machine=a29k-amd
-		os=-udi
+	tms9900-unknown)
+		vendor=ti
 		;;
-	sb1)
-		basic_machine=mipsisa64sb1-unknown
+	we32k-unknown)
+		vendor=att
 		;;
-	sb1el)
-		basic_machine=mipsisa64sb1el-unknown
+	cydra-unknown)
+		vendor=cydrome
 		;;
-	sde)
-		basic_machine=mipsisa32-sde
-		os=-elf
+	i370-ibm*)
+		vendor=ibm
 		;;
-	sei)
-		basic_machine=mips-sei
-		os=-seiux
+	orion-unknown)
+		vendor=highlevel
 		;;
-	sequent)
-		basic_machine=i386-sequent
+	xps-unknown | xps100-unknown)
+		cpu=xps100
+		vendor=honeywell
 		;;
-	sh)
-		basic_machine=sh-hitachi
-		os=-hms
+
+	# Here we normalize CPU types with a missing or matching vendor
+	armh-unknown | armh-alt)
+		cpu=armv7l
+		vendor=alt
+		basic_os=${basic_os:-linux-gnueabihf}
 		;;
-	sh5el)
-		basic_machine=sh5le-unknown
+
+	# Normalized CPU+vendor pairs that imply an OS, if not otherwise specified
+	m68k-isi)
+		basic_os=${basic_os:-sysv}
 		;;
-	sh64)
-		basic_machine=sh64-unknown
+	m68k-sony)
+		basic_os=${basic_os:-newsos}
 		;;
-	sparclite-wrs | simso-wrs)
-		basic_machine=sparclite-wrs
-		os=-vxworks
+	m68k-tektronix)
+		basic_os=${basic_os:-bsd}
 		;;
-	sps7)
-		basic_machine=m68k-bull
-		os=-sysv2
+	m88k-harris)
+		basic_os=${basic_os:-sysv3}
 		;;
-	spur)
-		basic_machine=spur-unknown
+	i386-bull | m68k-bull)
+		basic_os=${basic_os:-sysv3}
 		;;
-	st2000)
-		basic_machine=m68k-tandem
+	rs6000-bull)
+		basic_os=${basic_os:-bosx}
 		;;
-	stratus)
-		basic_machine=i860-stratus
-		os=-sysv4
+	mips-sni)
+		basic_os=${basic_os:-sysv4}
 		;;
-	sun2)
-		basic_machine=m68000-sun
+
+	# Here we normalize CPU types irrespective of the vendor
+	amd64-*)
+		cpu=x86_64
 		;;
-	sun2os3)
-		basic_machine=m68000-sun
-		os=-sunos3
+	blackfin-*)
+		cpu=bfin
+		basic_os=${basic_os:-linux}
 		;;
-	sun2os4)
-		basic_machine=m68000-sun
-		os=-sunos4
+	c54x-*)
+		cpu=tic54x
 		;;
-	sun3os3)
-		basic_machine=m68k-sun
-		os=-sunos3
+	c55x-*)
+		cpu=tic55x
 		;;
-	sun3os4)
-		basic_machine=m68k-sun
-		os=-sunos4
+	c6x-*)
+		cpu=tic6x
 		;;
-	sun4os3)
-		basic_machine=sparc-sun
-		os=-sunos3
+	e500v[12]-*)
+		cpu=powerpc
+		basic_os=${basic_os}"spe"
 		;;
-	sun4os4)
-		basic_machine=sparc-sun
-		os=-sunos4
+	mips3*-*)
+		cpu=mips64
 		;;
-	sun4sol2)
-		basic_machine=sparc-sun
-		os=-solaris2
+	ms1-*)
+		cpu=mt
 		;;
-	sun3 | sun3-*)
-		basic_machine=m68k-sun
+	m68knommu-*)
+		cpu=m68k
+		basic_os=${basic_os:-linux}
 		;;
-	sun4)
-		basic_machine=sparc-sun
+	m9s12z-* | m68hcs12z-* | hcs12z-* | s12z-*)
+		cpu=s12z
 		;;
-	sun386 | sun386i | roadrunner)
-		basic_machine=i386-sun
+	openrisc-*)
+		cpu=or32
 		;;
-	sv1)
-		basic_machine=sv1-cray
-		os=-unicos
+	parisc-*)
+		cpu=hppa
+		basic_os=${basic_os:-linux}
 		;;
-	symmetry)
-		basic_machine=i386-sequent
-		os=-dynix
+	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
+		cpu=i586
 		;;
-	t3e)
-		basic_machine=alphaev5-cray
-		os=-unicos
+	pentiumpro-* | p6-* | 6x86-* | athlon-* | athlon_*-*)
+		cpu=i686
 		;;
-	t90)
-		basic_machine=t90-cray
-		os=-unicos
+	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
+		cpu=i686
 		;;
-	tic54x | c54x*)
-		basic_machine=tic54x-unknown
-		os=-coff
+	pentium4-*)
+		cpu=i786
 		;;
-	tic55x | c55x*)
-		basic_machine=tic55x-unknown
-		os=-coff
+	ppc-* | ppcbe-*)
+		cpu=powerpc
 		;;
-	tic6x | c6x*)
-		basic_machine=tic6x-unknown
-		os=-coff
+	ppcle-* | powerpclittle-*)
+		cpu=powerpcle
 		;;
-	tile*)
-		basic_machine=tile-unknown
-		os=-linux-gnu
+	ppc64-*)
+		cpu=powerpc64
 		;;
-	tx39)
-		basic_machine=mipstx39-unknown
+	ppc64le-* | powerpc64little-*)
+		cpu=powerpc64le
 		;;
-	tx39el)
-		basic_machine=mipstx39el-unknown
+	sb1-*)
+		cpu=mipsisa64sb1
 		;;
-	toad1)
-		basic_machine=pdp10-xkl
-		os=-tops20
+	sb1el-*)
+		cpu=mipsisa64sb1el
 		;;
-	tower | tower-32)
-		basic_machine=m68k-ncr
+	sh5e[lb]-*)
+		cpu=`echo "$cpu" | sed 's/^\(sh.\)e\(.\)$/\1\2e/'`
 		;;
-	tpf)
-		basic_machine=s390x-ibm
-		os=-tpf
-		;;
-	udi29k)
-		basic_machine=a29k-amd
-		os=-udi
-		;;
-	ultra3)
-		basic_machine=a29k-nyu
-		os=-sym1
-		;;
-	v810 | necv810)
-		basic_machine=v810-nec
-		os=-none
-		;;
-	vaxv)
-		basic_machine=vax-dec
-		os=-sysv
-		;;
-	vms)
-		basic_machine=vax-dec
-		os=-vms
+	spur-*)
+		cpu=spur
 		;;
-	vpp*|vx|vx-*)
-		basic_machine=f301-fujitsu
+	strongarm-* | thumb-*)
+		cpu=arm
 		;;
-	vxworks960)
-		basic_machine=i960-wrs
-		os=-vxworks
-		;;
-	vxworks68)
-		basic_machine=m68k-wrs
-		os=-vxworks
-		;;
-	vxworks29k)
-		basic_machine=a29k-wrs
-		os=-vxworks
-		;;
-	w65*)
-		basic_machine=w65-wdc
-		os=-none
+	tx39-*)
+		cpu=mipstx39
 		;;
-	w89k-*)
-		basic_machine=hppa1.1-winbond
-		os=-proelf
+	tx39el-*)
+		cpu=mipstx39el
 		;;
-	xbox)
-		basic_machine=i686-pc
-		os=-mingw32
-		;;
-	xps | xps100)
-		basic_machine=xps100-honeywell
-		;;
-	ymp)
-		basic_machine=ymp-cray
-		os=-unicos
-		;;
-	z8k-*-coff)
-		basic_machine=z8k-unknown
-		os=-sim
-		;;
-	z80-*-coff)
-		basic_machine=z80-unknown
-		os=-sim
+	xscale-* | xscalee[bl]-*)
+		cpu=`echo "$cpu" | sed 's/^xscale/arm/'`
 		;;
-	none)
-		basic_machine=none-none
-		os=-none
+	arm64-* | aarch64le-*)
+		cpu=aarch64
 		;;
 
-# Here we handle the default manufacturer of certain CPU types.  It is in
-# some cases the only manufacturer, in others, it is the most popular.
-	w89k)
-		basic_machine=hppa1.1-winbond
-		;;
-	op50n)
-		basic_machine=hppa1.1-oki
-		;;
-	op60c)
-		basic_machine=hppa1.1-oki
-		;;
-	romp)
-		basic_machine=romp-ibm
-		;;
-	mmix)
-		basic_machine=mmix-knuth
-		;;
-	rs6000)
-		basic_machine=rs6000-ibm
-		;;
-	vax)
-		basic_machine=vax-dec
-		;;
-	pdp10)
-		# there are many clones, so DEC is not a safe bet
-		basic_machine=pdp10-unknown
-		;;
-	pdp11)
-		basic_machine=pdp11-dec
+	# Recognize the canonical CPU Types that limit and/or modify the
+	# company names they are paired with.
+	cr16-*)
+		basic_os=${basic_os:-elf}
 		;;
-	we32k)
-		basic_machine=we32k-att
+	crisv32-* | etraxfs*-*)
+		cpu=crisv32
+		vendor=axis
 		;;
-	sh[1234] | sh[24]a | sh[24]aeb | sh[34]eb | sh[1234]le | sh[23]ele)
-		basic_machine=sh-unknown
+	cris-* | etrax*-*)
+		cpu=cris
+		vendor=axis
 		;;
-	sparc | sparcv8 | sparcv9 | sparcv9b | sparcv9v)
-		basic_machine=sparc-sun
+	crx-*)
+		basic_os=${basic_os:-elf}
 		;;
-	cydra)
-		basic_machine=cydra-cydrome
+	neo-tandem)
+		cpu=neo
+		vendor=tandem
 		;;
-	orion)
-		basic_machine=orion-highlevel
+	nse-tandem)
+		cpu=nse
+		vendor=tandem
 		;;
-	orion105)
-		basic_machine=clipper-highlevel
-		;;
-	mac | mpw | mac-mpw)
-		basic_machine=m68k-apple
+	nsr-tandem)
+		cpu=nsr
+		vendor=tandem
 		;;
-	pmac | pmac-mpw)
-		basic_machine=powerpc-apple
+	nsv-tandem)
+		cpu=nsv
+		vendor=tandem
+		;;
+	nsx-tandem)
+		cpu=nsx
+		vendor=tandem
+		;;
+	mipsallegrexel-sony)
+		cpu=mipsallegrexel
+		vendor=sony
 		;;
-	*-unknown)
-		# Make sure to match an already-canonicalized machine name.
+	tile*-*)
+		basic_os=${basic_os:-linux-gnu}
 		;;
+
 	*)
-		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
-		exit 1
+		# Recognize the canonical CPU types that are allowed with any
+		# company name.
+		case $cpu in
+			  1750a \
+			| 580 \
+			| [cjt]90 \
+			| a29k \
+			| aarch64 \
+			| aarch64_be \
+			| aarch64c \
+			| abacus \
+			| alpha \
+			| alpha64 \
+			| alpha64ev56 \
+			| alpha64ev6[78] \
+			| alpha64ev[4-8] \
+			| alpha64pca5[67] \
+			| alphaev56 \
+			| alphaev6[78] \
+			| alphaev[4-8] \
+			| alphapca5[67] \
+			| am33_2.0 \
+			| amdgcn \
+			| arc \
+			| arc32 \
+			| arc64 \
+			| arceb \
+			| arm \
+			| arm64e \
+			| arm64ec \
+			| arm[lb]e \
+			| arme[lb] \
+			| armv* \
+			| asmjs \
+			| avr \
+			| avr32 \
+			| ba \
+			| be32 \
+			| be64 \
+			| bfin \
+			| bpf \
+			| bs2000 \
+			| c30 \
+			| c4x \
+			| c8051 \
+			| c[123]* \
+			| clipper \
+			| craynv \
+			| csky \
+			| cydra \
+			| d10v \
+			| d30v \
+			| dlx \
+			| dsp16xx \
+			| e2k \
+			| elxsi \
+			| epiphany \
+			| f30[01] \
+			| f700 \
+			| fido \
+			| fr30 \
+			| frv \
+			| ft32 \
+			| fx80 \
+			| h8300 \
+			| h8500 \
+			| hexagon \
+			| hppa \
+			| hppa1.[01] \
+			| hppa2.0 \
+			| hppa2.0[nw] \
+			| hppa64 \
+			| i*86 \
+			| i370 \
+			| i860 \
+			| i960 \
+			| ia16 \
+			| ia64 \
+			| ip2k \
+			| iq2000 \
+			| javascript \
+			| k1om \
+			| kvx \
+			| le32 \
+			| le64 \
+			| lm32 \
+			| loongarch32 \
+			| loongarch64 \
+			| m32c \
+			| m32r \
+			| m32rle \
+			| m5200 \
+			| m68000 \
+			| m680[012346]0 \
+			| m6811 \
+			| m6812 \
+			| m68360 \
+			| m683?2 \
+			| m68hc11 \
+			| m68hc12 \
+			| m68hcs12x \
+			| m68k \
+			| m88110 \
+			| m88k \
+			| maxq \
+			| mb \
+			| mcore \
+			| mep \
+			| metag \
+			| microblaze \
+			| microblazeel \
+			| mips* \
+			| mmix \
+			| mn10200 \
+			| mn10300 \
+			| moxie \
+			| msp430 \
+			| mt \
+			| nanomips* \
+			| nds32 \
+			| nds32be \
+			| nds32le \
+			| nfp \
+			| nios \
+			| nios2 \
+			| nios2eb \
+			| nios2el \
+			| none \
+			| np1 \
+			| ns16k \
+			| ns32k \
+			| nvptx \
+			| open8 \
+			| or1k* \
+			| or32 \
+			| orion \
+			| pdp10 \
+			| pdp11 \
+			| picochip \
+			| pj \
+			| pjl \
+			| pn \
+			| power \
+			| powerpc \
+			| powerpc64 \
+			| powerpc64le \
+			| powerpcle \
+			| powerpcspe \
+			| pru \
+			| pyramid \
+			| riscv \
+			| riscv32 \
+			| riscv32be \
+			| riscv64 \
+			| riscv64be \
+			| rl78 \
+			| romp \
+			| rs6000 \
+			| rx \
+			| s390 \
+			| s390x \
+			| score \
+			| sh \
+			| sh64 \
+			| sh64le \
+			| sh[12345][lb]e \
+			| sh[1234] \
+			| sh[1234]e[lb] \
+			| sh[23]e \
+			| sh[23]ele \
+			| sh[24]a \
+			| sh[24]ae[lb] \
+			| sh[lb]e \
+			| she[lb] \
+			| shl \
+			| sparc \
+			| sparc64 \
+			| sparc64b \
+			| sparc64v \
+			| sparc86x \
+			| sparclet \
+			| sparclite \
+			| sparcv8 \
+			| sparcv9 \
+			| sparcv9b \
+			| sparcv9v \
+			| spu \
+			| sv1 \
+			| sx* \
+			| tahoe \
+			| thumbv7* \
+			| tic30 \
+			| tic4x \
+			| tic54x \
+			| tic55x \
+			| tic6x \
+			| tic80 \
+                        | tms9900 \
+			| tron \
+			| ubicom32 \
+			| v70 \
+			| v810 \
+			| v850 \
+			| v850e \
+			| v850e1 \
+			| v850e2 \
+			| v850e2v3 \
+			| v850es \
+			| vax \
+			| vc4 \
+			| visium \
+			| w65 \
+			| wasm32 \
+			| wasm64 \
+			| we32k \
+			| x86 \
+			| x86_64 \
+			| xc16x \
+			| xgate \
+			| xps100 \
+			| xstormy16 \
+			| xtensa* \
+			| ymp \
+			| z80 \
+			| z8k)
+				;;
+
+			*)
+				echo "Invalid configuration '$1': machine '$cpu-$vendor' not recognized" 1>&2
+				exit 1
+				;;
+		esac
 		;;
 esac
 
 # Here we canonicalize certain aliases for manufacturers.
-case $basic_machine in
-	*-digital*)
-		basic_machine=`echo $basic_machine | sed 's/digital.*/dec/'`
+case $vendor in
+	digital*)
+		vendor=dec
 		;;
-	*-commodore*)
-		basic_machine=`echo $basic_machine | sed 's/commodore.*/cbm/'`
+	commodore*)
+		vendor=cbm
 		;;
 	*)
 		;;
@@ -1228,196 +1495,247 @@
 
 # Decode manufacturer-specific aliases for certain operating systems.
 
-if [ x"$os" != x"" ]
+if test x"$basic_os" != x
 then
+
+# First recognize some ad-hoc cases, or perhaps split kernel-os, or else just
+# set os.
+obj=
+case $basic_os in
+	gnu/linux*)
+		kernel=linux
+		os=`echo "$basic_os" | sed -e 's|gnu/linux|gnu|'`
+		;;
+	os2-emx)
+		kernel=os2
+		os=`echo "$basic_os" | sed -e 's|os2-emx|emx|'`
+		;;
+	nto-qnx*)
+		kernel=nto
+		os=`echo "$basic_os" | sed -e 's|nto-qnx|qnx|'`
+		;;
+	*-*)
+		saved_IFS=$IFS
+		IFS="-" read kernel os <<EOF
+$basic_os
+EOF
+		IFS=$saved_IFS
+		;;
+	# Default OS when just kernel was specified
+	nto*)
+		kernel=nto
+		os=`echo "$basic_os" | sed -e 's|nto|qnx|'`
+		;;
+	linux*)
+		kernel=linux
+		os=`echo "$basic_os" | sed -e 's|linux|gnu|'`
+		;;
+	managarm*)
+		kernel=managarm
+		os=`echo "$basic_os" | sed -e 's|managarm|mlibc|'`
+		;;
+	*)
+		kernel=
+		os=$basic_os
+		;;
+esac
+
+# Now, normalize the OS (knowing we just have one component, it's not a kernel,
+# etc.)
 case $os in
-        # First match some system type aliases
-        # that might get confused with valid system types.
-	# -solaris* is a basic system type, with this one exception.
-	-solaris1 | -solaris1.*)
-		os=`echo $os | sed -e 's|solaris1|sunos4|'`
-		;;
-	-solaris)
-		os=-solaris2
-		;;
-	-svr4*)
-		os=-sysv4
-		;;
-	-unixware*)
-		os=-sysv4.2uw
-		;;
-	-gnu/linux*)
-		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
-		;;
-	# First accept the basic system types.
-	# The portable systems comes first.
-	# Each alternative MUST END IN A *, to match a version number.
-	# -sysv* is not here because it comes later, after sysvr4.
-	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
-	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\
-	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
-	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
-	      | -aos* \
-	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
-	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
-	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
-	      | -openbsd* | -solidbsd* \
-	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
-	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
-	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
-	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
-	      | -chorusos* | -chorusrdb* | -cegcc* \
-	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
-	      | -mingw32* | -linux-gnu* | -linux-newlib* | -linux-uclibc* \
-	      | -uxpv* | -beos* | -mpeix* | -udk* \
-	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
-	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
-	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
-	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
-	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
-	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
-	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops*)
-	# Remember, each alternative MUST END IN *, to match a version number.
-		;;
-	-qnx*)
-		case $basic_machine in
-		    x86-* | i*86-*)
-			;;
-		    *)
-			os=-nto$os
-			;;
-		esac
+	# First match some system type aliases that might get confused
+	# with valid system types.
+	# solaris* is a basic system type, with this one exception.
+	auroraux)
+		os=auroraux
 		;;
-	-nto-qnx*)
+	bluegene*)
+		os=cnk
 		;;
-	-nto*)
-		os=`echo $os | sed -e 's|nto|nto-qnx|'`
+	solaris1 | solaris1.*)
+		os=`echo "$os" | sed -e 's|solaris1|sunos4|'`
 		;;
-	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
-	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* | -haiku* \
-	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
+	solaris)
+		os=solaris2
 		;;
-	-mac*)
-		os=`echo $os | sed -e 's|mac|macos|'`
+	unixware*)
+		os=sysv4.2uw
 		;;
-	-linux-dietlibc)
-		os=-linux-dietlibc
+	# The marketing names for NeXT's operating systems were
+	# NeXTSTEP, NeXTSTEP 2, OpenSTEP 3, OpenSTEP 4.  'openstep' is
+	# mapped to 'openstep3', but 'openstep1' and 'openstep2' are
+	# mapped to 'nextstep' and 'nextstep2', consistent with the
+	# treatment of SunOS/Solaris.
+	ns | ns1 | nextstep | nextstep1 | openstep1)
+		os=nextstep
 		;;
-	-linux*)
-		os=`echo $os | sed -e 's|linux|linux-gnu|'`
+	ns2 | nextstep2 | openstep2)
+		os=nextstep2
 		;;
-	-sunos5*)
-		os=`echo $os | sed -e 's|sunos5|solaris2|'`
+	ns3 | nextstep3 | openstep | openstep3)
+		os=openstep3
 		;;
-	-sunos6*)
-		os=`echo $os | sed -e 's|sunos6|solaris3|'`
+	ns4 | nextstep4 | openstep4)
+		os=openstep4
 		;;
-	-opened*)
-		os=-openedition
+	# es1800 is here to avoid being matched by es* (a different OS)
+	es1800*)
+		os=ose
 		;;
-        -os400*)
-		os=-os400
+	# Some version numbers need modification
+	chorusos*)
+		os=chorusos
 		;;
-	-wince*)
-		os=-wince
+	isc)
+		os=isc2.2
 		;;
-	-osfrose*)
-		os=-osfrose
+	sco6)
+		os=sco5v6
 		;;
-	-osf*)
-		os=-osf
+	sco5)
+		os=sco3.2v5
 		;;
-	-utek*)
-		os=-bsd
+	sco4)
+		os=sco3.2v4
 		;;
-	-dynix*)
-		os=-bsd
+	sco3.2.[4-9]*)
+		os=`echo "$os" | sed -e 's/sco3.2./sco3.2v/'`
 		;;
-	-acis*)
-		os=-aos
+	sco*v* | scout)
+		# Don't match below
 		;;
-	-atheos*)
-		os=-atheos
+	sco*)
+		os=sco3.2v2
 		;;
-	-syllable*)
-		os=-syllable
+	psos*)
+		os=psos
 		;;
-	-386bsd)
-		os=-bsd
+	qnx*)
+		os=qnx
 		;;
-	-ctix* | -uts*)
-		os=-sysv
+	hiux*)
+		os=hiuxwe2
 		;;
-	-nova*)
-		os=-rtmk-nova
+	lynx*178)
+		os=lynxos178
 		;;
-	-ns2 )
-		os=-nextstep2
+	lynx*5)
+		os=lynxos5
 		;;
-	-nsk*)
-		os=-nsk
+	lynxos*)
+		# don't get caught up in next wildcard
 		;;
-	# Preserve the version number of sinix5.
-	-sinix5.*)
-		os=`echo $os | sed -e 's|sinix|sysv|'`
+	lynx*)
+		os=lynxos
+		;;
+	mac[0-9]*)
+		os=`echo "$os" | sed -e 's|mac|macos|'`
+		;;
+	opened*)
+		os=openedition
+		;;
+	os400*)
+		os=os400
+		;;
+	sunos5*)
+		os=`echo "$os" | sed -e 's|sunos5|solaris2|'`
+		;;
+	sunos6*)
+		os=`echo "$os" | sed -e 's|sunos6|solaris3|'`
+		;;
+	wince*)
+		os=wince
+		;;
+	utek*)
+		os=bsd
+		vendor=`echo "$vendor" | sed -e 's|^unknown$|tektronix|'`
+		;;
+	dynix*)
+		os=bsd
 		;;
-	-sinix*)
-		os=-sysv4
+	acis*)
+		os=aos
 		;;
-        -tpf*)
-		os=-tpf
+	atheos*)
+		os=atheos
 		;;
-	-triton*)
-		os=-sysv3
+	syllable*)
+		os=syllable
 		;;
-	-oss*)
-		os=-sysv3
+	386bsd)
+		os=bsd
+		;;
+	ctix*)
+		os=sysv
+		vendor=`echo "$vendor" | sed -e 's|^unknown$|convergent|'`
+		;;
+	uts*)
+		os=sysv
+		;;
+	nova*)
+		kernel=rtmk
+		os=nova
 		;;
-	-svr4)
-		os=-sysv4
+	# Preserve the version number of sinix5.
+	sinix5.*)
+		os=`echo "$os" | sed -e 's|sinix|sysv|'`
+		vendor=`echo "$vendor" | sed -e 's|^unknown$|sni|'`
 		;;
-	-svr3)
-		os=-sysv3
+	sinix*)
+		os=sysv4
+		vendor=`echo "$vendor" | sed -e 's|^unknown$|sni|'`
 		;;
-	-sysvr4)
-		os=-sysv4
+	tpf*)
+		os=tpf
 		;;
-	# This must come after -sysvr4.
-	-sysv*)
+	triton*)
+		os=sysv3
 		;;
-	-ose*)
-		os=-ose
+	oss*)
+		os=sysv3
 		;;
-	-es1800*)
-		os=-ose
+	svr4*)
+		os=sysv4
 		;;
-	-xenix)
-		os=-xenix
+	svr3)
+		os=sysv3
 		;;
-	-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
-		os=-mint
+	sysvr4)
+		os=sysv4
 		;;
-	-aros*)
-		os=-aros
+	ose*)
+		os=ose
 		;;
-	-kaos*)
-		os=-kaos
+	*mint | mint[0-9]* | *MiNT | MiNT[0-9]*)
+		os=mint
 		;;
-	-zvmoe)
-		os=-zvmoe
+	dicos*)
+		os=dicos
 		;;
-	-dicos*)
-		os=-dicos
+	pikeos*)
+		# Until real need of OS specific support for
+		# particular features comes up, bare metal
+		# configurations are quite functional.
+		case $cpu in
+		    arm*)
+			os=eabi
+			;;
+		    *)
+			os=
+			obj=elf
+			;;
+		esac
 		;;
-	-none)
+	aout* | coff* | elf* | pe*)
+		# These are machine code file formats, not OSes
+		obj=$os
+		os=
 		;;
 	*)
-		# Get rid of the `-' at the beginning of $os.
-		os=`echo $os | sed 's/[^-]*-//'`
-		echo Invalid configuration \`$1\': system \`$os\' not recognized 1>&2
-		exit 1
+		# No normalization, but not necessarily accepted, that comes below.
 		;;
 esac
+
 else
 
 # Here we handle the default operating systems that come with various machines.
@@ -1430,249 +1748,613 @@
 # will signal an error saying that MANUFACTURER isn't an operating
 # system, and we'll never get to this point.
 
-case $basic_machine in
-        score-*)
-		os=-elf
+kernel=
+obj=
+case $cpu-$vendor in
+	score-*)
+		os=
+		obj=elf
 		;;
-        spu-*)
-		os=-elf
+	spu-*)
+		os=
+		obj=elf
 		;;
 	*-acorn)
-		os=-riscix1.2
+		os=riscix1.2
 		;;
 	arm*-rebel)
-		os=-linux
+		kernel=linux
+		os=gnu
 		;;
 	arm*-semi)
-		os=-aout
+		os=
+		obj=aout
+		;;
+	c4x-* | tic4x-*)
+		os=
+		obj=coff
+		;;
+	c8051-*)
+		os=
+		obj=elf
 		;;
-        c4x-* | tic4x-*)
-        	os=-coff
+	clipper-intergraph)
+		os=clix
+		;;
+	hexagon-*)
+		os=
+		obj=elf
+		;;
+	tic54x-*)
+		os=
+		obj=coff
+		;;
+	tic55x-*)
+		os=
+		obj=coff
+		;;
+	tic6x-*)
+		os=
+		obj=coff
 		;;
 	# This must come before the *-dec entry.
 	pdp10-*)
-		os=-tops20
+		os=tops20
 		;;
 	pdp11-*)
-		os=-none
+		os=none
+		;;
+	tms9900-*)
+		os=none
 		;;
 	*-dec | vax-*)
-		os=-ultrix4.2
+		os=ultrix4.2
 		;;
 	m68*-apollo)
-		os=-domain
+		os=domain
 		;;
 	i386-sun)
-		os=-sunos4.0.2
+		os=sunos4.0.2
 		;;
 	m68000-sun)
-		os=-sunos3
-		# This also exists in the configure program, but was not the
-		# default.
-		# os=-sunos4
+		os=sunos3
 		;;
 	m68*-cisco)
-		os=-aout
+		os=
+		obj=aout
 		;;
-        mep-*)
-		os=-elf
+	mep-*)
+		os=
+		obj=elf
+		;;
+	# The -sgi and -siemens entries must be before the mips- entry
+	# or we get the wrong os.
+	*-sgi)
+		os=irix
+		;;
+	*-siemens)
+		os=sysv4
 		;;
 	mips*-cisco)
-		os=-elf
+		os=
+		obj=elf
 		;;
-	mips*-*)
-		os=-elf
+	mips*-*|nanomips*-*)
+		os=
+		obj=elf
 		;;
 	or32-*)
-		os=-coff
+		os=
+		obj=coff
 		;;
-	*-tti)	# must be before sparc entry or we get the wrong os.
-		os=-sysv3
+	# This must be before the sparc-* entry or we get the wrong os.
+	*-tti)
+		os=sysv3
 		;;
 	sparc-* | *-sun)
-		os=-sunos4.1.1
+		os=sunos4.1.1
 		;;
-	*-be)
-		os=-beos
+	pru-*)
+		os=
+		obj=elf
 		;;
-	*-haiku)
-		os=-haiku
+	*-be)
+		os=beos
 		;;
 	*-ibm)
-		os=-aix
+		os=aix
 		;;
-    	*-knuth)
-		os=-mmixware
+	*-knuth)
+		os=mmixware
 		;;
 	*-wec)
-		os=-proelf
+		os=proelf
 		;;
 	*-winbond)
-		os=-proelf
+		os=proelf
 		;;
 	*-oki)
-		os=-proelf
+		os=proelf
 		;;
 	*-hp)
-		os=-hpux
+		os=hpux
 		;;
 	*-hitachi)
-		os=-hiux
+		os=hiuxwe2
 		;;
 	i860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)
-		os=-sysv
+		os=sysv
 		;;
 	*-cbm)
-		os=-amigaos
+		os=amigaos
 		;;
 	*-dg)
-		os=-dgux
+		os=dgux
 		;;
 	*-dolphin)
-		os=-sysv3
+		os=sysv3
 		;;
 	m68k-ccur)
-		os=-rtu
+		os=rtu
 		;;
 	m88k-omron*)
-		os=-luna
+		os=luna
 		;;
-	*-next )
-		os=-nextstep
+	*-next)
+		os=nextstep
 		;;
 	*-sequent)
-		os=-ptx
+		os=ptx
 		;;
 	*-crds)
-		os=-unos
+		os=unos
 		;;
 	*-ns)
-		os=-genix
+		os=genix
 		;;
 	i370-*)
-		os=-mvs
-		;;
-	*-next)
-		os=-nextstep3
+		os=mvs
 		;;
 	*-gould)
-		os=-sysv
+		os=sysv
 		;;
 	*-highlevel)
-		os=-bsd
+		os=bsd
 		;;
 	*-encore)
-		os=-bsd
-		;;
-	*-sgi)
-		os=-irix
-		;;
-	*-siemens)
-		os=-sysv4
+		os=bsd
 		;;
 	*-masscomp)
-		os=-rtu
+		os=rtu
 		;;
 	f30[01]-fujitsu | f700-fujitsu)
-		os=-uxpv
+		os=uxpv
 		;;
 	*-rom68k)
-		os=-coff
+		os=
+		obj=coff
 		;;
 	*-*bug)
-		os=-coff
+		os=
+		obj=coff
 		;;
 	*-apple)
-		os=-macos
+		os=macos
 		;;
 	*-atari*)
-		os=-mint
+		os=mint
+		;;
+	*-wrs)
+		os=vxworks
 		;;
 	*)
-		os=-none
+		os=none
 		;;
 esac
+
 fi
 
+# Now, validate our (potentially fixed-up) individual pieces (OS, OBJ).
+
+case $os in
+	# Sometimes we do "kernel-libc", so those need to count as OSes.
+	llvm* | musl* | newlib* | relibc* | uclibc*)
+		;;
+	# Likewise for "kernel-abi"
+	eabi* | gnueabi*)
+		;;
+	# VxWorks passes extra cpu info in the 4th filed.
+	simlinux | simwindows | spe)
+		;;
+	# See `case $cpu-$os` validation below
+	ghcjs)
+		;;
+	# Now accept the basic system types.
+	# Each alternative MUST end in a * to match a version number.
+	  abug \
+	| aix* \
+	| amdhsa* \
+	| amigados* \
+	| amigaos* \
+	| android* \
+	| aof* \
+	| aos* \
+	| aros* \
+	| atheos* \
+	| auroraux* \
+	| aux* \
+	| beos* \
+	| bitrig* \
+	| bme* \
+	| bosx* \
+	| bsd* \
+	| cegcc* \
+	| chorusos* \
+	| chorusrdb* \
+	| clix* \
+	| cloudabi* \
+	| cnk* \
+	| conix* \
+	| cos* \
+	| cxux* \
+	| cygwin* \
+	| darwin* \
+	| dgux* \
+	| dicos* \
+	| dnix* \
+	| domain* \
+	| dragonfly* \
+	| drops* \
+	| ebmon* \
+	| ecoff* \
+	| ekkobsd* \
+	| emscripten* \
+	| emx* \
+	| es* \
+	| fiwix* \
+	| freebsd* \
+	| fuchsia* \
+	| genix* \
+	| genode* \
+	| glidix* \
+	| gnu* \
+	| go32* \
+	| haiku* \
+	| hcos* \
+	| hiux* \
+	| hms* \
+	| hpux* \
+	| ieee* \
+	| interix* \
+	| ios* \
+	| iris* \
+	| irix* \
+	| ironclad* \
+	| isc* \
+	| its* \
+	| l4re* \
+	| libertybsd* \
+	| lites* \
+	| lnews* \
+	| luna* \
+	| lynxos* \
+	| mach* \
+	| macos* \
+	| magic* \
+	| mbr* \
+	| midipix* \
+	| midnightbsd* \
+	| mingw32* \
+	| mingw64* \
+	| minix* \
+	| mint* \
+	| mirbsd* \
+	| mks* \
+	| mlibc* \
+	| mmixware* \
+	| mon960* \
+	| morphos* \
+	| moss* \
+	| moxiebox* \
+	| mpeix* \
+	| mpw* \
+	| msdos* \
+	| msys* \
+	| mvs* \
+	| nacl* \
+	| netbsd* \
+	| netware* \
+	| newsos* \
+	| nextstep* \
+	| nindy* \
+	| nonstopux* \
+	| nova* \
+	| nsk* \
+	| nucleus* \
+	| nx6 \
+	| nx7 \
+	| oabi* \
+	| ohos* \
+	| onefs* \
+	| openbsd* \
+	| openedition* \
+	| openstep* \
+	| os108* \
+	| os2* \
+	| os400* \
+	| os68k* \
+	| os9* \
+	| ose* \
+	| osf* \
+	| oskit* \
+	| osx* \
+	| palmos* \
+	| phoenix* \
+	| plan9* \
+	| powermax* \
+	| powerunix* \
+	| proelf* \
+	| psos* \
+	| psp* \
+	| ptx* \
+	| pw32* \
+	| qnx* \
+	| rdos* \
+	| redox* \
+	| rhapsody* \
+	| riscix* \
+	| riscos* \
+	| rtems* \
+	| rtmk* \
+	| rtu* \
+	| scout* \
+	| secbsd* \
+	| sei* \
+	| serenity* \
+	| sim* \
+	| skyos* \
+	| solaris* \
+	| solidbsd* \
+	| sortix* \
+	| storm-chaos* \
+	| sunos \
+	| sunos[34]* \
+	| superux* \
+	| syllable* \
+	| sym* \
+	| sysv* \
+	| tenex* \
+	| tirtos* \
+	| toppers* \
+	| tops10* \
+	| tops20* \
+	| tpf* \
+	| tvos* \
+	| twizzler* \
+	| uclinux* \
+	| udi* \
+	| udk* \
+	| ultrix* \
+	| unicos* \
+	| uniplus* \
+	| unleashed* \
+	| unos* \
+	| uwin* \
+	| uxpv* \
+	| v88r* \
+	|*vms* \
+	| vos* \
+	| vsta* \
+	| vxsim* \
+	| vxworks* \
+	| wasi* \
+	| watchos* \
+	| wince* \
+	| windiss* \
+	| windows* \
+	| winnt* \
+	| xenix* \
+	| xray* \
+	| zephyr* \
+	| zvmoe* )
+		;;
+	# This one is extra strict with allowed versions
+	sco3.2v2 | sco3.2v[4-9]* | sco5v6*)
+		# Don't forget version if it is 3.2v4 or newer.
+		;;
+	# This refers to builds using the UEFI calling convention
+	# (which depends on the architecture) and PE file format.
+	# Note that this is both a different calling convention and
+	# different file format than that of GNU-EFI
+	# (x86_64-w64-mingw32).
+	uefi)
+		;;
+	none)
+		;;
+	kernel* | msvc* )
+		# Restricted further below
+		;;
+	'')
+		if test x"$obj" = x
+		then
+			echo "Invalid configuration '$1': Blank OS only allowed with explicit machine code file format" 1>&2
+		fi
+		;;
+	*)
+		echo "Invalid configuration '$1': OS '$os' not recognized" 1>&2
+		exit 1
+		;;
+esac
+
+case $obj in
+	aout* | coff* | elf* | pe*)
+		;;
+	'')
+		# empty is fine
+		;;
+	*)
+		echo "Invalid configuration '$1': Machine code format '$obj' not recognized" 1>&2
+		exit 1
+		;;
+esac
+
+# Here we handle the constraint that a (synthetic) cpu and os are
+# valid only in combination with each other and nowhere else.
+case $cpu-$os in
+	# The "javascript-unknown-ghcjs" triple is used by GHC; we
+	# accept it here in order to tolerate that, but reject any
+	# variations.
+	javascript-ghcjs)
+		;;
+	javascript-* | *-ghcjs)
+		echo "Invalid configuration '$1': cpu '$cpu' is not valid with os '$os$obj'" 1>&2
+		exit 1
+		;;
+esac
+
+# As a final step for OS-related things, validate the OS-kernel combination
+# (given a valid OS), if there is a kernel.
+case $kernel-$os-$obj in
+	linux-gnu*- | linux-android*- | linux-dietlibc*- | linux-llvm*- \
+		    | linux-mlibc*- | linux-musl*- | linux-newlib*- \
+		    | linux-relibc*- | linux-uclibc*- | linux-ohos*- )
+		;;
+	uclinux-uclibc*- | uclinux-gnu*- )
+		;;
+	managarm-mlibc*- | managarm-kernel*- )
+		;;
+	windows*-msvc*-)
+		;;
+	-dietlibc*- | -llvm*- | -mlibc*- | -musl*- | -newlib*- | -relibc*- \
+		    | -uclibc*- )
+		# These are just libc implementations, not actual OSes, and thus
+		# require a kernel.
+		echo "Invalid configuration '$1': libc '$os' needs explicit kernel." 1>&2
+		exit 1
+		;;
+	-kernel*- )
+		echo "Invalid configuration '$1': '$os' needs explicit kernel." 1>&2
+		exit 1
+		;;
+	*-kernel*- )
+		echo "Invalid configuration '$1': '$kernel' does not support '$os'." 1>&2
+		exit 1
+		;;
+	*-msvc*- )
+		echo "Invalid configuration '$1': '$os' needs 'windows'." 1>&2
+		exit 1
+		;;
+	kfreebsd*-gnu*- | knetbsd*-gnu*- | netbsd*-gnu*- | kopensolaris*-gnu*-)
+		;;
+	vxworks-simlinux- | vxworks-simwindows- | vxworks-spe-)
+		;;
+	nto-qnx*-)
+		;;
+	os2-emx-)
+		;;
+	rtmk-nova-)
+		;;
+	*-eabi*- | *-gnueabi*-)
+		;;
+	none--*)
+		# None (no kernel, i.e. freestanding / bare metal),
+		# can be paired with an machine code file format
+		;;
+	-*-)
+		# Blank kernel with real OS is always fine.
+		;;
+	--*)
+		# Blank kernel and OS with real machine code file format is always fine.
+		;;
+	*-*-*)
+		echo "Invalid configuration '$1': Kernel '$kernel' not known to work with OS '$os'." 1>&2
+		exit 1
+		;;
+esac
+
 # Here we handle the case where we know the os, and the CPU type, but not the
 # manufacturer.  We pick the logical manufacturer.
-vendor=unknown
-case $basic_machine in
-	*-unknown)
-		case $os in
-			-riscix*)
+case $vendor in
+	unknown)
+		case $cpu-$os in
+			*-riscix*)
 				vendor=acorn
 				;;
-			-sunos*)
+			*-sunos* | *-solaris*)
 				vendor=sun
 				;;
-			-aix*)
+			*-cnk* | *-aix*)
 				vendor=ibm
 				;;
-			-beos*)
+			*-beos*)
 				vendor=be
 				;;
-			-hpux*)
+			*-hpux*)
 				vendor=hp
 				;;
-			-mpeix*)
+			*-mpeix*)
 				vendor=hp
 				;;
-			-hiux*)
+			*-hiux*)
 				vendor=hitachi
 				;;
-			-unos*)
+			*-unos*)
 				vendor=crds
 				;;
-			-dgux*)
+			*-dgux*)
 				vendor=dg
 				;;
-			-luna*)
+			*-luna*)
 				vendor=omron
 				;;
-			-genix*)
+			*-genix*)
 				vendor=ns
 				;;
-			-mvs* | -opened*)
+			*-clix*)
+				vendor=intergraph
+				;;
+			*-mvs* | *-opened*)
+				vendor=ibm
+				;;
+			*-os400*)
 				vendor=ibm
 				;;
-			-os400*)
+			s390-* | s390x-*)
 				vendor=ibm
 				;;
-			-ptx*)
+			*-ptx*)
 				vendor=sequent
 				;;
-			-tpf*)
+			*-tpf*)
 				vendor=ibm
 				;;
-			-vxsim* | -vxworks* | -windiss*)
+			*-vxsim* | *-vxworks* | *-windiss*)
 				vendor=wrs
 				;;
-			-aux*)
+			*-aux*)
 				vendor=apple
 				;;
-			-hms*)
+			*-hms*)
 				vendor=hitachi
 				;;
-			-mpw* | -macos*)
+			*-mpw* | *-macos*)
 				vendor=apple
 				;;
-			-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
+			*-*mint | *-mint[0-9]* | *-*MiNT | *-MiNT[0-9]*)
 				vendor=atari
 				;;
-			-vos*)
+			*-vos*)
 				vendor=stratus
 				;;
 		esac
-		basic_machine=`echo $basic_machine | sed "s/unknown/$vendor/"`
 		;;
 esac
 
-echo $basic_machine$os
+echo "$cpu-$vendor${kernel:+-$kernel}${os:+-$os}${obj:+-$obj}"
 exit
 
 # Local variables:
-# eval: (add-hook 'write-file-hooks 'time-stamp)
+# eval: (add-hook 'before-save-hook 'time-stamp)
 # time-stamp-start: "timestamp='"
 # time-stamp-format: "%:y-%02m-%02d"
 # time-stamp-end: "'"
diff -ru gcc-4.4.0-orig/gcc/c-cppbuiltin.c gcc-4.4.0/gcc/c-cppbuiltin.c
--- gcc-4.4.0-orig/gcc/c-cppbuiltin.c	2009-01-18 16:26:26.000000000 +0000
+++ gcc-4.4.0/gcc/c-cppbuiltin.c	2024-10-05 07:13:03.922412536 +0100
@@ -104,12 +104,27 @@
   int decimal_dig;
 
   fmt = REAL_MODE_FORMAT (TYPE_MODE (type));
+
+/*  MGB don't assert if building for TMS9900.  We want to use radix-10
+ *  representations internally. */
+#ifndef TMS9900
   gcc_assert (fmt->b != 10);
+#endif
 
   /* The radix of the exponent representation.  */
   if (type == float_type_node)
     builtin_define_with_int_value ("__FLT_RADIX__", fmt->b);
-  log10_b = log10_2;
+
+/*  MGB if building for TMS9900 then radix may be 10.  If it isn't, then the log
+ *  value is 1 since we want no conversion of the exponent. */
+  if (fmt->b == 10)
+  {
+    log10_b = 1;
+  }
+  else
+  {
+    log10_b = log10_2;
+  }
 
   /* The number of radix digits, p, in the floating-point significand.  */
   sprintf (name, "__%s_MANT_DIG__", name_prefix);
@@ -614,6 +629,13 @@
 
   /* Misc.  */
   builtin_define_with_value ("__VERSION__", version_string, 1);
+#ifdef TMS9900
+  char major[10];
+  char *minor = strchr(revision_string, '.');
+  sprintf (major, "%d", atoi (revision_string));
+  builtin_define_with_value ("__TMS9900_PATCH_MAJOR__", major, 0);
+  builtin_define_with_value ("__TMS9900_PATCH_MINOR__", minor+1, 0);
+#endif
 
   if (flag_gnu89_inline)
     cpp_define (pfile, "__GNUC_GNU_INLINE__");
diff -ru gcc-4.4.0-orig/gcc/combine.c gcc-4.4.0/gcc/combine.c
--- gcc-4.4.0-orig/gcc/combine.c	2009-04-01 21:47:37.000000000 +0100
+++ gcc-4.4.0/gcc/combine.c	2024-10-06 08:31:26.962724143 +0100
@@ -672,9 +672,29 @@
       && GET_CODE (newval) == CONST_INT)
     {
       /* Sanity check that we're replacing oldval with a CONST_INT
-	 that is a valid sign-extension for the original mode.  */
+	 that is a valid sign-extension for the original mode. */
+
+      /*  MGB: There is a false assert for TMS9900 if converting an int to a void.
+       *  trunc_int_for_mode() returns 0xffffffff but INTVAL() is 0xffff.
+       *  Disable the assert unless this is not the case */
+      if (GET_MODE(oldval) != HImode || INTVAL(newval) != 0xffff)
+      {
+      if (INTVAL(newval)!=trunc_int_for_mode(INTVAL (newval), GET_MODE (oldval)))
+      {
+          printf ("MGB old=%s(%d) new=%s(%d)\n",
+            GET_MODE_NAME(GET_MODE(oldval)),
+            GET_MODE_BITSIZE(GET_MODE(oldval)),
+            GET_MODE_NAME(GET_MODE(newval)),
+            GET_MODE_BITSIZE(GET_MODE(newval)));
+
+          printf ("MGB i(new)=%x t(new,old)=%x\n",
+              INTVAL(newval),
+              trunc_int_for_mode(INTVAL (newval), GET_MODE (oldval)));
+      }
+
       gcc_assert (INTVAL (newval)
-		  == trunc_int_for_mode (INTVAL (newval), GET_MODE (oldval)));
+                == trunc_int_for_mode (INTVAL (newval), GET_MODE (oldval)));
+      }
 
       /* Replacing the operand of a SUBREG or a ZERO_EXTEND with a
 	 CONST_INT is not valid, because after the replacement, the
@@ -1381,6 +1401,7 @@
           && uns1 == uns3
 	  && (mode1 == mode2 || strictly_local))
         {
+          // printf("MGB elim extend mode=%s\n", GET_MODE_NAME(mode4));
 	  /* Record that the value was promoted from mode1 to mode3,
 	     so that any sign extension at the head of the current
 	     function may be eliminated.  */
@@ -4466,6 +4487,7 @@
 		    return gen_rtx_CLOBBER (VOIDmode, const0_rtx);
 #endif
 
+
 		  new_rtx = (unique_copy && n_occurrences ? copy_rtx (to) : to);
 		  n_occurrences++;
 		}
@@ -6147,7 +6169,10 @@
 	  && GET_MODE_BITSIZE (GET_MODE (x)) <= HOST_BITS_PER_WIDE_INT
 	  && (nonzero_bits (SUBREG_REG (XEXP (x, 0)), GET_MODE (x))
 	      & ~GET_MODE_MASK (GET_MODE (XEXP (x, 0)))) == 0)
+        {
+        // printf ("MGB reduce ext(subr)\n");
 	return SUBREG_REG (XEXP (x, 0));
+        }
 
       /* (zero_extend:DI (truncate:SI foo:DI)) is just foo:DI when foo
 	 is a comparison and STORE_FLAG_VALUE permits.  This is like
@@ -9934,7 +9959,7 @@
 	 generate a paradoxical subreg instead.  That will force a reload
 	 of the original memref X.  */
       if (isize < osize)
-	return gen_rtx_SUBREG (omode, x, 0);
+        return gen_rtx_SUBREG (omode, x, 0);
 
       if (WORDS_BIG_ENDIAN)
 	offset = MAX (isize, UNITS_PER_WORD) - MAX (osize, UNITS_PER_WORD);
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/atof.c gcc-4.4.0/gcc/config/tms9900/atof.c
--- gcc-4.4.0-orig/gcc/config/tms9900/atof.c	2024-10-05 07:13:03.766413632 +0100
+++ gcc-4.4.0/gcc/config/tms9900/atof.c	2024-10-05 07:13:03.998412002 +0100
@@ -0,0 +1,142 @@
+/* atof.c
+   This method converts an ascii representation of a float to a float.
+   change log:
+   06/23/2023 mrvan initial version
+*/
+
+// #include <stdlib.h>
+// #include <ctype.h>
+// #include <string_ext.h>
+#define isdigit(s) ((s>='0')&&(s<='9'))
+
+// converts an ascii representation of a float to a float
+void tireal_atof (const char *a, unsigned char *result) {
+
+   // The TI-99/4A uses RADIX-100 for doubles. RADIX is also known as base. So the doubles are 
+   // stored in base 100. Doubles are stored as 8 bytes, where the number is in scientific notation,
+   // but again as radix 100:
+   // - The first byte is the exponent (a radix 100 exponent, not base 10 exponent).
+   // - Subsequent bytes store the mantissa. The decimal point is after the first mantissa digit.
+   // - Negative numbers are stored with the exponent and first digit negated.
+   // - Zero has an exponent and first digit set to 0 and 0, respectively.
+   // - Exponents are offset by 0x40.
+   // - Note that there are excellent explanations online, but even those have some incorrect info.
+   // - https://www.unige.ch/medecine/nouspikel/ti99/reals.htm
+   // - For instance, one example gets the matissa correct but the author inadvertantly used base
+   // - 10 for the exponent, rather than base 100.
+
+   char *s = (char *) a;
+   char * pd = (char *) result; // pointer to the return value
+
+   // staging values for final double value
+   int exp     = 0;                                            // base 100 exponent
+   int neg_pos = 1;                                            // pos = 1, neg = -1
+   int v[14]   = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // represented as base 10 later to be compbined as base 100
+   int pos     = 0;                                            // write pos in v[]
+   int dp      = 0;                                            // decimal point position relative to v[]
+
+   int b10_exp_neg_pos = 1;
+   int b10_exp = 0;
+   int b10_exp_have_digit = 0;
+
+   int n;
+   int have_pos_digit = 0;
+   int i;
+
+   // skip whitespace
+   // s = skip_whitespace (s);
+
+   // capture the negative sign if present
+   if (*s == '-') {
+      neg_pos = -1;
+      s++;
+   }
+
+   // run through the digits before any decimal point
+   while ( (*s) && (isdigit (*s)) && (pos < 14) ) {
+      n = *s;
+      n -= 48;
+      if (n >= 1) have_pos_digit = 1;
+      if (have_pos_digit) {
+         v[pos] = n;
+         pos++;
+      } 
+      s++;
+   }
+
+   // capture the decimal point position, even if implicit due to lack of one
+   if (*s == '.') {
+      s++;
+   }
+   dp = pos;
+
+   // run through the fractional digits before any exponent designation
+   while ( (*s) && (isdigit (*s)) && (pos < 14) ) {
+      n = *s;
+      n = n - '0'; 
+      if (n >= 1) have_pos_digit = 1;
+      if (have_pos_digit) {
+         v[pos] = n;
+         pos++;
+      } else {
+         dp--;
+      }
+      s++;
+   }
+
+   // handle specified exponent
+   if ( (*s == 'e') || (*s == 'E') ) {
+      s++;
+      if (*s == '-') {
+         b10_exp_neg_pos = -1;
+         s++;
+      }
+      while ( (*s) && (isdigit (*s)) ) {
+         if (b10_exp_have_digit) {
+            b10_exp *= 10;
+         }
+         n = *s;
+         b10_exp += n - '0';
+         b10_exp_have_digit = 1;
+         s++;
+      }
+      dp += b10_exp * b10_exp_neg_pos;
+   }
+   
+   // process the collected value if at least one positive digit was found, otherwise the value is zero
+   if (have_pos_digit) {
+      // calculate the exponent, which is base 100
+      exp = 0x3F + dp / 2;
+      if ( (dp > 0) && (dp % 2) ) exp++;
+   
+      // shift the base 10 digits right by one if not exp aligned for base 100
+      if (dp % 2) {
+         for (i = 13; i > 0; i--) {
+            v[i] = v[i - 1];
+         }
+         v[0] = 0;
+      }
+   }
+
+   // finally, convert the collected and processed value into a double
+
+   // generate the exponent, write and advance. Note that this is a base 100 exponent
+   if (neg_pos == -1) exp++;
+   n = exp * neg_pos;
+   *pd = n;
+   pd++;
+
+   // generate the first mantissa digit, that might need to be negated, write and advance
+   n = (v[0] * 10 + v[1]) * neg_pos; // base 100 generated by combining the v[0] and v[1] values
+   *pd = n;
+   pd++;
+   
+   // process and write the remaining base 100 digits, combining the adjacent base 10 digits
+   for (i = 2; i < 14; i += 2) {
+      n = v[i] * 10 + v[i + 1];
+      *pd = n;
+      pd++;
+   }
+
+   // return d;
+}
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/d_adj_neg_pos.c gcc-4.4.0/gcc/config/tms9900/d_adj_neg_pos.c
--- gcc-4.4.0-orig/gcc/config/tms9900/d_adj_neg_pos.c	2024-10-05 07:13:03.770413605 +0100
+++ gcc-4.4.0/gcc/config/tms9900/d_adj_neg_pos.c	2024-10-05 07:13:04.006411945 +0100
@@ -0,0 +1,18 @@
+/* d_adj_neg_pos.c
+   This method performs absolute value on the incoming double and indicates whether it was positive or negative.
+   06/23/2023 mrvan initial version
+*/
+
+#include "math_private.h"
+
+int d_adj_neg_pos (double *d) {
+   char *p = (char *) d;
+   int np = 1;
+   if (*p < 0) {
+      *p = -(*p) - 1;
+      np = -1;
+      p++;
+      *p = -(*p);
+   }
+   return np;
+}
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/d_compare.c gcc-4.4.0/gcc/config/tms9900/d_compare.c
--- gcc-4.4.0-orig/gcc/config/tms9900/d_compare.c	2024-10-05 07:13:03.770413605 +0100
+++ gcc-4.4.0/gcc/config/tms9900/d_compare.c	2024-10-05 07:13:04.014411889 +0100
@@ -0,0 +1,47 @@
+/* 06/23/2023 mrvan initial version
+*/
+#include "math_private.h"
+
+// returns a value less than zero if a is strictly less than b, 0 if equal, 1 if a is strictly greater than b
+int d_compare (double a, double b) { // , int lt_response, int gt_response, int eq_response) {
+   int npa = 1;
+   int npb = 1;           
+   char *pa, *pb;
+   int r;
+   int i;
+
+   npa = d_adj_neg_pos (&a);
+   npb = d_adj_neg_pos (&b);
+   
+   if (npa < npb) {
+      // r = lt_response;
+      r = -1;
+   } else if (npa > npb) {
+      // r = gt_response;
+      r = 1;
+   } else {
+      pa = (char *) &a;
+      pb = (char *) &b;
+      // r = eq_response;
+      r = 0;
+      for (i = 0; i < 8; i++) {
+         // first test if they are unequal and if so determine how so, otherwise move on.
+         // one comparison if equal, 1-2 if not.
+         if (!(*pa == *pb)) {
+            if (*pa < *pb) {
+               // r = lt_response;
+               r = -1;
+               break;
+            } else if (*pa > *pb) {
+               // r = gt_response;
+               r = 1;
+               break;
+            }
+         }
+         pa++;
+         pb++;
+      }
+   }
+
+   return r;
+}
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/double.c gcc-4.4.0/gcc/config/tms9900/double.c
--- gcc-4.4.0-orig/gcc/config/tms9900/double.c	2024-10-05 07:13:03.774413576 +0100
+++ gcc-4.4.0/gcc/config/tms9900/double.c	2024-10-06 08:31:26.970724091 +0100
@@ -0,0 +1,98 @@
+/* double.c
+   This file includes double math functions that the GCC compiler requires.
+   06/23/2023 mrvan initial version
+   08/14/2023 mrvan removed methods not associated with the FAC and ARG to separate files
+*/
+
+#define FAC 0x834A
+#define ARG 0x835C
+#define FAC_PTR ((volatile double*)FAC)
+#define ARG_PTR ((volatile double*)ARG)
+
+#define FADD_AUGEND FAC_PTR
+#define FADD_ADDEND ARG_PTR
+#define FADD_SUM    FAC_PTR
+
+#define FSUB_MINUEND    ARG_PTR
+#define FSUB_SUBTRAHEND FAC_PTR
+#define FSUB_DIFFERENCE FAC_PTR
+
+#define FMUL_MULTIPLICAND ARG_PTR
+#define FMUL_MULTIPLIER   FAC_PTR
+#define FMUL_PRODUCT      FAC_PTR
+
+#define FDIV_DIVIDEND FAC_PTR
+#define FDIV_DIVISOR  ARG_PTR
+#define FDIV_QUOTIENT FAC_PTR
+
+// double addition -- method normally included in GCC lib
+double __adddf3 (double a, double b) {
+
+   // use the ti99's ROM method
+
+   // adds a and b
+   *FADD_AUGEND = a;
+   *FADD_ADDEND = b;
+
+  __asm__(
+    "lwpi >83E0\n\t"
+    "bl @>0D80\n\t"
+    "lwpi >83A0\n\t"
+  );
+
+  return *FADD_SUM;
+}
+
+// double subtraction -- method normally included in GCC lib
+double __subdf3 (double a, double b) {
+
+   // use the ti99's ROM method
+
+   // subtract b from a
+   *FSUB_MINUEND    = a;
+   *FSUB_SUBTRAHEND = b;
+
+  __asm__(
+    "lwpi >83E0\n\t"
+    "bl @>0D7C\n\t"
+    "lwpi >83A0\n\t"
+  );
+
+  return *FSUB_DIFFERENCE;
+}
+
+// double multiplication -- method normally included in GCC lib
+double __muldf3 (double a, double b) {
+
+   // use the ti99's ROM method
+
+   // multiply a and b
+   *FMUL_MULTIPLICAND = a;
+   *FMUL_MULTIPLIER   = b;
+
+  __asm__(
+    "lwpi >83E0\n\t"
+    "bl @>0E88\n\t"
+    "lwpi >83A0\n\t"
+  );
+
+  return *FMUL_PRODUCT;
+}
+
+// double division -- method normally included in GCC lib
+double __divdf3 (double a, double b) {
+
+   // use the ti99's ROM method
+
+   // divide b by a
+   *FDIV_DIVIDEND = b;
+   *FDIV_DIVISOR  = a;
+
+  __asm__(
+    "lwpi >83E0\n\t"
+    "bl @>0FF4\n\t"
+    "lwpi >83A0\n\t"
+  );
+
+  return *FDIV_QUOTIENT;
+}
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/eqdf2.c gcc-4.4.0/gcc/config/tms9900/eqdf2.c
--- gcc-4.4.0-orig/gcc/config/tms9900/eqdf2.c	2024-10-05 07:13:03.778413548 +0100
+++ gcc-4.4.0/gcc/config/tms9900/eqdf2.c	2023-12-09 11:15:23.961658672 +0000
@@ -0,0 +1,15 @@
+/* 06/23/2023 mrvan initial version
+*/
+// returns 0 if two double values are equal
+int __eqdf2 (double a, double b) {
+   char *ap = (char *) &a;
+   char *bp = (char *) &b;
+   int cmp = 0;
+   int i;
+   for (i = 0; i < 8; i++) {
+      cmp |= *ap != *bp;
+      ap++;
+      bp++;
+   }
+   return cmp;
+}
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/ftoa.c gcc-4.4.0/gcc/config/tms9900/ftoa.c
--- gcc-4.4.0-orig/gcc/config/tms9900/ftoa.c	2024-10-05 07:13:03.778413548 +0100
+++ gcc-4.4.0/gcc/config/tms9900/ftoa.c	2024-10-05 07:13:04.038411721 +0100
@@ -0,0 +1,55 @@
+/* ftoa.c
+   This method converts a TI float to an ascii representation of a float.  It
+   doesn't create very pretty output, but that doesn't matter, it's only for internal
+   use.
+
+   change log:
+   7-DEC-2023 MGB initial version
+*/
+
+void tireal_ftoa (unsigned char *d, char *p)
+{
+    short first = d[0] << 8 | d[1];
+    int exp;
+    int i;
+    if (first < 0)
+    {
+        *p++='-';
+        first =- first;
+    }
+
+    exp = first >> 8;
+    first &= 0xff;
+
+    if (first>9) *p++=(first/10) + '0';
+    *p++=(first%10)+'0';
+    *p++='.';
+    for (i = 2; i < 8; i++)
+    {
+        *p++=(d[i]/10)+'0';
+        *p++=(d[i]%10)+'0';
+    }
+
+    exp -= 0x40;
+    exp*=2;
+
+    if (exp != 0)
+    {
+        *p++='E';
+
+        if (exp<0)
+        {
+            *p++='-';
+            exp=-exp;
+        }
+
+        if (exp>9)
+        {
+            *p++=(exp/10)+'0';
+            exp/=10;
+        }
+        *p++=exp+'0';
+    }
+    *p=0;
+}
+
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/gedf2.c gcc-4.4.0/gcc/config/tms9900/gedf2.c
--- gcc-4.4.0-orig/gcc/config/tms9900/gedf2.c	2024-10-05 07:13:03.782413520 +0100
+++ gcc-4.4.0/gcc/config/tms9900/gedf2.c	2024-10-05 07:13:04.046411664 +0100
@@ -0,0 +1,9 @@
+/* 06/23/2023 mrvan initial version
+*/
+
+#include "math_private.h"
+
+// returns a value greater than or equal to zero if a is greater than or equal to b
+int __gedf2 (double a, double b) {
+   return d_compare (a, b); 
+}
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/gtdf2.c gcc-4.4.0/gcc/config/tms9900/gtdf2.c
--- gcc-4.4.0-orig/gcc/config/tms9900/gtdf2.c	2024-10-05 07:13:03.782413520 +0100
+++ gcc-4.4.0/gcc/config/tms9900/gtdf2.c	2023-12-09 11:16:04.565816750 +0000
@@ -0,0 +1,9 @@
+/* 06/23/2023 mrvan initial version
+*/
+
+#include "math_private.h"
+
+// returns a value greater than zero a is strictly greater than b
+int __gtdf2 (double a, double b) {
+   return d_compare (a, b);
+} 
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/ledf2.c gcc-4.4.0/gcc/config/tms9900/ledf2.c
--- gcc-4.4.0-orig/gcc/config/tms9900/ledf2.c	2024-10-05 07:13:03.786413492 +0100
+++ gcc-4.4.0/gcc/config/tms9900/ledf2.c	2024-10-05 07:13:04.062411552 +0100
@@ -0,0 +1,9 @@
+/* 06/23/2023 mrvan initial version
+*/
+
+#include "math_private.h"
+
+// returns a value less than or equal to zero if a is less than or equal to b
+int __ledf2 (double a, double b) {
+   return d_compare (a, b); 
+}  
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/lib1funcs.asm gcc-4.4.0/gcc/config/tms9900/lib1funcs.asm
--- gcc-4.4.0-orig/gcc/config/tms9900/lib1funcs.asm	2024-07-28 14:42:12.617792819 +0100
+++ gcc-4.4.0/gcc/config/tms9900/lib1funcs.asm	2024-10-06 08:31:26.978724038 +0100
@@ -0,0 +1,1058 @@
+/*
+ *  MGB 32-bit arithmetic functions never seem to be used.  The compiler emits
+ *  sequences of 16-bit ops to perform 32-bit ops.  An exception is it does look
+ *  for __ashlsi3 and __ashrsi3 when built to optimise for size (-Os) so these
+ *  have been added here.
+ */
+
+/******************************************************************************
+*                               __clzM2
+*******************************************************************************
+* Return the number of leading 0-bits in a value, starting at the most
+* significant bit position.  If the value is zero, the result is undefined.
+*
+* Inputs : r1 - Value to test
+*
+* Returns: r1 - Number of zero bits
+******************************************************************************/
+
+#ifdef L_clzqi2
+/*********************************************************/
+/*                     __clzqi2                          */
+/*********************************************************/
+  def __clzqi2
+__clzqi2:
+  mov  r2, @-2(r10)     /* Scratch reg */
+  movb r1, r2  /* Move value into position, set condition flags */
+  clr  r1      /* Set minimum bit count, flags unchanged */
+  jgt  do_clz  /* If val==0, return undefined, if val<0, MSB set, return 0*/
+  mov  @-2(r10), r2
+  b    *r11
+do_clz:
+  b    @__clz_nosave
+#endif
+
+
+#ifdef L_clzhi2
+/*********************************************************/
+/*                     __clzhi2                          */
+/*********************************************************/
+  def __clzhi2
+__clzhi2:
+  mov  r2, @-2(r10)     /* Scratch reg */
+  mov  r1, r2  /* Move value into position, set condition flags */
+  clr  r1      /* Set minimum bit count, flags unchanged */
+  jgt  do_clz  /* If val==0, return undefined, if val<0, MSB set, return 0*/
+  mov  @-2(r10), r2
+  b *r11
+do_clz:
+  b    @__clz_nosave
+#endif
+
+
+#ifdef L_clzsi2
+/*********************************************************/
+/*                     __clzsi2                          */
+/*********************************************************/
+  def __clzsi2
+__clzsi2:
+  mov  r2, @-2(r10)     /* Scratch reg */
+  mov  r1, r1   /* Test MSW for set bits */
+  jlt  ret_0    /* Upper bit of MSW set, return zero */
+  jgt  clz_msw  /* Count leading zeroes in MSW */
+
+clz_lsw:
+  li   r1, 16   /* MSW was zero, initialize count to 16 */
+  mov  r2, r2   /* Test bits in LSW */
+  jlt  ret_16   /* Upper bit of LSW set, return sisxteen */
+  jgt  do_clz   /* Count leading zeroes of LSW */
+
+ret_0:
+  clr  r1
+ret_16:
+  mov  @-2(r10), r2
+  b    *r11
+
+clz_msw:
+  mov  r1, r2  /* Move MSW into test position */
+  clr  r1      /* Initialize count to zero */
+do_clz:
+  b    @__clz_nosave
+#endif
+
+
+#ifdef L_clz
+/******************************************************************************
+*                               __clz
+*******************************************************************************
+* Return the number of leading 0-bits in a 16-bit value, starting at the most 
+* significant bit position.  If the value is zero, the result is undefined.
+*
+* Inputs : R1 - Minimum posible bit count
+*          R2 - Value to test
+*
+* Returns: R1 - Number of zero bits
+*******************************************************************************/
+  def __clz
+/*
+* We will shift left until we find a set bit
+*
+* Example 1, zero leading bits:
+*   C Val   N
+*   - ----  -
+*   . 1000  0
+*
+* Example 2, one leading bit:
+*   C Val   N
+*   - ----  -
+*   . 0100  4
+*   1 00..  2->1
+*
+* Example 3, two leading bits:
+*   C Val   N
+*   - ----  -
+*   0 0010  4
+*   0 10..  2
+*
+* If we got here, there is at least one bit set in supplied value
+*/
+__clz:
+  mov  r2, @-2(r10)     /* Scratch reg */
+__clz_nosave:
+  inct r1      /* Assume two zero bits, double count implied bit */
+  sla  r2, 2   /* Move next two bits into test position, set flags */
+  joc  bottom  /* Upper test bit set, exit */
+  jgt  __clz   /* Upper and lower test bits clear, loop */
+  
+  /* Clean up after loop */
+  inc r1       /* If we got here, negate next instruction */
+bottom:
+  dec r1       /* No cleared bits in last test set, decrement count */
+
+  /* Bit count is in R1, exit */
+  mov  @-2(r10), r2
+  b *r11
+#endif
+
+  
+/******************************************************************************
+*                               __ctzM2
+*******************************************************************************
+* Return the number of trailing 0-bits in a 16-bit value, starting at the least
+* significant bit position.  If the value is zero, the result is undefined.
+*
+* Inputs : R1 - Value to test
+*
+* Returns: R1 - Number of zero bits
+******************************************************************************/
+
+#ifdef L_ctzqi2
+/*********************************************************/
+/*                     __ctzqi2                          */
+/*********************************************************/
+  def __ctzqi2
+__ctzqi2:
+  clr  r2
+  movb r1, r2  /* Move value to R2, clearing low bits */
+  jeq  bottom  /* If all bits clear, stop now, return zero */
+  li   r1, 8   /* Max possible zero bits */
+  b    @__ctz  /* Examine provided value */
+bottom:
+  mov  @-2(r10), r2
+  b *r11
+#endif
+
+
+#ifdef L_ctzhi2
+/*********************************************************/
+/*                     __ctzhi2                          */
+/*********************************************************/
+  def __ctzhi2
+__ctzhi2:
+  mov  r2, @-2(r10)     /* Scratch reg */
+  mov r1, r2  /* Move value to R2, set condition flags */
+  jeq bottom  /* If all bits clear, stop now, return zero */
+  li  r1, 16  /* Max possible zero bits */
+  b   @__ctz_nosave  /* Examine provided value */
+bottom:
+  mov  @-2(r10), r2
+  b *r11
+#endif
+
+
+#ifdef L_ctzsi2
+/*********************************************************/
+/*                     __ctzsi2                          */
+/*********************************************************/
+  def __ctzsi2
+__ctzsi2:
+  mov  r2, @-2(r10)     /* Scratch reg */
+  mov  r2, r2     /* Check low word for set bits */
+  jeq  lsw_clear 
+
+  /* There are set bits in the low word */
+  li   r1, 16     /* Maximum number of possible zero bits */
+  b    @__ctz_nosave     /* Examine provided value */
+
+  /* All bits clear in the low word, no need to test them */
+lsw_clear:
+  mov  r1, r2     /* Move high word into test position */
+  jeq  bottom     /* If all bits clear, stop now, return zero */
+  li   r1, 32     /* Maximum number of possible zero bits */
+  b    @__ctz_nosave     /* Examine provided value */
+
+bottom:
+  mov  @-2(r10), r2
+  b *r11
+#endif
+
+
+#if L_ctz
+/******************************************************************************
+*                               __ctz
+*******************************************************************************
+* Return the number of trailing 0-bits in a 16-bit value, starting at the least 
+* significant bit position.  If the value is zero, the result is undefined.
+*
+* Inputs : R1 - Maximum posible bit count
+*          R2 - Value to test
+*
+* Returns: R1 - Number of zero bits
+******************************************************************************/
+  def __ctz
+
+/*
+* We will shift left until all leading set bits are shifted out of the value
+*
+* Exmaple 1, zero trailing bits:
+*   C Val   N
+*   - ----  -
+*   . 0001  4
+*   0 01..  2
+*   1 ....  0
+*
+* Exmaple 2, one trailing bit:
+*   C Val   N
+*   - ----  -
+*   . 0010  4
+*   0 10..  2
+*   0 ....  1
+*
+* Exmaple 3, two trailing bits:
+*   C Val   N
+*   - ----  -
+*   0 0100  4
+*   1 00..  2
+*/
+
+  /* Test loop, check two uppermost bits at a time */
+__ctz:
+  mov  r2, @-2(r10)     /* Scratch reg */
+__ctz_nosave:
+  dect r1      /* Assume both bits are set */
+  sla  r2, 2   /* Shift two bits into test position */
+  jne  __ctz_nosave   /* Still have set bits, keep looping */
+
+  /* Correct for last two test bits */
+  joc  bottom  /* If carry bit set, lower test bit was set */
+  inc  r1      /* lower test bit was clear, increment bit count */
+bottom:
+  mov  @-2(r10), r2
+  b *r11
+#endif
+
+
+/******************************************************************************
+*                               __ffsM2
+*******************************************************************************
+* Return the index of the least significant set bit in a value, or zero 
+* if the value is zero.  The least significant bit is index one.
+*
+* Inputs : R1 - Value to test
+*
+* Returns: R1 - Index to lowest set bit
+******************************************************************************/
+
+
+#ifdef L_ffsqi2
+/*********************************************************/
+/*                     __ffsqi2                          */
+/*********************************************************/
+  def __ffsqi2
+__ffsqi2:
+  dect r10
+  mov  r11,*r10
+  movb r1, r1     /* Check for zero value */
+  jeq  done       /* If so, exit now */
+  bl   @__ctzqi2  /* Count trailing zero bits */
+  inc  r1         /* Least sig. bit is in position trailing_count +1 */
+  jmp  ffsqi2_ret
+done:
+  clr  r1         /* Return zero value */
+ffsqi2_ret:
+  mov  *r10+, r11
+  b    *r11
+#endif
+
+
+#ifdef L_ffshi2
+/*********************************************************/
+/*                     __ffshi2                          */
+/*********************************************************/
+  def __ffshi2
+__ffshi2:
+  dect r10
+  mov  r11,*r10
+  mov r1, r1      /* Check for zero value */
+  jeq done        /* If so, exit now */
+  bl  @__ctzhi2   /* Count trailing zero bits */
+  inc r1          /* Least sig. bit is in position trailing_count +1 */
+done:
+  mov  *r10+, r11
+  b    *r11
+#endif
+
+
+#ifdef L_ffssi2
+/*********************************************************/
+/*                     __ffssi2                          */
+/*********************************************************/
+  def __ffssi2
+__ffssi2:
+  dect r10
+  mov  r11,*r10
+  mov r1, r0
+  soc r2, r0      /* Check for zero value */
+  jeq done        /* If so, exit now */
+  bl  @__ctzsi2   /* Count trailing zero bits */
+  inc r1          /* Least sig. bit is in position trailing_count +1 */
+done:
+  mov  *r10+, r11
+  b    *r11
+  ; def __modsi3 ; ???
+#endif
+
+
+#ifdef L_parity
+/******************************************************************************
+*                               __parityM2
+*******************************************************************************
+* Return the value zero if the number of bits set in the given value is even,
+* and the value one otherwise.
+*
+* Inputs : R1 - Value to test
+*
+* Returns: R1 - Number of zero bits
+******************************************************************************/
+
+/* Test an 8-bit value */
+  def __parityqi2
+__parityqi2:
+  dect r10
+  mov  r3,*r10  ; save r3
+  seto r3
+  jmp byte1
+
+/* Test a 16-bit value */
+  def __parityhi2
+__parityhi2:
+  dect r10
+  mov  r3,*r10  ; save r3
+  clr r3
+  jmp byte2
+
+/* Test a 32-bit value */
+  def __paritysi2
+__paritysi2:
+  dect r10
+  mov  r3,*r10  ; save r3
+  clr  r3
+  movb r2, r2
+  jop pre_byte3
+  inv r3
+pre_byte3:
+  swpb r2
+byte3:
+  movb r2, r2
+  jop byte2
+  inv r3
+byte2:
+  movb r1, r1
+  jop pre_byte1
+  inv r3
+pre_byte1:
+  swpb r1
+byte1:
+  movb r1, r1
+  jop done
+  inv r3
+done:
+  neg r3
+  mov r3, r1
+  mov  *r10+, r3
+  bl *r11
+#endif
+
+
+/******************************************************************************
+*                               __popcountM2
+*******************************************************************************
+* Return the number of set bits in a value
+*
+* Inputs : R1 - Value to test
+*
+* Returns: R1 - Number of set bits
+******************************************************************************/
+
+
+#ifdef L_popcountqi2
+/*********************************************************/
+/*                   __popcountqi2                       */
+/*********************************************************/
+  def __popcountqi2
+__popcountqi2:
+  dect r10
+  mov  r2,*r10  ; save r2
+  dect r10
+  mov  r11,*r10  ; save r11
+  clr  r2           /* Clear lower unused bits */
+  movb r1, r2       /* Move value into test position */
+  clr  r1           /* Clear bit count */
+  bl   @__popcount  /* Find set bit count */
+  mov  *r10+, r11
+  mov  *r10+, r3
+  b    *r11
+#endif
+
+
+#ifdef L_popcounthi2
+/*********************************************************/
+/*                   __popcounthi2                       */
+/*********************************************************/
+  def __popcounthi2
+__popcounthi2:
+  dect r10
+  mov  r2,*r10  ; save r2
+  dect r10
+  mov  r11,*r10  ; save r11
+  mov  r1, r2       /* Move value into test position */
+  clr  r1           /* Clear bit count */
+  bl   @__popcount  /* Find set bit count */
+  mov  *r10+, r11
+  mov  *r10+, r3
+  b    *r11
+#endif
+
+
+#ifdef L_popcountsi2
+/*********************************************************/
+/*                   __popcountsi2                       */
+/*********************************************************/
+  def __popcountsi2
+__popcountsi2:
+  dect r10
+  mov  r3,*r10  ; save r3
+  dect r10
+  mov  r11,*r10  ; save r11
+  mov  r1, r3       /* Move MSW to safe position */
+  clr  r1           /* Clear bit count */
+  bl   @__popcount  /* Find LSW set bit count */
+  mov  r3, r2       /* Move MSW into test position */
+  bl   @__popcount  /* Find MSW set bit count */
+  mov  *r10+, r11
+  mov  *r10+, r3
+  b    *r11
+#endif
+
+
+#ifdef L_popcount
+/******************************************************************************
+*                               __popcount
+*******************************************************************************
+* Return the number of set bits in a 16-bit value
+*
+* Inputs : R1 - Current bit count
+*          R2 - Value to test
+*
+* Returns: R1 - Number of set bits
+******************************************************************************/
+  def __popcount
+__popcount:
+  mov  r2,r2   /* Check for zero value */  
+  jeq  done    /* If zero, exit now */
+top:
+  inc  r1      /* Increment bit count */
+  mov  r2, r0  /* \                           */
+  neg  r0      /* | Equvilent to r2 &= (r2-1) */
+  szc  r0, r2  /* /                           */
+  jne  top     /* Keep looping until all bits counted */
+done:
+  b    *r11    /* Return to caller */
+#endif
+
+
+#ifdef L_divmodsi3
+/******************************************************************************
+*                               __divmodsi3
+*******************************************************************************
+* Calculate the signed quotient and modulus of the two values provided
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*           R5     - Address for modulus
+*
+* Returns: [R1,R2] - 32-bit quotient
+*
+* TODO - is this a library function?  Why pointer in r5?  Disabled for now
+******************************************************************************/
+  def __divmodsi3
+__divmodsi3:
+  /* Save return register and r6 */
+  dect r10
+  mov  r11,*r10
+  dect r10
+  mov  r5,*r10
+
+  bl   @__divmodstart
+
+  /* Caclulate result */
+calc:
+  bl   @__udivmod32
+
+  /* Negate modulus if needed */
+  mov  r5, r0
+  jlt  savemod
+  inv  r3
+  neg  r4
+  jnc  savemod
+  inc  r3
+  
+  /* Save modulus */
+savemod:
+  mov  *r10, r0
+  mov  r3, *r0+
+  mov  r4, *r0
+
+  /* Restore from stack */
+  mov  *r10+, r5
+  mov  *r10+, r11
+
+  /* Complete operatons */
+  b    @__divmodend
+#endif
+
+
+#ifdef L_divsi3
+/******************************************************************************
+*                               __divsi3
+*******************************************************************************
+* Calculate the signed quotient of the two values provided
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*
+* Returns: [R1,R2] - 32-bit quotient
+******************************************************************************/
+  def __divsi3
+__divsi3:
+  /* Save return register */
+  dect r10
+  mov  r11,*r10  ; save r11
+  dect r10
+  mov  r5,*r10  ; save r5
+  bl   @__divmodstart
+
+  /* Caclulate result */
+calc:
+  bl   @__udivmod32
+
+  /* Restore from stack */
+  mov  *r10+, r5
+  mov  *r10+, r11
+
+  b    @__divmodend
+#endif
+
+
+#ifdef L_modsi3
+/******************************************************************************
+*                               __modsi3
+*******************************************************************************
+* Calculate the signed modulus of the two values provided
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*
+* Returns: [R1,R2] - 32-bit modulus
+******************************************************************************/
+  def __modsi3
+__modsi3:
+  /* Save return register */
+  dect r10
+  mov  r11,*r10  ; save r11
+  dect r10
+  mov  r5,*r10  ; save r5
+  bl   @__divmodstart
+
+  /* Caclulate result */
+calc:
+  bl   @__udivmod32
+  mov  r3, r1
+  mov  r4, r2
+
+  /* Restore from stack */
+  mov  *r10+, r5
+  mov  *r10+, r11
+
+  b    @__divmodend
+#endif
+
+
+#ifdef L_divmod_common
+/******************************************************************************
+*                               __divmodstart
+*******************************************************************************
+* Common code for the start of all signed division and modulo calculations
+*
+* Inputs:  [R1,R2] - Signed 32-bit numerator
+*          [R3,R4] - Signed 32-bit denominator
+*
+* Returns: [R1,R2] - Positive 32-bit quotient
+*          [R3,R4] - Positive 32-bit denominator
+*          [R5]    - Sign of result
+******************************************************************************/
+  def __divmodstart
+__divmodstart:
+  /* Make numerator positive */
+  mov  r1, r5
+  jlt  negnum
+  jmp  testden
+negnum:
+  inv  r1
+  neg  r2
+  jnc  testden
+  inc  r1
+
+  /* Make denominator positive */
+testden:
+  xor  r3, r5
+  mov  r3, r3
+  jlt  negden
+  jmp  done
+negden:
+  inv  r3
+  neg  r4
+  jnc  done
+  inc  r3
+done:
+  b    *r11
+
+
+/******************************************************************************
+*                               __divmodend
+*******************************************************************************
+* Common code for the end of all signed division and modulo calculations
+*
+* Inputs:  [R1,R2] - Positive 32-bit quotient
+*          [R3,R4] - Positive 32-bit denominator
+*          [R5]    - Sign of result
+*          
+* Returns: [R1,R2] - Signed 32-bit result
+******************************************************************************/
+  def __divmodend
+__divmodend:
+
+  /* Do we need to negate the result? */
+  mov  r5, r0
+  jlt  makeneg  
+  b    *r11        # Nope, exit now
+
+  /* Negate result and return */
+makeneg:  
+  inv  r1
+  neg  r2
+  jnc  jmp1
+  inc  r1
+jmp1:
+  b    *r11
+#endif
+
+
+#ifdef L_udivmodsi3
+/******************************************************************************
+*                             __udivmodsi3
+*******************************************************************************
+* Calculate the unsigned quotient and remainder of the two values provided
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*           R5     - Address to place 32-bit remainder
+*
+* Returns: [R1,R2] - 32-bit quotient
+******************************************************************************/
+  def __udivmodsi3
+__udivmodsi3:
+  /* Save pointer and return address */
+  dect r10
+  mov  r11,*r10  ; save r11
+  dect r10
+  mov  r5,*r10  ; save r5
+
+  /* Do some math */
+  bl   @__udivmodsi
+  
+  /* Save remainder */
+  mov  *r10, r0
+  mov  r3, *r0+
+  mov  r4, *r0
+
+  mov  *r10+, r5
+  mov  *r10+, r11
+  b    *r11
+#endif
+
+
+#ifdef L_udivsi3
+/******************************************************************************
+*                               __udivsi3
+*******************************************************************************
+* Calculate the unsigned quotient of the two values provided
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*
+* Returns: [R1,R2] - 32-bit quotient
+******************************************************************************/
+  def __udivsi3
+__udivsi3:
+  /* Fall through to next routine */
+
+
+/******************************************************************************
+*                               __udivmod32
+*******************************************************************************
+* Calculate the unsigned quotient and remainder of the two values provided.
+* This is used by all the 32-bit division and modulus functions.
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*
+* Returns: [R1,R2] - 32-bit quotient
+*          [R3,R4] - 32-bit remainder
+******************************************************************************/
+  def __udivmod32
+__udivmod32:
+  ai   r10, -10
+  mov  r10, r0
+  mov  r5, *r0+
+  mov  r6, *r0+
+  mov  r7, *r0+
+  mov  r8, *r0+
+  mov  r12, *r0+
+
+  /* Check size of denominator */
+  mov  r3, r3      /* Is the upper word of denominator used? */
+  jne  den32       /* If so, jump to 32-bit code */
+
+  /* Handle 16-bit denominator */
+  /* Zero extend numerator */
+  clr  r0
+  mov  r1, r1
+  jeq  num16       /* If numerator is only 16 bits, skip the first DIV */
+
+  /* Perform calculation */
+  div  r4, r0
+num16:
+  div  r4, r1
+
+  /* Move results into return position */
+  mov  r2, r4      /* LSW of remainder */
+                   /* MSW of remainder still zero */
+  mov  r1, r2      /* LSW of result */
+  mov  r0, r1      /* MSW of result */
+  jmp  jmp4
+
+den32:
+  /*
+  * Handle 32-bit denominator
+  *
+  *      A1*N + A1
+  * Q = ---------
+  *      B1*N + B2
+  *
+  * N = 0x10000
+  *
+  * Divide top and bottom by 2*B1 to make the denominator a 16-bit quantity
+  *
+  *        A1*N + A2
+  *       ---------
+  *          2*B1
+  * Q = ---------------
+  *        N     B2
+  *       --- + ---
+  *        2    2*B1
+  *
+  * This will result in some rounding error which must be corrected for.
+  * We will call the approximate value P, and the rounding error E. 
+  *
+  * Q - P = E
+  *
+  * Analysis of the error shows that E must be either 0 or -1. We will calculate
+  * the remainder to determine E and so correct P.
+  *
+  * R = (A1*N + A2) - P*(B1*N + B2)
+  *
+  * If R is negative, P is too large by one and we will apply the correction.
+  * Otherwise, P is correct and we can use the value directly.
+  */
+
+  /* Move arguments into test position */
+  mov  r1, r0      /* [r0,r12] <- [A1,A2] = numerator */
+  mov  r2, r12
+
+  mov  r3, r7      /* [r7,r8] <- [B1,B2] = deominator */
+  mov  r4, r8
+
+  /* Calculate V = (N/2 + B2/(2*B1)) */
+  clr  r1          /* [r1,r2] <- [C1,C2] = B2/2 */
+  mov  r8, r2
+  srl  r2, 1
+
+  div  r7, r1      /* r1 <- v = [C1,C2]/B1 */
+  ai   r1, 0x8000  /* v += 0x8000 */
+
+  /* Calculate U = (A1*N + A2)/(2*B1) */
+  mov  r0, r2      /* [r2,r3] <- [U1,U2] = [A1,A2] */
+  mov  r12, r3
+
+  srl  r2, 1       /* [U1,U2] = [A1,A2]/2 */
+  srl  r3, 1
+  jnc  jmp1
+  ori  r3, 0x8000
+jmp1:
+
+  clr  r4          /* [U1,U2] = [U1,U2]/B1 */
+  mov  r2, r5
+  div  r7, r4
+  mov  r3, r6
+  div  r7, r5
+  mov  r4, r2
+  mov  r5, r3
+
+  div  r1, r2      /* r2 <- P = [U1,U2]/V */
+
+  /* Calculate remainder  [m1,m2]=[a1,a2]-[b1,b2]*p */
+  mov  r7, r3      /* [r3,r4] <- [U1,U2] = B1*p */
+  mpy  r2, r3
+
+  mov  r8, r5      /* [r5,r6] <- [D1,D2] = B2*P */
+  mpy  r2, r5
+
+  a    r4, r5      /* [D1,D2] += [U2,0] */
+
+  mov  r0, r3      /* [M1,M2] = [A1,A2] */
+  mov  r12, r4
+
+  s    r5, r3      /* [M1,M2] -= [D1,D2] */
+  s    r6, r4
+  joc  jmp2
+  dec  r3
+jmp2:
+
+  /*
+  * Results now in return position, prepare for exit
+  *   [r1,r2] <- quotient
+  *   [r3,r4] <- remainder
+  */
+  clr  r1          /* Set upper word of quotient, we know it will be zero */
+  mov  r3, r3      /* if(remainder >= 0) P is correct */
+  jlt  jmp3
+  jmp  jmp4
+jmp3:
+
+  /* Correct result for rounding error */
+  dec  r2          /* P -= 1 */
+
+  /* Correct remainder for rounding error */
+  a    r7, r3      /* [M1,M2] += [B1,B2] */
+  a    r8, r4
+  jnc  jmp4
+  inc  r3
+jmp4:
+
+  /* Return value */
+  mov  *r10+, r5
+  mov  *r10+, r6
+  mov  *r10+, r7
+  mov  *r10+, r8
+  mov  *r10+, r12
+  b    *r11
+#endif
+
+
+#ifdef L_umodsi3
+/******************************************************************************
+*                               __umodsi3
+*******************************************************************************
+* Calculate the unsigned modulus of the two values provided
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*
+* Returns: [R1,R2] - 32-bit modulus
+******************************************************************************/
+  def __umodsi3
+__umodsi3:
+  dect r10
+  mov  r11,*r10  ; save r11
+  bl   @__udivmod32
+  mov  r3, r1
+  mov  r4, r2
+  mov  *r10+, r11
+  b    *r11
+#endif
+
+
+#ifdef L_ashlsi3
+/******************************************************************************
+*                               __ashlsi3
+*******************************************************************************
+* Arithmetic left shift of 32 bit value
+*
+* Inputs:  [R1,R2] - 32-bit value
+*          [R3]    - Shift count
+*
+* Returns: [R1,R2] - 32-bit result
+******************************************************************************/
+  def __ashlsi3
+__ashlsi3:
+  mov  r15, @-2(r10)     /* Scratch reg. No need to modify SP, not used and no siblings */
+
+  /* Variable shift */
+  mov  r3, r0
+  ci   r0, 16
+  jlt  ashllt16
+  jeq  ashleq16
+     
+  /* Shift count greater than 16 */
+  sla  r2, 0 
+
+  /* eq_16: Shift count equals 16 */
+ashleq16:
+  mov  r2, r1
+  clr  r2
+  jmp  ashldone
+
+  /* lt_16: Shift count less than 16 */
+ashllt16:      
+  abs  r0
+  jeq  ashldone
+  mov  r2, r15
+  sla  r1, 0
+  sla  r2, 0
+  neg  r0
+  srl  r15, 0
+  soc  r15, r1
+
+ashldone:
+  mov  @-2(r10), r15
+  b    *r11
+#endif
+
+
+#ifdef L_ashrsi3
+/******************************************************************************
+*                               __ashrsi3
+*******************************************************************************
+* Arithmetic left shift of 32 bit value
+*
+* Inputs:  [R1,R2] - 32-bit value
+*          [R3]    - Shift count
+*
+* Returns: [R1,R2] - 32-bit result
+******************************************************************************/
+  def __ashrsi3
+__ashrsi3:
+  mov  r15, @-2(r10)     /* Scratch reg */
+
+  /* Variable shift */
+  mov  r3, r0
+  ci   r0, 16
+  jlt  ashrlt16
+  jeq  ashreq16
+
+  /* Shift count greater than 16 */
+  sra  r1, 0
+
+ashreq16:
+  /* eq_16: Shift count equals 16 */
+  mov  r1, r2
+  seto r1
+  jlt  ashrdone
+  clr  r1
+  jmp  ashrdone
+
+ashrlt16:
+  /* lt_16: Shift count less than 16 */
+  abs  r0
+  jeq  ashrdone
+  mov  r2, r15
+  sra  r1, 0
+  srl  r2, 0
+  neg  r0
+  sla  r15, 0
+  soc  r15, r2
+
+ashrdone:
+  mov  @-2(r10), r15
+  b    *r11
+#endif
+
+
+#ifdef L_lshrsi3
+/******************************************************************************
+*                               __lshrsi3
+*******************************************************************************
+* Arithmetic left shift of 32 bit value
+*
+* Inputs:  [R1,R2] - 32-bit value
+*          [R3]    - Shift count
+*
+* Returns: [R1,R2] - 32-bit result
+******************************************************************************/
+  def __lshrsi3
+__lshrsi3:
+  mov  r15, @-2(r10)     /* Scratch reg */
+
+  /* Variable shift */
+  mov  r3, r0
+  ci   r0, 16
+  jlt  lshrlt16
+  jeq  lshreq16
+
+  /* Shift count greater than 16 */
+  srl  r1, 0
+
+lshreq16:
+  /* eq_16: Shift count equals 16 */
+  mov  r1, r2
+  clr  r1
+  jmp  lshrdone
+
+lshrlt16:
+  /* lt_16: Shift count less than 16 */
+  abs  r0
+  jeq  lshrdone
+  mov  r2, r15
+  srl  r1, 0
+  srl  r2, 0
+  neg  r0
+  sla  r15, 0
+  soc  r15, r2
+
+lshrdone:
+  mov  @-2(r10), r15
+  b    *r11
+#endif
+
+
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/longdivmod.c gcc-4.4.0/gcc/config/tms9900/longdivmod.c
--- gcc-4.4.0-orig/gcc/config/tms9900/longdivmod.c	2024-10-05 07:13:03.790413464 +0100
+++ gcc-4.4.0/gcc/config/tms9900/longdivmod.c	2024-10-05 07:13:04.078411439 +0100
@@ -0,0 +1,64 @@
+/* longdivmod.c
+   These methods provide long division and moduls.
+   change log:
+   12/26/2023 initial version
+*/
+
+// #include <longdivmod.h>
+
+long numerator_s32_cache = 0;
+long denominator_s32_cache = 0; 
+volatile long quotient_s32_cache;
+volatile long remainder_s32_cache;
+
+void divmod_s32 (long numerator, long denominator) {
+
+   long sign = 1;
+   long t;
+
+   quotient_s32_cache  = 0;
+   remainder_s32_cache = 0;
+
+   if (numerator < 0) {
+      sign      = sign * -1;
+      numerator = -numerator;
+   }
+
+   if (denominator < 0) {
+      sign        = sign * -1;
+      denominator = -denominator;
+   }
+
+   int i;
+   for (i = 31 ; i >= 0; i--) {
+      remainder_s32_cache = remainder_s32_cache << 1;
+      t                   = (long) 1 << i;
+      t                   = t & numerator; 
+      t                   = t >> i;
+      remainder_s32_cache = remainder_s32_cache | t;
+      if (remainder_s32_cache >= denominator) {
+         remainder_s32_cache = remainder_s32_cache - denominator;
+         quotient_s32_cache  = quotient_s32_cache | ((long) 1 << i);
+      }
+   }
+
+   quotient_s32_cache = quotient_s32_cache * sign;
+}
+
+long __divsi3 (long numerator, long denominator) {
+   if (numerator != numerator_s32_cache || denominator != denominator_s32_cache) {
+      numerator_s32_cache   = numerator;
+      denominator_s32_cache = denominator;
+      divmod_s32 (numerator_s32_cache, denominator_s32_cache);
+   }
+   return quotient_s32_cache;
+}
+
+long __modsi3 (long numerator, long denominator) {
+   if (numerator != numerator_s32_cache || denominator != denominator_s32_cache) {
+      numerator_s32_cache   = numerator;
+      denominator_s32_cache = denominator;
+      divmod_s32 (numerator_s32_cache, denominator_s32_cache);
+   }
+   return remainder_s32_cache;
+}
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/ltdf2.c gcc-4.4.0/gcc/config/tms9900/ltdf2.c
--- gcc-4.4.0-orig/gcc/config/tms9900/ltdf2.c	2024-10-05 07:13:03.790413464 +0100
+++ gcc-4.4.0/gcc/config/tms9900/ltdf2.c	2024-10-05 07:13:04.082411411 +0100
@@ -0,0 +1,9 @@
+/* 06/23/2023 mrvan initial version
+*/
+
+#include "math_private.h"
+
+// returns a value less than zero if a is strictly less than b
+int __ltdf2 (double a, double b) {
+   return d_compare (a, b); 
+}
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/math_private.h gcc-4.4.0/gcc/config/tms9900/math_private.h
--- gcc-4.4.0-orig/gcc/config/tms9900/math_private.h	2024-10-05 07:13:03.794413436 +0100
+++ gcc-4.4.0/gcc/config/tms9900/math_private.h	2024-10-05 07:13:04.086411383 +0100
@@ -0,0 +1,10 @@
+#ifndef MATH_PRIVATE_H
+#define MATH_PRIVATE_H
+
+// adjusts the exponent and first digit of mantissa to positive and returns -1 if the double is negative or 1 if not
+int d_adj_neg_pos (double *d);
+
+// compares two floats
+int d_compare (double a, double b);
+
+#endif
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/tms9900.c gcc-4.4.0/gcc/config/tms9900/tms9900.c
--- gcc-4.4.0-orig/gcc/config/tms9900/tms9900.c	2024-07-28 14:42:12.629792725 +0100
+++ gcc-4.4.0/gcc/config/tms9900/tms9900.c	2024-10-06 08:31:26.994723933 +0100
@@ -0,0 +1,1515 @@
+/* Subroutines for insn-output.c for TMS9900.
+   Copyright (C) 1987, 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002,
+   2004, 2005, 2006, 2007, 2008
+   Free Software Foundation, Inc.
+
+Copyright 2009 Eric Welser (EMW)
+Copyright 2023 Mark Burkley (MGB)
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#include "insn-modes.h"
+#include <stdio.h>
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "rtl.h"
+#include "tree.h"
+#include "tm_p.h"
+#include "regs.h"
+#include "hard-reg-set.h"
+#include "real.h"
+#include "insn-config.h"
+#include "conditions.h"
+#include "output.h"
+#include "insn-attr.h"
+#include "flags.h"
+#include "recog.h"
+#include "expr.h"
+#include "libfuncs.h"
+#include "toplev.h"
+#include "basic-block.h"
+#include "function.h"
+#include "ggc.h"
+#include "reload.h"
+#include "target.h"
+#include "target-def.h"
+#include "df.h"
+#include "dfp.h"
+#include "decimal128.h"
+#include "decNumber.h"
+
+/* Define this to put insn debug info into output files.  Note this method is a
+ * bit of a hack that takes a copy of the output file pointer.  On rare
+ * occasions this pointer may go invalid before we are finished which may cause
+ * a segfault on write so if debugging segfaults make sure to test with inline
+ * debug disabled 
+
+ * Note that this is also controlled by the -minline_rtl command line switch, so is
+ * always left enabled now.
+ */
+// #undef TMS9900_INLINE_DEBUG
+#define TMS9900_INLINE_DEBUG 1
+
+/* Define this to 1 to output debug info to stdout as we are compiling. */
+#if 0
+#define dbgprintf printf
+#else
+#define dbgprintf(...)
+#endif
+
+static bool tms9900_pass_by_reference (CUMULATIVE_ARGS *,
+                                       enum machine_mode, const_tree, bool);
+static bool tms9900_asm_integer(rtx x, unsigned int size, int aligned_p);
+
+static int tms9900_dwarf_label_counter;
+
+/* Define data types */
+#undef  TARGET_ASM_BYTE_OP
+#define TARGET_ASM_BYTE_OP "\tbyte\t"
+
+#undef  TARGET_ASM_ALIGNED_HI_OP
+#define TARGET_ASM_ALIGNED_HI_OP "\tdata\t"
+
+#undef  TARGET_PASS_BY_REFERENCE
+#define TARGET_PASS_BY_REFERENCE tms9900_pass_by_reference
+
+#undef  TARGET_ASM_INTEGER
+#define TARGET_ASM_INTEGER tms9900_asm_integer
+
+#undef  TARGET_FUNCTION_OK_FOR_SIBCALL
+#define TARGET_FUNCTION_OK_FOR_SIBCALL tms9900_ok_for_sibcall
+
+/*  MGB if we return true here, then any constants we define using
+ *  force_const_mem will get added to a shared pool instead of a function pool.
+ *  This should result in better use of memory as duplicates will be eliminated.
+ *  We don't care about distances as all memory references are 16-bits.
+ *
+ *  NOTE : force_const_mem must only be called in a define_expand not a
+ *  define_insn as it is too late to add a constant to the pool for output by
+ *  the time we are emitting insns.
+ *
+ *  Actually, expands have problems too.  Presumably because later compiler
+ *  passes can generate new compare insns which then can't be matched.
+ *  define_insn_and_split works better
+ *
+ *  Changing this to be false to use per fucntion pools instead.  If byte
+ *  constants are placed at the end of a compilation unit, it may result in an
+ *  odd address for the end of the pseg which messes up loading.  TODO fix that
+ *  properly sometime.
+ */
+
+static bool
+tms9900_use_blocks_for_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED,
+				const_rtx x ATTRIBUTE_UNUSED)
+{
+  // return true;
+  return false;
+}
+
+#undef TARGET_USE_BLOCKS_FOR_CONSTANT_P
+#define TARGET_USE_BLOCKS_FOR_CONSTANT_P tms9900_use_blocks_for_constant_p
+
+static bool
+tms9900_ok_for_sibcall (tree decl, tree exp)
+{
+  return true;
+}
+
+#define TARGET_ASM_ALIGNED_HI_OP "\tdata\t"
+#define TARGET_ASM_ALIGNED_SI_OP NULL
+#define TARGET_ASM_ALIGNED_DI_OP NULL
+#define TARGET_ASM_ALIGNED_TI_OP NULL
+
+static bool
+tms9900_cannot_force_const_mem (rtx x);
+
+#undef TARGET_CANNOT_FORCE_CONST_MEM
+#define TARGET_CANNOT_FORCE_CONST_MEM tms9900_cannot_force_const_mem
+
+struct gcc_target targetm = TARGET_INITIALIZER;
+
+#include "ftoa.c"
+#include "atof.c"
+
+static void
+tms9900_encode_real (const struct real_format *fmt, long *buf,
+		    const REAL_VALUE_TYPE *r)
+{
+  char a[256];
+  unsigned char d[8];
+  decimal128ToString((const decimal128*)r->sig, a);
+
+  tireal_atof (a, d);
+
+  // Convert 8-bytes to 3-longs ????
+  buf[0] = (d[0] << 24) | (d[1] << 16) | (d[2] << 8) | d[3];
+  buf[1] = (d[4] << 24) | (d[5] << 16) | (d[6] << 8) | d[7];
+  buf[2] = 0;
+}
+
+/*  Decode a TI real to REAL_VALUE_TYPE by first converting it to a string.  The
+ *  r->sig member of the real value is a decimal128 struct */
+static void
+tms9900_decode_real (const struct real_format *fmt, REAL_VALUE_TYPE *r,
+		    const long *buf)
+{
+  char s[32];
+  unsigned char d[8];
+
+  /*  Assuming reverse mapping of longs to bytes that we did in encode */
+  d[0] = (buf[0] >> 24) & 0xff;
+  d[1] = (buf[0] >> 16) & 0xff;
+  d[2] = (buf[0] >> 8) & 0xff;
+  d[3] = buf[0] & 0xff;
+  d[4] = (buf[1] >> 24) & 0xff;
+  d[5] = (buf[1] >> 16) & 0xff;
+  d[6] = (buf[1] >> 8) & 0xff;
+  d[7] = buf[1] & 0xff;
+
+  tireal_ftoa (d, s);
+    
+  decimal_real_from_string (r, s);
+}
+
+const struct real_format tms9900_real_format =
+  {
+    tms9900_encode_real,
+    tms9900_decode_real,
+    10,         // base 10
+    14,         // 14 digits
+    14,         // 14 digits
+    -63,        // lowest exp
+    64,         // highest exp
+    63,
+    63,
+    false,      // Don't round toward 0
+    false,      // Don't have sign dependent rounding
+    false,      // Don't have NAN
+    false,      // Don't have INF
+    false,      // Don't have denorm whatever that is
+    true,       // Do have signed zero
+    false,      // Don't have qnan
+    false       // Don't have that last thing
+  };
+
+
+/* Set global variables as needed for the options enabled.  */
+
+void override_options (void)
+{
+  /* We use TI99 floating point, not IEEE floating point.  */
+  if (!TARGET_NO_TI99_FLOAT)
+    REAL_MODE_FORMAT (DFmode) = &tms9900_real_format;
+}
+
+/* Non-volatile registers to be saved across function calls 
+   HARD_R5_REGNUM,
+   HARD_R6_REGNUM,
+   HARD_R7_REGNUM,
+   HARD_R8_REGNUM, */
+
+static int nvolregs[]={
+   HARD_LR_REGNUM,
+   HARD_BP_REGNUM,
+   HARD_R12_REGNUM,
+   HARD_R13_REGNUM,
+   HARD_R14_REGNUM,
+   HARD_R15_REGNUM};
+
+#define MAX_SAVED_REGS (sizeof (nvolregs) / sizeof (int))
+
+/* If defined, a C expression which determines whether, and in which direction,
+   to pad out an argument with extra space.  The value should be of type
+   `enum direction': either `upward' to pad above the argument,
+   `downward' to pad below, or `none' to inhibit padding.
+
+   Structures are stored left shifted in their argument slot.  */
+int tms9900_function_arg_padding (enum machine_mode mode,
+                                  const_tree type)
+{
+  if (type != 0 && AGGREGATE_TYPE_P (type))
+  {
+    dbgprintf ("%s upward\n", __func__);
+    return upward;
+  }
+
+  /* Fall back to the default.  */
+  return DEFAULT_FUNCTION_ARG_PADDING (mode, type);
+}
+
+
+/* Update the data in CUM to advance over an argument
+   of mode MODE and data type TYPE.
+   (TYPE is null for libcalls where that information may not be available.)  */
+void tms9900_function_arg_advance (CUMULATIVE_ARGS *cum, 
+                                   enum machine_mode mode,
+                                   tree type, 
+                                   int named ATTRIBUTE_UNUSED)
+{
+  int arg_bytes;
+  if(mode == BLKmode)
+  {
+     arg_bytes = int_size_in_bytes (type);
+  }
+  else
+  {
+     arg_bytes = GET_MODE_SIZE (mode);
+  }
+  cum->nregs += ((arg_bytes + 1)/ UNITS_PER_WORD) * REGS_PER_WORD;
+  dbgprintf("%s bytes=%d\n", __func__, arg_bytes);
+  return;
+}
+
+
+/* Initialize a variable CUM of type CUMULATIVE_ARGS
+   for a call to a function whose data type is FNTYPE.
+   For a library call, FNTYPE is NULL.  */
+void tms9900_init_cumulative_args (CUMULATIVE_ARGS *cum, 
+                                   tree fntype ATTRIBUTE_UNUSED,
+                                   rtx libname ATTRIBUTE_UNUSED)
+{
+  /* Varargs vectors are treated the same as long long. Using
+     named_count avoids having to change the way 'named' is handled */
+  cum->named_count = 0;
+  cum->nregs = 0;
+}
+
+
+/* Determine where to put an argument to a function.
+   Value is zero to push the argument on the stack,
+   or a hard register in which to store the argument.
+
+   MODE is the argument's machine mode.
+   TYPE is the data type of the argument (as a tree).
+      This is null for libcalls where that information may
+      not be available.
+   CUM is a variable of type CUMULATIVE_ARGS which gives info about
+      the preceding args and about the function being called.
+   NAMED is nonzero if this argument is a named parameter
+      (otherwise it is an extra parameter matching an ellipsis).  */
+rtx tms9900_function_arg (CUMULATIVE_ARGS *cum, 
+                          enum machine_mode mode,
+		          tree type,
+                          int named)
+{
+   if (mode == VOIDmode)
+   {
+     /* Pick an arbitrary value for operand 2 of the call insn.  */
+     dbgprintf ("%s void\n", __func__);
+     return const0_rtx;
+   }
+  
+   /* TODO it seems named is zero for the last named parameter before an
+    * elipsis.  The value named_count in the cum structure is not used but in
+    * the arm backend, the code traverses the arg tree to count the number of
+    * named params.  Maybe its a known thing that named_count should be
+    * maintained separately
+    */
+   if (/* Vararg argument, must live on stack */
+       !named ||
+       /* Argument doesn't completely fit in arg registers */      
+       GET_MODE_SIZE(mode) + cum->nregs > TMS9900_ARG_REGS)
+   {
+      dbgprintf ("%s named=%d size=%d nr=%d max=%d : alloc on stack\n", __func__,
+              named, (int)GET_MODE_SIZE(mode), cum->nregs, TMS9900_ARG_REGS);
+      return NULL_RTX;
+   }
+
+   /* Allocate registers for argument */
+   dbgprintf ("%s alloc in reg %d\n", __func__, cum->nregs+1);
+   return gen_rtx_REG (mode, cum->nregs + HARD_R1_REGNUM);
+}
+
+/* Output all constant addresses using hex values */
+static void tms9900_output_addr_const(FILE *file, rtx addr)
+{
+  if(CONST_INT_P(addr))
+    fprintf(file, ">%X", (int)(INTVAL(addr)) & 0xFFFF);
+  else
+    output_addr_const(file, addr);
+}
+
+/* Construct string expression matching an address operand */
+void print_operand_address (FILE *file,
+                            register rtx addr)
+{
+  retry:
+  switch (GET_CODE (addr))
+    {
+    case MEM:
+      addr = XEXP (addr, 0);
+      goto retry;
+
+    case REG:
+      fprintf (file, "*%s", reg_names[REGNO (addr)]);
+      break;
+
+    case POST_MODIFY:
+    case POST_INC:
+      fprintf (file, "*%s+", reg_names[REGNO (XEXP (addr, 0))]);
+      break;
+
+    case PLUS:
+      /* @xxxx(R0) */
+      if (GET_CODE (addr) == PLUS            &&
+          GET_CODE (XEXP (addr, 0)) == REG   &&
+          REG_OK_FOR_BASE_P (XEXP (addr, 0)) &&
+          CONSTANT_ADDRESS_P (XEXP (addr, 1)))
+      {
+        fprintf(file, "@");
+        tms9900_output_addr_const (file, XEXP (addr, 1));
+        fprintf(file, "(%s)", reg_names[REGNO (XEXP (addr, 0))]);
+      }
+
+      /* @(symbol+xxxx)(R0) */
+      else if(GET_CODE (addr) == PLUS )
+      {
+        rtx base   = 0;
+        rtx offset = 0;
+        int regno  = 0;
+        if(GET_CODE(XEXP(addr,0)) == MEM)
+        {
+          rtx op = XEXP(addr,0);
+          op = XEXP(op, 0);
+          if(GET_CODE (op) == PLUS             &&
+             GET_CODE (XEXP (op, 0)) == REG    &&
+             REG_OK_FOR_BASE_P (XEXP (op, 0))  &&
+             CONSTANT_ADDRESS_P(XEXP (op, 1))  &&
+             CONSTANT_ADDRESS_P(XEXP(addr, 1)))
+          {
+            base   = XEXP(addr, 1);
+            offset = XEXP(op, 1);
+            regno  = REGNO(XEXP(op, 0));
+            if(CONST_INT_P(base) && CONST_INT_P(offset))
+            {
+              fprintf(file, "@>%X(%s)", (int)(INTVAL(base) + INTVAL(offset)) & 0xFFFF, reg_names[regno]);
+            }
+            else
+            {
+              fprintf(file, "@(");
+              tms9900_output_addr_const (file, base);
+              fprintf(file, "+>%X)(%s)", ((int)INTVAL(offset)) & 0xFFFF, reg_names[regno]);
+            }
+          }
+        }
+      }
+      else
+      {
+        gcc_assert (0);
+      }
+      break;
+
+    default:
+      fprintf(file, "@");
+      tms9900_output_addr_const (file, addr);
+    }
+}
+
+/* Should we save this register?  The only registers we care about are R11 which
+ * must be saved if we are not a leaf function or if used by an inline asm and
+ * R14 if we use a frame pointer in this function. */ 
+int tms9900_should_save_reg(int regno)
+{
+  dbgprintf("%s ever_live=%d used=%d R%d leaf=%d fp_need=%d\n",
+         __func__, df_regs_ever_live_p(regno), call_used_regs[regno],
+         regno, current_function_is_leaf,
+         frame_pointer_needed);
+
+  /*  Generic condition for register that is used and marked as must be
+   *  preserved */
+  if (df_regs_ever_live_p(regno) && (call_used_regs[regno] == 0))
+  {
+    dbgprintf ("%s save live and not used\n", __func__);
+    return 1;
+  }
+
+  /*  Special case, R11 is declared as used so save it */
+  if (df_regs_ever_live_p(regno) && regno == HARD_LR_REGNUM)
+  {
+    dbgprintf ("%s save LR, ever_live\n", __func__);
+    return 1;
+  }
+
+  /*  This function calls other functions, save R11 */
+  if (regno == HARD_LR_REGNUM && !current_function_is_leaf)
+  {
+    dbgprintf ("%s save LR, not leaf\n", __func__);
+    return 1;
+  }
+          
+  /*  Not used, but the logic here is to only save BP if we need a frame pointer */
+  if (regno == HARD_BP_REGNUM && frame_pointer_needed)
+  {
+    dbgprintf ("%s save BP\n", __func__);
+    return 1;
+  }
+
+  dbgprintf ("%s no save\n", __func__);
+  return 0;
+}
+
+/* Get number of bytes used to save registers in the current stack frame */
+static int tms9900_get_saved_reg_size(void)
+{
+   int size = 0;
+   int i;
+
+   for (i = 0; i < MAX_SAVED_REGS; i++)
+      if (tms9900_should_save_reg (nvolregs[i]))
+         size += 2; 
+
+   return size;
+}
+
+static int tms9900_get_regs_to_save (int saveregs[])
+{
+   int i;
+   int count = 0;
+
+   for (i = 0; i < MAX_SAVED_REGS; i++)
+      if (tms9900_should_save_reg (nvolregs[i]))
+         saveregs[count++] = nvolregs[i];
+
+   return count;
+}
+
+static void print_arg_offset (int from)
+{
+    switch (from)
+    {
+    case ARG_POINTER_REGNUM: dbgprintf ("%d=ARG_PTR_R ", from); break;
+    case HARD_SP_REGNUM: dbgprintf ("%d=HARD_SP_R ", from); break;
+    case FRAME_POINTER_REGNUM: dbgprintf ("%d=FR_PTR_R ", from); break;
+    default: dbgprintf ("%d=dunno? ", from); break;
+    }
+}
+
+/* Define the offset between two registers, one to be eliminated, and the
+   other its replacement, at the start of a routine.
+   MGB return values as they are AFTER the prolog */
+int tms9900_initial_elimination_offset (int from,
+                                        int to)
+{
+  /*  
+      [argn]
+      .
+      [arg0]
+      . <- arg pointer
+      [saved regs]
+      [frame]
+      . <- stack pointer
+      . <- frame pointer
+  */
+
+  // dbgprintf("%s savedregs=%d frame=%d ", __func__,
+  //     tms9900_get_saved_reg_size(), get_frame_size());
+  // print_arg_offset (from);
+  // print_arg_offset (to);
+  int ret = 0;
+  if (from == ARG_POINTER_REGNUM && to == HARD_SP_REGNUM)
+  {
+    ret =(tms9900_get_saved_reg_size()+
+           get_frame_size ());
+  }
+  if (from == FRAME_POINTER_REGNUM && to == HARD_SP_REGNUM)
+  {
+    ret = 0;
+  }
+  if (from == ARG_POINTER_REGNUM && to == FRAME_POINTER_REGNUM)
+  {
+    ret =(tms9900_get_saved_reg_size()+
+           get_frame_size ());
+  }
+  // dbgprintf ("%s res=%d\n", __func__, ret);
+  return ret;
+}
+
+
+/* Determine if an address is represented using a valid expression */
+int legitimate_address_p (enum machine_mode mode,
+                          rtx address)
+{
+    GO_IF_LEGITIMATE_ADDRESS(mode, address, win);   
+    return 0;
+    
+  win:
+    return 1;
+}
+
+
+/* Determine the memory operand type
+   returns : 0 - Not a memory operand
+             1 - Register indirect : *Rn
+             2 - Post increment    : *Rn+
+             3 - Indexed register  : @INDEX(Rn)
+*/
+int tms9900_address_type(rtx op,
+                         enum machine_mode mode ATTRIBUTE_UNUSED)
+{
+  rtx addr;
+
+  /* Eliminate non-memory operations */
+  if (GET_CODE (op) != MEM)
+    return 0;
+
+  /* Decode the address now.  */
+indirection:
+  addr = XEXP (op, 0);
+  switch (GET_CODE (addr))
+  {
+    case REG:
+      /* Register indirect: *Rn */
+      return 1;
+	
+    case POST_INC:
+      /* Post increment: *Rn+ */
+      return 2;
+	
+    case MEM:
+      /* Yes, we know this is a memory expression.
+         Strip this code and try again */
+      op=addr;
+      goto indirection;
+	
+    case CONST_INT:
+    case LABEL_REF:	       
+    case CONST:
+    case SYMBOL_REF:
+      /* Indexed register : @ADDRESS(R0) - extra word required */
+
+    case PLUS:
+      /* Indexed register : @INDEX(Rn) - extra word required */
+      return 3;
+
+    default:
+      break;
+  }
+    
+  /* We should never get here, but we need to return something */
+  return 0;
+}
+
+
+/* Emit a branch condtional instruction */
+const char* output_branch (const char *pos, const char *neg, int length)
+{
+    static int label_id = 0;
+    
+    static char buf[1000];
+    length -= 10;
+    if(length == 2)
+    {
+        sprintf(buf, "%s  %%l0",pos);
+    }
+    else if(length == 4)
+    {
+        if(*pos == 'L')
+            sprintf(buf, "jlt  %%l0\n"
+                         "\tjeq  %%l0");
+        else if(*pos == 'G')
+            sprintf(buf, "jgt  %%l0\n"
+                         "\tjeq  %%l0");
+        else
+            gcc_unreachable();
+    }
+    else if(length == 6)
+    {
+	sprintf(buf, "%s  JMP_%d\n"
+                     "\tb    @%%l0\n"
+                     "JMP_%d", neg, label_id, label_id);	
+	label_id++;
+    }
+    else if(length == 8)
+    {
+        if(*neg == 'L')
+            sprintf(buf, "jlt  JMP_%d\n"
+                         "\tjeq  JMP_%d\n"
+                         "\tb    @%%l0\n"
+                         "JMP_%d", label_id, label_id, label_id);
+        else if(*neg == 'G')
+            sprintf(buf, "jgt  JMP_%d\n"
+                         "\tjeq  JMP_%d\n"
+                         "\tb    @%%l0\n"
+                         "JMP_%d", label_id, label_id, label_id);
+        else
+            gcc_unreachable();
+
+	label_id++;
+    }
+    else
+    {
+	gcc_unreachable();
+    }    
+    return buf;
+}
+
+
+/* Emit a jump instrcution */
+const char* output_jump (int length)
+{
+    length -= 10;
+    switch(length)    
+    {
+        case 2: return("jmp  %l0");
+        case 4: return("b    @%l0");
+        default: gcc_unreachable();
+    }
+}
+
+/* Determine if an instruction will update the conditional
+   flag as a side effect. This is used to eliminate unnneded
+   comparison instructions */
+void notice_update_cc_on_set(rtx exp, rtx insn ATTRIBUTE_UNUSED)
+{
+  if (GET_CODE (SET_DEST (exp)) == CC0)
+  {
+    cc_status.flags = 0;					
+    cc_status.value1 = SET_DEST (exp);			
+    cc_status.value2 = SET_SRC (exp);			
+  }
+  else if((GET_MODE (SET_DEST(exp)) == HImode ||
+           GET_MODE (SET_DEST(exp)) == QImode)
+          &&
+          (GET_CODE(SET_SRC(exp)) == PLUS  ||
+           GET_CODE(SET_SRC(exp)) == MINUS ||
+           GET_CODE(SET_SRC(exp)) == AND   ||
+           GET_CODE(SET_SRC(exp)) == IOR   ||
+           GET_CODE(SET_SRC(exp)) == XOR   ||
+           GET_CODE(SET_SRC(exp)) == NOT   ||
+           GET_CODE(SET_SRC(exp)) == NEG   ||
+           GET_CODE(SET_SRC(exp)) == ABS   ||
+           GET_CODE(SET_SRC(exp)) == REG   ||
+           GET_CODE(SET_SRC(exp)) == MEM))
+  {
+    cc_status.flags = 0;
+    cc_status.value1 = SET_SRC (exp);
+    cc_status.value2 = SET_DEST (exp);
+  }
+  else
+  {  
+    /* This last else is a bit paranoid, but since nearly all
+       instructions play with condition codes, it's reasonable. */
+    CC_STATUS_INIT;
+  }		        
+}
+
+/* A C statement to output to the stdio stream STREAM an assembler
+   instruction to assemble a string constant containing the LEN bytes
+   at PTR.  PTR will be a C expression of type `char *' and LEN a C
+   expression of type `int'. */
+void tms9900_output_ascii(FILE* stream, const char* ptr, int len)
+{
+   int i;
+   int in_text = 0;
+   int count = 0;
+   for (i = 0; i < len; i++)
+   {
+      int c = *ptr++;
+      if (ISPRINT(c))
+      {
+         /* End TEXT statement */
+         if (in_text && count==64)
+         {
+            fprintf (stream, "'\n");
+            in_text = 0;
+            count = 0;
+         }
+
+         /* Start TEXT statement */
+         if(in_text == 0)
+         {
+            fprintf (stream, "\ttext '");
+            in_text = 1;
+         }
+         putc (c, stream);
+         count++;
+         if(c == '\'') putc (c, stream);
+      }
+      else
+      {
+         /* Close TEXT statement */
+         if(in_text == 1)
+         {
+            fprintf (stream, "'\n");
+            in_text = 0;
+         }
+
+         /* Handle non-printable characters by inlining BYTE constants*/
+         fprintf (stream, "\tbyte %d\n", (unsigned char)c);
+      }
+   }
+
+   /*  If we ran out of input before we had closed the text, close it now */
+   if(in_text == 1)
+      fprintf (stream, "'\n");
+}
+
+void tms9900_expand_prologue (void)
+{
+   /* Find non-volatile registers which need to be saved */
+   int saveregs[MAX_SAVED_REGS];
+   int regcount = tms9900_get_regs_to_save (saveregs);
+   int frame_size = get_frame_size();
+
+   dbgprintf("%s saving regs=%d frame=%d\n", __func__, regcount, frame_size);
+   if (regcount > 2)
+   {
+      /* Allocate stack space for saved regs if more than 2 saved. */
+      /*
+      ai sp, -regs*2        4      14+8+8   = 30
+      mov sp, r0            2      14+8     = 22
+      mov r9 , *r0+         2      14+8+8+8 = 38
+      mov r13, *r0+         2      14+8+8+8 = 38
+      mov r14, *r0+         2      14+8+8+8 = 38
+      mov r15, *r0+         2      14+8+8+8 = 38
+      mov r11, *r0          2      14+8+8+8 = 34
+      ai sp, -frame         4      14+8+8   = 30
+      */
+      /* Emit "ai sp, -regcount*2" */
+      emit_insn(gen_addhi3(stack_pointer_rtx, stack_pointer_rtx, 
+                          GEN_INT(-regcount * 2)));
+
+      /* Copy sp to r0 and use r0 as the dest
+       * with auto-inc */
+
+      /* Emit "mov sp, r0" */
+      emit_insn(gen_movhi(gen_rtx_REG(HImode, HARD_R0_REGNUM),
+                          stack_pointer_rtx));
+
+      for (int i = 0; i < regcount; i++)
+      {
+         /*  Don't postinc if last reg */
+         if(i == regcount-1)
+         {
+            /* Emit "mov Rx, *R0" */
+            emit_insn(gen_movhi(
+            gen_rtx_MEM(HImode, gen_rtx_REG(HImode, HARD_R0_REGNUM)),
+                        gen_rtx_REG(HImode, saveregs[i])));
+         }
+         else
+         {
+            /* Emit "mov Rx, *R0+" */
+            emit_insn(gen_movhi(
+            gen_rtx_MEM(HImode, 
+                        gen_rtx_POST_INC(HImode, 
+                            gen_rtx_REG(HImode, HARD_R0_REGNUM))),
+                        gen_rtx_REG(HImode, saveregs[i])));
+         }
+      }
+   }
+   else
+   {
+      /* Save registers and create stack frame.  Since we currently only save up to 2 regs,
+       * we use dect instead of ai for the sp.  NOTE we must store regs in
+       * reverse order if doing it this way.  */
+      /*
+      dect sp               3      10+6     = 16
+      mov r11, *sp          2      14+8+8+8 = 38
+      dect sp               3      10+6     = 16
+      mov r14, *sp          2      14+8+8+8 = 38
+      ai sp, -frame         4      14+8+8   = 30
+      */
+      for (int i = regcount-1; i >= 0; i--)
+      {
+         dbgprintf("%s save R%d\n", __func__, saveregs[i]);
+         /* Emit "dect sp" */
+         emit_insn(gen_addhi3(stack_pointer_rtx, stack_pointer_rtx, GEN_INT(-2)));
+
+         /* Emit "mov Rx, *SP" */
+         emit_insn(gen_movhi(
+                     gen_rtx_MEM(HImode, stack_pointer_rtx),
+                     gen_rtx_REG(HImode, saveregs[i])));
+      }
+   }
+
+   if(frame_size > 0)
+   {
+      dbgprintf("%s alloc frame %d\n", __func__, frame_size);
+      /* Emit "ai sp, -framesize" */
+      emit_insn(gen_addhi3(stack_pointer_rtx, stack_pointer_rtx, 
+                          GEN_INT(-frame_size)));
+   }
+
+   /* Set frame pointer */
+   if(frame_pointer_needed)
+   {
+      dbgprintf("%s set fp\n", __func__);
+      /* Emit "mov sp, bp" */
+      emit_insn(gen_movhi(gen_rtx_REG(HImode, FRAME_POINTER_REGNUM),
+                          stack_pointer_rtx));
+   }
+
+   dbgprintf("%s done\n", __func__);
+}
+
+void tms9900_expand_epilogue (bool is_sibcall)
+{
+   /*
+   ai sp, frame         4      14+8+8   = 30
+   mov *sp+, r14        2      14+8+8+8 = 38
+   mov *sp+, r11        2      14+8+8+8 = 38
+   */
+
+   /* Find frame size to restore */
+   int frame_size = get_frame_size();
+
+   if(frame_size != 0)
+   {
+      dbgprintf("%s delete frame size=%d\n", __func__, frame_size);
+      /* Emit "ai sp, frame_size" */
+      emit_insn(gen_addhi3(stack_pointer_rtx, stack_pointer_rtx, 
+                           GEN_INT(frame_size)));
+   }
+
+   /* Find non-volatile registers which need to be restored */
+   int saveregs[MAX_SAVED_REGS];
+   int regcount = tms9900_get_regs_to_save (saveregs);
+   int i = 0;
+
+   for (i = 0; i < regcount; i++)
+   {
+      dbgprintf("%s restore R%d\n", __func__, saveregs[i]);
+      /* Emit "mov *SP+, Rx" */
+      emit_insn(gen_movhi(
+         gen_rtx_REG(HImode, saveregs[i]),
+         gen_rtx_MEM(HImode, 
+                     gen_rtx_POST_INC(HImode, stack_pointer_rtx))));
+   }
+   
+   if(!is_sibcall)
+   {
+      // dbgprintf("%s return\n", __func__);
+      /* Emit the return instruction "b *R11" */
+      emit_insn(gen_rtx_UNSPEC(HImode, 
+                               gen_rtvec (1, gen_rtx_REG(HImode, HARD_R11_REGNUM)),
+                               UNSPEC_RETURN));
+   }
+   dbgprintf("%s done\n", __func__);
+}
+
+/* All registers may be used as a base, except R0 or 
+   pseudoregs when we are in strict mod */
+int tms9900_reg_ok_for_base(int strict, rtx reg)
+{
+  return(!strict || 
+         (REGNO(reg) !=0 && REGNO(reg) <= HARD_R15_REGNUM));
+}
+
+/* Determine if the specified address is a valid operand */
+int tms9900_go_if_legitimate_address(enum machine_mode mode ATTRIBUTE_UNUSED, rtx operand, int strict)
+{
+  /* Accept *R0 */
+  if (GET_CODE (operand) == REG &&
+      tms9900_reg_ok_for_base(strict, operand))
+    return 1;
+
+  /* Accept *R0+ */
+  if (GET_CODE (operand) == POST_INC      &&
+      GET_CODE (XEXP (operand, 0)) == REG &&
+      tms9900_reg_ok_for_base(strict, XEXP (operand, 0)))
+    return 1;
+
+  /* Accept @xxxx */
+  if (CONSTANT_ADDRESS_P (operand))
+    return 1;
+
+  /* Accept @xxxx(R0)*/
+  if (GET_CODE (operand) == PLUS            &&
+      GET_CODE (XEXP (operand, 0)) == REG   &&
+      tms9900_reg_ok_for_base(strict, XEXP (operand, 0)) &&
+      CONSTANT_ADDRESS_P (XEXP (operand, 1)))
+    return 1;
+
+  /* Accept @(symbol+xxxx)(R0)*/
+/*
+  if(GET_CODE (operand) == PLUS )
+  {
+    if(GET_CODE(XEXP(operand,0)) == MEM)
+    {
+      rtx op = XEXP(operand,0);
+      op = XEXP(op, 0);
+      if(GET_CODE (op) == PLUS             &&
+         GET_CODE (XEXP (op, 0)) == REG    &&
+         tms9900_reg_ok_for_base(strict, XEXP (op, 0))  &&
+         CONSTANT_ADDRESS_P (XEXP (op, 1)) &&
+         CONSTANT_ADDRESS_P(XEXP(operand, 1)))
+      {
+        return 1;
+      }
+    }
+  }
+*/
+  /* Anything else is invalid */
+// printf("MGB not legit add : ");
+// print_inline_rtx (stdout, operand, 0);
+// printf("\n");
+  return 0;
+}
+
+
+/* All aggregate types or types larger than four bytes which are
+   to be passsed by value are silently copied to the stack and 
+   then passed by reference. */
+static bool
+tms9900_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,
+                       enum machine_mode mode ATTRIBUTE_UNUSED,
+                       const_tree type, bool named ATTRIBUTE_UNUSED)
+{
+  unsigned int size;
+  if (type)
+    {
+      if (AGGREGATE_TYPE_P (type))
+        return(true);
+      size = int_size_in_bytes (type);
+    }
+  else
+    size = GET_MODE_SIZE (mode);
+  return(size > 4);
+}
+
+
+/* Output a difference of two labels that will be an assembly time
+   constant if the two labels are local.  (.long lab1-lab2 will be
+   very different if lab1 is at the boundary between two sections; it
+   will be relocated according to the second section, not the first,
+   so one ends up with a difference between labels in different
+   sections, which is bad in the dwarf2 eh context for instance.)  */
+void
+tms9900_asm_output_dwarf_delta (FILE *file, int size,
+                               const char *lab1, const char *lab2)
+{
+  int islocaldiff = (lab1[0] == '*' && lab1[1] == 'L'
+                     && lab2[0] == '*' && lab2[1] == 'L');
+  const char *directive = "data";
+  islocaldiff=1;
+  if(size > 2) fprintf(file,"\n\tdata 0\n",size);
+  if (islocaldiff)
+    fprintf (file, "\t.set L$set$%d,", tms9900_dwarf_label_counter);
+  else
+    fprintf (file, "\t%s\t", directive);
+  assemble_name_raw (file, lab1);
+  fprintf (file, "-");
+  assemble_name_raw (file, lab2);
+  if (islocaldiff)
+    fprintf (file, "\n\t%s L$set$%d", directive, tms9900_dwarf_label_counter++);
+}
+
+
+/* Output an offset from a label for use in a dwarf record */
+void tms9900_asm_output_dwarf_offset (FILE *file, int size, const char * lab,
+                                section *base)
+{
+  char sname[64];
+  sprintf(sname, "%s",&base->named.name[0]);
+  tms9900_asm_output_dwarf_delta (file, size, lab, sname);
+}
+
+
+/* Output an integer value of a specified size and alignemnt */
+static bool
+tms9900_asm_integer(rtx x, unsigned int size, int aligned_p)
+{
+  if(!aligned_p)
+  {
+    if(GET_CODE(x) == CONST_INT)
+    {
+      unsigned int value = INTVAL(x);
+      int i;
+      fprintf(asm_out_file, "\tbyte\t");
+      for(i = size-1; i>=1; i--)
+      {
+        fprintf(asm_out_file, "0x%X,", (value >> (i*8)) & 0xFF);        
+      }
+      fprintf(asm_out_file, "0x%X", value & 0xFF);
+      return true;
+    }
+  }
+  return default_assemble_integer(x,size,1);
+}
+
+
+//==================================================================
+// Code for tms9900_subreg pass
+
+
+#include "tree-pass.h"
+#include "basic-block.h"
+#include "rtl.h"
+
+static void
+tms9900_extract_subreg(rtx insn, rtx arg, rtx* parg)
+{
+  dbgprintf("%s\n", __func__);
+  if(BINARY_P(arg))
+  {
+    dbgprintf("%s recurse\n", __func__);
+    /* Recurse until we find a leaf expression */
+    tms9900_extract_subreg(insn, XEXP(arg,0), &XEXP(arg,0));
+    tms9900_extract_subreg(insn, XEXP(arg,1), &XEXP(arg,1));
+  }
+  else
+
+  {
+    if(GET_CODE(arg) == SUBREG && GET_MODE(arg) == QImode)
+    {
+      dbgprintf ("%s creating extract\n", __func__);
+      /* Found a subreg expression we need to extract.
+         Place it in a seperate instruction before this one */
+      rtx temp_reg = gen_reg_rtx(QImode);
+      rtx extract = gen_rtx_SET(QImode, temp_reg, arg);
+
+      if(dump_file)
+      {
+        fprintf(dump_file, "\nModifying insn %d, extracting subreg to new instruction %d\n",
+                INSN_UID(insn), INSN_UID(extract));
+      }
+
+      // print_inline_rtx (stdout, extract, 0);
+      /* Replace expression in instruction with our new temp register */
+      memcpy(parg, &temp_reg, sizeof(rtx));
+      emit_insn_before(extract, insn);
+
+      if(dump_file)
+      {
+        fprintf(dump_file, "New sequence:\n");
+        print_rtl_single(dump_file, extract);
+        print_rtl_single(dump_file, insn);
+      }
+    }
+  }
+}
+
+static bool
+gate_tms9900_subreg (void)
+{
+  return true;
+}
+
+static unsigned int
+tms9900_subreg (void)
+{
+  dbgprintf("%s disabled\n", __func__);
+  return 0;
+  basic_block bb;
+  rtx insn;
+
+  FOR_EACH_BB (bb)
+    FOR_BB_INSNS (bb, insn)
+    {
+    dbgprintf("%s looping\n", __func__);
+    if (INSN_P (insn))
+    {
+      dbgprintf("%s get single_set\n", __func__);
+      rtx set=single_set (insn);
+      if(set !=NULL)
+      {
+        /* We only need to handle cases where there may be
+           subreg expressions in an operation in the source
+           argument. Unary expressions are already handled
+           in the machine description. */
+        rtx src=SET_SRC(set);
+        if(BINARY_P(src))
+        {
+          tms9900_extract_subreg(insn, XEXP(src,0), &XEXP(src,0));
+          tms9900_extract_subreg(insn, XEXP(src,1), &XEXP(src,1));
+        }
+      }
+    }
+    else
+      dbgprintf("%s not INSN_P\n", __func__);
+    }
+
+  dbgprintf("%s done\n", __func__);
+  return 0;
+}
+
+
+struct rtl_opt_pass pass_tms9900_subreg =
+{
+ {
+  RTL_PASS,
+  "tms9900_subreg",                     /* name */
+  gate_tms9900_subreg,                  /* gate */
+  tms9900_subreg,                       /* execute */
+  NULL,                                 /* sub */
+  NULL,                                 /* next */
+  0,                                    /* static_pass_number */
+  0,                                    /* tv_id */
+  0,                                    /* properties_required */
+  0,                                    /* properties_provided */
+  0,                                    /* properties_destroyed */
+  0,                                    /* todo_flags_start */
+  TODO_dump_func |
+  TODO_ggc_collect                      /* todo_flags_finish */
+ }
+};
+
+//==================================================================
+// Code for tms9900_postinc pass
+
+/* last instruction to use target register */
+struct reg_last_used {
+  rtx insn;
+  int regnum;
+  int is_deref;
+  int mode;
+  rtx parent;
+  int argnum;
+};
+
+static struct reg_last_used reg_last_insn[1024] = {0};
+
+
+static bool
+gate_tms9900_postinc(void)
+{
+  return true;
+}
+
+
+/* Find an instruction which uses a form like *(register+constant) we could 
+   merge via pointer postincrement in an earlier instruction.*/
+static void
+tms9900_find_merge_insn(rtx insn, rtx parent, int argnum, rtx arg)
+{
+    // printf ("%s code=%s \n", __func__, GET_RTX_NAME(GET_CODE(arg)));
+  if(MEM_P(arg))
+  {
+    rtx expr = XEXP(arg,0);
+   //  printf ("%s expr=%s \n", __func__, GET_RTX_NAME(GET_CODE(expr)));
+    if(GET_CODE(expr) == PLUS)
+    {
+      rtx val1 = XEXP(expr,0);
+      rtx val2 = XEXP(expr,1);
+      int offset;
+      int regnum = -1;
+      rtx reg;
+
+      /* Isolate regnum and offset in sum */
+      if(CONST_INT_P(val1) && REG_P(val2))
+      {
+         offset = INTVAL(val1);
+         regnum = REGNO(val2);
+         reg = val2;
+      }
+      else if(CONST_INT_P(val2) && REG_P(val1))
+      {
+         offset = INTVAL(val2);
+         regnum = REGNO(val1);
+         reg = val1;
+      }
+
+   //  printf ("%s reg=%d off=%d dead=%s\n", __func__, regnum, offset,
+   //  find_regno_note(insn, REG_DEAD, regnum)?"yes":"no");
+
+      if((regnum >= 0) && 
+         (offset == 2 || offset == 1) &&
+         (find_regno_note(insn, REG_DEAD, regnum)))
+      {
+        /* Found an indexed address with a small offset, investigate further */
+        struct reg_last_used *last = &reg_last_insn[regnum];
+        // if(dump_file)
+        // {
+         //  printf("POSTINC Possible merge candidate insn %d:\n", INSN_UID(insn));
+          // print_rtl_single(dump_file, insn);
+          // printf("POSTINC Last use of reg %d was in insn %d:\n", regnum, INSN_UID(last->insn));
+          // print_rtl_single(dump_file, last->insn);
+       // }
+
+        if((last->is_deref) && (GET_MODE_SIZE(last->mode) == offset))
+        {
+          /* Modify previous instruction to use postincrement */
+          rtx temp_inc = gen_rtx_POST_INC(last->mode, reg);
+          rtx temp_arg = gen_rtx_MEM(last->mode,temp_inc); 
+          memcpy(XEXP(last->parent, last->argnum), temp_arg, rtx_size(temp_arg));
+
+          /* Modify this instruction to remove index */
+          temp_arg = gen_rtx_MEM(last->mode,reg); 
+          memcpy(XEXP(parent, argnum), temp_arg, rtx_size(temp_arg));
+
+          // if(dump_file) 
+          // {
+            // fprintf(stdout,"; POSTINC Modified instruction %d:\n",INSN_UID(last->insn));
+            // print_rtl_single(dump_file,last->insn);
+          // }
+        }
+        // else fprintf(stdout, "; POSTINC Cannot merge\n");
+        return;
+      }
+    }
+  }
+
+  if(BINARY_P(arg))
+  {
+    /* This is a binary expression, check the children */
+    tms9900_find_merge_insn(insn, arg, 0, XEXP(arg,0));
+    tms9900_find_merge_insn(insn, arg, 1, XEXP(arg,1));
+  }
+  else
+  {
+    /* This is a leaf expression. Note the register used here for later */
+    int is_deref = 0;
+    if(MEM_P(arg))
+    {
+      arg = XEXP(arg,0);
+      is_deref = 1;
+    }
+    if(REG_P(arg))
+    {
+      int index = REGNO(arg);
+      reg_last_insn[index].insn = insn;
+      reg_last_insn[index].is_deref = is_deref;
+      reg_last_insn[index].mode = GET_MODE(arg);     
+      reg_last_insn[index].regnum = REGNO(arg);
+      reg_last_insn[index].parent = parent;
+      reg_last_insn[index].argnum = argnum;
+    }
+  }
+}
+
+
+static unsigned int
+tms9900_postinc (void)
+{
+  basic_block bb;
+  rtx insn;
+  int i;
+
+  dbgprintf("%s\n", __func__);
+  FOR_EACH_BB (bb)
+  {
+    memset(reg_last_insn, 0, sizeof(reg_last_insn));
+    FOR_BB_INSNS (bb, insn)
+    {
+  // fprintf(asm_out_file, "; %s loop\n", __func__);
+      if (INSN_P (insn))
+      {
+        rtx set=single_set (insn);
+        if(set !=NULL)
+        {
+          /* Look for memory references of the form *(costant+reg) */
+          tms9900_find_merge_insn(insn, set, 0, SET_DEST(set));
+          tms9900_find_merge_insn(insn, set, 1, SET_SRC(set));
+        }
+      }
+    }
+  }
+  dbgprintf("%s done\n", __func__);
+  return 0;
+}
+
+
+struct rtl_opt_pass pass_tms9900_postinc =
+{
+ {
+  RTL_PASS,
+  "tms9900_postinc",                    /* name */
+  gate_tms9900_postinc,                 /* gate */
+  tms9900_postinc,                      /* execute */
+  NULL,                                 /* sub */
+  NULL,                                 /* next */
+  0,                                    /* static_pass_number */
+  0,                                    /* tv_id */
+  0,                                    /* properties_required */
+  0,                                    /* properties_provided */
+  0,                                    /* properties_destroyed */
+  0,                                    /* todo_flags_start */
+  TODO_dump_func |
+  TODO_ggc_collect                      /* todo_flags_finish */
+ }
+};
+
+// MGB additions start here - mostly for debug
+
+/*  Check if there is a byte offset correction needed for an operand.  If
+ *  operand is a register and REGNO matches ORIGINAL_REGNO and offset is non
+ *  zero then a correction is needed.  -1 indicates an extend is needed, +1
+ *  indicates a truncate is needed. */
+extern bool tms9900_operand_subreg_offset (rtx operand, int mode)
+{
+  /*  If the source operand is not a register or does not have an offset of
+   *  minus 1 byte then no action required */
+  // if (!REG_P (operand) || (REG_OFFSET (operand) % 2) == 0)
+  // if (!REG_P (operand) || REG_OFFSET (operand) != -1)
+  if (!REG_P (operand) || REG_OFFSET (operand) == 0)
+    return false;
+
+  int offset = REG_OFFSET (operand);
+
+  // Bypass debug flag and put direct to file
+  // tms9900_inline_debug ("; reg/reg=%d/%d expr=%d\n", REGNO(operand),
+  fprintf (asm_out_file, "; SUBR off=%ld mode=%s reg/reg=%d/%d\n",
+           REG_OFFSET (operand), GET_MODE_NAME (mode),
+           REGNO(operand), ORIGINAL_REGNO(operand));
+
+  if (mode == QImode && offset != 1)
+    return false;
+
+  if (mode == HImode && offset != -1)
+    return false;
+
+  /*  If the source register is not the original register, and the original is a
+   *  mem expression, then the offset refers to something else, so we can ignore
+   *  this case */
+  if (ORIGINAL_REGNO (operand) != REGNO (operand))
+      //  && REG_EXPR (operand))
+  {
+    tms9900_debug_operands ("REG_EXPR", operand, NULL, 0);
+    return false;
+  }
+
+  // tms9900_inline_debug ("; correct required\n");
+  fprintf (asm_out_file, "; SUBR correction required\n");
+  /*  Correction is needed */
+  return true;
+}
+
+/* Determine if it's legal to put X into the constant pool.  This
+   is not possible if X contains the address of a symbol that is
+   not constant (TLS) or not known at final link time (PIC).
+
+   MGB : This is probably overkill for us as we can't generate PIC code and
+   don't have threads but including it here for completeness 
+*/
+
+static bool
+tms9900_cannot_force_const_mem (rtx x)
+{
+  // printf("%s code=%s\n", __func__, GET_RTX_NAME(GET_CODE(x)));
+  switch (GET_CODE (x))
+    {
+    case CONST_INT:
+    case CONST_DOUBLE:
+    case CONST_VECTOR:
+    case LABEL_REF:
+    case SYMBOL_REF:
+      /* Accept all non-symbolic constants.  */
+      return false;
+#if 0
+    case LABEL_REF:
+      /* Labels are OK iff we are non-PIC.  */
+      return flag_pic != 0;
+
+    case SYMBOL_REF:
+      /* 'Naked' TLS symbol references are never OK,
+	 non-TLS symbols are OK iff we are non-PIC.  */
+      if (SYMBOL_REF_TLS_MODEL (x))
+	return true;
+      else
+	return flag_pic != 0;
+#endif
+    case CONST:
+      return tms9900_cannot_force_const_mem (XEXP (x, 0));
+    case PLUS:
+    case MINUS:
+      return tms9900_cannot_force_const_mem (XEXP (x, 0))
+         || tms9900_cannot_force_const_mem (XEXP (x, 1));
+    case UNSPEC:
+      return true;
+    default:
+      gcc_unreachable ();
+    }
+}
+
+/* Determine if a given RTX is a valid constant.  We already know this
+   satisfies CONSTANT_P.  */
+
+bool
+tms9900_legitimate_constant_p (rtx x)
+{
+  // printf ("%s x=%s\n", __func__, GET_RTX_NAME(GET_CODE(x)));
+  return true;
+}
+
+/* Determine if a given RTX is a valid constant address.  */
+
+bool
+tms9900_constant_address_p (rtx x)
+{
+  // printf ("%s x=%s\n", __func__, GET_RTX_NAME(GET_CODE(x)));
+  switch (GET_CODE (x))
+    {
+    case LABEL_REF:
+    case CONST_INT:
+    case HIGH:
+      return true;
+
+    case CONST:
+    case SYMBOL_REF:
+      return tms9900_legitimate_constant_p (x);
+
+    default:
+      return false;
+    }
+}
+
+#include <stdlib.h>
+#include <stdarg.h>
+
+extern void tms9900_inline_debug (const char *fmt,...)
+{
+#ifndef TMS9900_INLINE_DEBUG
+    return;
+#endif
+    if (!TARGET_TI99_INLINE_RTL)
+        return;
+
+    va_list ap;
+
+    va_start (ap, fmt);
+    vfprintf (asm_out_file, fmt, ap);
+    va_end (ap);
+}
+
+extern void tms9900_debug_operands (const char *name, rtx insn, rtx ops[], int count)
+{
+#ifndef TMS9900_INLINE_DEBUG
+    return;
+#endif
+
+    if (!TARGET_TI99_INLINE_RTL)
+        return;
+
+    static int refcount;
+    if (insn)
+    {
+        fprintf(asm_out_file, "\n; %s-%d : ", name, INSN_UID(insn));
+        print_inline_rtx (asm_out_file, insn, 0);
+        fprintf(asm_out_file, "\n\n");
+    }
+    else
+    {
+        fprintf(asm_out_file, "\n; %s-expand-%d\n", name, ++refcount);
+        for (int i = 0; i < count; i++)
+        {
+            fprintf(asm_out_file, "; OP%d : ", i);
+
+            /* For print_inline_rtx to prefix its output with a comment indicator.
+             * This is similar to passing -dP to gcc but more specific to our needs
+             */
+            extern const char *print_rtx_head;
+            print_rtx_head = "; ";
+
+            print_inline_rtx (asm_out_file, ops[i], 0);
+            fprintf (asm_out_file, "code=[%s:%s]\n", GET_RTX_NAME(GET_CODE(ops[i])),
+                     GET_MODE_NAME (GET_MODE (ops[i])));
+        }
+    }
+}
+
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/tms9900.h gcc-4.4.0/gcc/config/tms9900/tms9900.h
--- gcc-4.4.0-orig/gcc/config/tms9900/tms9900.h	2024-07-28 14:42:12.629792725 +0100
+++ gcc-4.4.0/gcc/config/tms9900/tms9900.h	2024-10-06 08:31:27.002723881 +0100
@@ -0,0 +1,1247 @@
+/* Definitions of target machine for GNU compiler.
+   Texas Instruments TMS9900
+   Copyright (C) 2009
+
+Copyright 2009 Eric Welser (EMW)
+Copyright 2023 Mark Burkley (MGB)
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.
+*/
+
+/*****************************************************************************
+**
+** Controlling the Compilation Driver, `gcc'
+**
+*****************************************************************************/
+
+#undef ENDFILE_SPEC
+
+/* Define this for front-ended changes */
+#define TMS9900
+
+/* Options to pass to the assembler */
+#ifndef ASM_SPEC
+#define ASM_SPEC ""
+#endif
+
+/* Options for the linker. 
+   We need to tell the linker the target elf format.
+   This can be overridden by -Wl option of gcc.  */
+#ifndef LINK_SPEC
+#define LINK_SPEC "-m tms9900"
+#endif
+
+/* More linker options, these are used at the beginning of the command */
+#undef STARTFILE_SPEC
+/*#define STARTFILE_SPEC "crt1%O%s"*/
+#define STARTFILE_SPEC ""
+
+/* More linker options, used at the end of the command string */
+#ifndef LIB_SPEC
+#define LIB_SPEC       ""
+#endif
+
+/* Options to pass to CC1 and other language front ends */
+#ifndef CC1_SPEC
+#define CC1_SPEC       ""
+#endif
+
+/* Options to pass to the C Preprocessor */
+#ifndef CPP_SPEC
+#define CPP_SPEC ""
+#endif
+
+// MGB TODO
+// Setting to 0 or 1 makes no difference to string constants - they are always
+// emitted before the function.  Int consts are currently never emitted but it
+// doesn't logically make sense to emit them before as they haven't been defined
+// yet???  They have if use expand or split so undefning now.
+// #define CONSTANT_POOL_BEFORE_FUNCTION	0
+
+/* Names to predefine in the preprocessor for this target machine.  */
+#define TARGET_CPU_CPP_BUILTINS()		\
+  do						\
+    {						\
+      builtin_define_std ("tms9900");		\
+    }						\
+  while (0)
+
+/* As an embedded target, we have no libc.  */
+//#ifndef inhibit_libc
+//#  define inhibit_libc
+//#endif
+
+/* Forward type declaration for prototypes definitions.
+   rtx_ptr is equivalent to rtx. Can't use the same name.  */
+struct rtx_def;
+typedef struct rtx_def *rtx_ptr;
+
+union tree_node;
+typedef union tree_node *tree_ptr;
+
+/* We can't declare enum machine_mode forward nor include 'machmode.h' here.
+   Prototypes defined here will use an int instead. It's better than no
+   prototype at all.  */
+typedef int enum_machine_mode;
+
+/*****************************************************************************
+**
+** Run-time Target Specification
+**
+*****************************************************************************/
+
+/* Run-time compilation parameters selecting different hardware subsets.  */
+
+extern short *reg_renumber;	/* def in local_alloc.c */
+
+#define TARGET_OP_TIME		(optimize && optimize_size == 0)
+#define TARGET_RELAX            (TARGET_NO_DIRECT_MODE)
+
+/* Default target_flags if no switches specified.  */
+#ifndef TARGET_DEFAULT
+# define TARGET_DEFAULT		0
+#endif
+
+#define OVERRIDE_OPTIONS override_options ()
+
+/* Define this macro as a C expression for the initializer of an
+   array of string to tell the driver program which options are
+   defaults for this target and thus do not need to be handled
+   specially when using `MULTILIB_OPTIONS'.  */
+#ifndef MULTILIB_DEFAULTS
+# define MULTILIB_DEFAULTS { "tms9900" }
+#endif
+
+/* Print subsidiary information on the compiler version in use.  */
+#define TARGET_VERSION	fprintf (stderr, " (TMS9900)")
+
+
+/* Target machine storage layout */
+
+/* Define this as 1 if most significant byte of a word is the lowest numbered.  */
+#define BYTES_BIG_ENDIAN 	1
+
+/* Define this as 1 if most significant bit is lowest numbered
+   in instructions that operate on numbered bit-fields.  */
+#define BITS_BIG_ENDIAN         1
+
+/* Define this as 1 if most significant word of a multiword number is lowest numbered.  */
+#define WORDS_BIG_ENDIAN 	1
+
+/* Width of a word, in units (bytes).  */
+#define UNITS_PER_WORD		2
+
+/* Definition of size_t.  This is really an unsigned short as the
+   TMS9900 only handles a 64K address space.  */
+#define SIZE_TYPE               "short unsigned int"
+
+/* A C expression for a string describing the name of the data type
+   to use for the result of subtracting two pointers.  The typedef
+   name `ptrdiff_t' is defined using the contents of the string.
+   The TMS9900 only has a 64K address space.  */
+#define PTRDIFF_TYPE            "short int"
+
+/* Allocation boundary (bits) for storing pointers in memory.  */
+#define POINTER_BOUNDARY	16
+
+/* Normal alignment required for function parameters on the stack, in bits.
+   This can't be less than BITS_PER_WORD */
+#define PARM_BOUNDARY		(BITS_PER_WORD)
+
+/* Boundary (bits) on which stack pointer should be aligned.  */
+#define STACK_BOUNDARY		16
+
+/* Allocation boundary (bits) for the code of a function.  */
+#define FUNCTION_BOUNDARY	16
+
+/* Biggest alignment which, if violated, may cause a fault */
+#define BIGGEST_ALIGNMENT	16
+
+/* Alignment of field after `int : 0' in a structure.  */
+#define EMPTY_FIELD_BOUNDARY	16
+
+/* Every structure's size must be a multiple of this.  */
+#define STRUCTURE_SIZE_BOUNDARY 16
+
+/* Define this as 1 if instructions will fail to work if given data not
+   on the nominal alignment.  If instructions will merely go slower
+   in that case, do not define this macro.  */
+#define STRICT_ALIGNMENT	1
+
+/* An integer expression for the size in bits of the largest integer
+   machine mode that should actually be used.  All integer machine modes of
+   this size or smaller can be used for structures and unions with the
+   appropriate sizes.  */
+#define MAX_FIXED_MODE_SIZE	32
+
+/* target machine storage layout */
+
+/* Size (bits) of the type "int" on target machine */
+#define INT_TYPE_SIZE           16
+
+/* Size (bits) of the type "short" on target machine */
+#define SHORT_TYPE_SIZE		16
+
+/* Size (bits) of the type "long" on target machine */
+#define LONG_TYPE_SIZE		32
+
+/* Size (bits) of the type "long long" on target machine */
+#define LONG_LONG_TYPE_SIZE     64
+
+/* A C expression for the size in bits of the type `float' on the
+   target machine. If you don't define this, the default is one word.
+   Don't use default: a word is only 16.
+   MGB let's see if we can make floats and doubles the same size
+   MGB doesn't work - gcc assumes sizeof float == sizeof SI ? */
+#define FLOAT_TYPE_SIZE         64
+
+/* A C expression for the size in bits of the type double on the target
+   machine. If you don't define this, the default is two words.
+   Be IEEE compliant.  */
+#define DOUBLE_TYPE_SIZE        64
+
+#define LONG_DOUBLE_TYPE_SIZE   64
+
+/*  We don't have "floats" as in 32-bit floating point values (SFmode) but we do
+ *  have "doubles" as in 64-bit (DFmode). */
+#define LIBGCC2_HAS_SF_MODE 0
+#define LIBGCC2_HAS_DF_MODE 1
+
+/* Define this as 1 if `char' should by default be signed; else as 0.  */
+#define DEFAULT_SIGNED_CHAR	1
+
+/* A C expression for a string describing the name of the data type
+   to use for wide characters.  The typedef name `wchar_t' is defined
+   using the contents of the string.
+   
+   Define these to avoid dependence on meaning of `int'.
+   Note that WCHAR_TYPE_SIZE is used in cexp.y,
+   where TARGET_SHORT is not available.  */
+#define WCHAR_TYPE              "short int"
+#define WCHAR_TYPE_SIZE         16
+
+/* Standard register usage.  */
+
+#define HARD_REG_SIZE           (2)
+
+#define REGS_PER_WORD (UNITS_PER_WORD / HARD_REG_SIZE)
+
+/* Assign names to real TMS9900 registers. */
+#define HARD_R0_REGNUM		0
+#define HARD_R1_REGNUM		1
+#define HARD_R2_REGNUM		2
+#define HARD_R3_REGNUM		3
+#define HARD_R4_REGNUM		4
+#define HARD_R5_REGNUM		5
+#define HARD_R6_REGNUM		6
+#define HARD_R7_REGNUM		7
+#define HARD_R8_REGNUM		8
+#define HARD_R9_REGNUM		9
+#define HARD_R10_REGNUM		10
+#define HARD_R11_REGNUM		11
+#define HARD_R12_REGNUM		12
+#define HARD_R13_REGNUM		13
+#define HARD_R14_REGNUM		14
+#define HARD_R15_REGNUM		15
+
+/* Shift count register */
+#define HARD_SC_REGNUM		HARD_R0_REGNUM
+/* Base pointer */
+#define HARD_BP_REGNUM		HARD_R9_REGNUM
+/* Stack pointer */
+#define HARD_SP_REGNUM		HARD_R10_REGNUM
+/* Old PC after BL instruction */
+#define HARD_LR_REGNUM		HARD_R11_REGNUM
+/* static chain */
+#define HARD_CB_REGNUM		HARD_R12_REGNUM
+/* Arg pointer */
+#define HARD_AP_REGNUM		HARD_R13_REGNUM
+
+/* How to refer to registers in assembler output.  This sequence is indexed
+   by compiler's hard-register-number (see above). */
+#define REGISTER_NAMES \
+{ "r0",  "r1", "r2",  "r3",  "r4",  "r5",  "r6",  "r7",  \
+  "r8",  "r9", "r10", "r11", "r12", "r13", "r14", "r15"}
+
+/* Number of actual hardware registers. The hardware registers are assigned
+   numbers for the compiler from 0 to just below FIRST_PSEUDO_REGISTER. 
+   All registers that the compiler knows about must be given numbers, even
+   those that are not normally considered general registers.  */
+#define FIRST_PSEUDO_REGISTER	(16)
+
+/* NOTE - BP (R9) is not a fixed register and may be used as a general
+ * register by functions that do not require a stack frameo
+ */
+/* 1 for registers that have pervasive standard uses and are not available
+ * for the register allocator.  */
+#define FIXED_REGISTERS \
+  {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0}
+/* SC 1  2  3  4  5  6  7  8  BP SP LR CB AP 14 15*/
+
+/* MGB It seemed excessive to always preserve R13,R14,R15 as these will only
+ * have values to be saved if we were invoked by a BLWP which is never emitted
+ * by this backend.  I have removed them from the list.  If someone is writing
+ * an ISR / DSR which is invoked by a BLWP then we can ask them to save
+ * R13/R14/R15 themselves.
+ *
+ * It also seems counter-intuitive that LR should be identified as a call reg
+ * but gcc/reginfo.c will assert if any register is fixed and not a call reg.
+ *
+ * MGB JAN-24 I'm adding back in R12 thru R15 as preserved.  It actually
+ * seems to allow gcc to generate smaller code since leaf functions do not need
+ * to save them.  More testing needed to see which is actually more efficient.
+ */
+/* 0 for registers which must be preserved across function call boundaries */
+  // {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1}
+#define CALL_USED_REGISTERS \
+  {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0}
+/* SC 1  2  3  4  5  6  7  8  BP SP LR CB AP 14 15*/
+
+/* Define this macro to change register usage conditional on target flags. */
+#define CONDITIONAL_REGISTER_USAGE 
+
+/* List the order in which to allocate registers.  Each register must be
+   listed once, even those in FIXED_REGISTERS.  */
+#define REG_ALLOC_ORDER	\
+   {HARD_R1_REGNUM, HARD_R2_REGNUM, HARD_R3_REGNUM, HARD_R4_REGNUM,\
+    HARD_R5_REGNUM, HARD_R6_REGNUM, HARD_R7_REGNUM, HARD_R8_REGNUM,\
+    HARD_R14_REGNUM, HARD_R15_REGNUM, HARD_R12_REGNUM, HARD_SC_REGNUM,\
+    HARD_AP_REGNUM, HARD_BP_REGNUM, HARD_LR_REGNUM, HARD_SP_REGNUM}
+
+/* A C expression for the number of consecutive hard registers,
+   starting at register number REGNO, required to hold a value of
+   mode MODE.  */
+#define HARD_REGNO_NREGS(REGNO, MODE) \
+   ((GET_MODE_SIZE (MODE) + HARD_REG_SIZE - 1) / HARD_REG_SIZE)
+
+/* Value is 1 if hard register REGNO (or starting with REGNO) can hold a value of machine-mode MODE
+ */
+#define HARD_REGNO_MODE_OK(REGNO, MODE) \
+   (!(MODE == SImode && REGNO==HARD_R15_REGNUM))
+  
+/* A C expression that is nonzero if hard register number REGNO2 can be
+   considered for use as a rename register for REGNO1 */
+#define HARD_REGNO_RENAME_OK(REGNO1,REGNO2) 1
+
+/* Value is 1 if it is a good idea to tie two pseudo registers when one has
+   mode MODE1 and one has mode MODE2.  If HARD_REGNO_MODE_OK could produce
+   different values for MODE1 and MODE2, for any hard reg, then this must be
+   0 for correct output. */
+#define MODES_TIEABLE_P(MODE1, MODE2) 0
+
+/* Define the classes of registers for register constraints in the
+   machine description.  Also define ranges of constants.
+
+   One of the classes must always be named ALL_REGS and include all hard regs.
+   If there is more than one class, another class must be named NO_REGS
+   and contain no registers.
+
+   The classes must be numbered in nondecreasing order; that is,
+   a larger-numbered class must never be contained completely
+   in a smaller-numbered class.
+
+   For any two classes, it is very desirable that there be another
+   class that represents their union.
+*/
+enum reg_class
+{
+  NO_REGS,
+  FIXED_REGS,     /* Register used for fixed purposes (LR, SP) */
+  BASE_REGS,      /* Registers which may be used as a memory base */
+  ALL_REGS,       /* All registers, including fakes */
+  LIM_REG_CLASSES
+};
+
+/* The name GENERAL_REGS must be the name of a class (or an alias for
+   another name such as ALL_REGS).  This is the class of registers
+   that is allowed by "g" or "r" in a register constraint.
+   Also, registers outside this class are allocated only when
+   instructions express preferences for them. */
+#define GENERAL_REGS	ALL_REGS
+
+/* The number of distict register classes */
+#define N_REG_CLASSES	(int) LIM_REG_CLASSES
+
+/* Give names of register classes as strings for dump file.  */
+#define REG_CLASS_NAMES \
+{ "NO_REGS",       \
+  "FIXED_REGS",    \
+  "BASE_REGS",     \
+  "ALL_REGS" }
+
+/* An initializer containing the contents of the register classes,
+   as integers which are bit masks.  The Nth integer specifies the
+   contents of class N.  The way the integer MASK is interpreted is
+   that register R is in the class if `MASK & (1 << R)' is 1.  */
+
+/*--------------------------------------------------------------
+   SC      0x00000001
+   R1      0x00000002
+   R2      0x00000004
+   R3      0x00000008
+   R4      0x00000010
+   R5      0x00000020
+   R6      0x00000040
+   R7      0x00000080
+   R8      0x00000100
+   BP      0x00000200
+   SP      0x00000400
+   LR      0x00000800
+   R12     0x00001000
+   R13     0x00002000
+   R14     0x00004000
+   R15     0x00008000
+--------------------------------------------------------------*/
+
+#define REG_CLASS_CONTENTS \
+/* NO_REGS       */  {{ 0x00000000 }, \
+/* FIXED_REGS    */   { 0x00000A01 }, /* SC,LR,SP */ \
+/* BASE_REGS     */   { 0x0000FFFE }, \
+/* ALL_REGS      */   { 0x0000FFFF }}
+
+/* Set up a C expression whose value is a register class containing hard
+   register REGNO */
+#define REGNO_REG_CLASS(REGNO) \
+   (REGNO == HARD_SC_REGNUM  ? FIXED_REGS : \
+    REGNO == HARD_LR_REGNUM  ? FIXED_REGS   : \
+    REGNO == HARD_SP_REGNUM  ? FIXED_REGS   : \
+    REGNO <= HARD_R15_REGNUM ? ALL_REGS   : \
+    NO_REGS)
+
+/* Get register class from a letter in the machine description. */
+#define REG_CLASS_FROM_LETTER(C) \
+   ((C) == 'T' ? ALL_REGS   : \
+    NO_REGS)
+
+/* A C expression that places additional restrictions of the register
+   class to use when it is necessary to copy value X into a register
+   in class CLASS. Some values may require the use of a more restrictive
+   class.*/
+#define PREFERRED_RELOAD_CLASS(X,CLASS)	CLASS
+
+/* Return the maximum number of consecutive registers needed to represent
+   mode MODE in a register of class CLASS.  */
+#define CLASS_MAX_NREGS(CLASS, MODE) \
+   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)
+
+/* The letters I, J, K, L and M in a register constraint string
+   can be used to stand for particular ranges of immediate operands.
+   This macro defines what the ranges are.
+   C is the letter, and VALUE is a constant value.
+   Return 1 if VALUE is in the range specified by C.
+
+   'I' is for 32-bit value xxxx0000
+   'J' is for 32-bit value 0000xxxx
+   'K' is for 32-bit value xxxxxxxx
+   'L' is for 2 or -2
+   'M' is for -1
+   'N' is for 1
+   'O' is for 0
+   'P' is for 16-bit value 00ff
+*/
+#define CONST_OK_FOR_LETTER_P(VALUE, C) \
+  ((C) == 'L' ? ((VALUE) == 2 || (VALUE) == -2): \
+   (C) == 'M' ? ((VALUE) == -1): \
+   (C) == 'N' ? ((VALUE) == 1): \
+   (C) == 'O' ? ((VALUE) == 0): \
+   (C) == 'P' ? ((VALUE) == 0x00ff): \
+   (C) == 'I' ? ((VALUE) & 0xffff0000) == 0: \
+   (C) == 'J' ? ((VALUE) & 0x0000ffff) == 0: \
+   (C) == 'K' ? (((VALUE) & 0xffff0000) != 0 && \
+		 ((VALUE) & 0x0000ffff) != 0): \
+   0)
+
+/* Similar, but for floating constants, and defining letters G and H.
+
+   `G' is for 0.0.  */
+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \
+  ((C) == 'G' ? (GET_MODE_CLASS (GET_MODE (VALUE)) == MODE_FLOAT \
+		 && VALUE == CONST0_RTX (GET_MODE (VALUE))) : 0) 
+
+/* Letters in the range `Q' through `U' may be defined in a
+   machine-dependent fashion to stand for arbitrary operand types. 
+   The machine description macro `EXTRA_CONSTRAINT' is passed the
+   operand as its first argument and the constraint letter as its
+   second operand.
+
+   This macro returns 1 if the provided CODE matches the provided OP
+
+   `Q'	is for memory references that require an extra word after the opcode.
+   `R'	is for memory references which are encoded within the opcode.  */
+#define EXTRA_CONSTRAINT(OP,CODE)					\
+  ((GET_CODE (OP) != MEM) ? 0						\
+   : !legitimate_address_p (GET_MODE (OP), XEXP (OP, 0)) ? 0		\
+   : ((CODE) == 'Q') ? (tms9900_address_type (OP, GET_MODE (OP)) == 3)  \
+   : ((CODE) == 'R') ? (tms9900_address_type (OP, GET_MODE (OP)) == 1)	\
+   : 0)
+   // constantpool_mem_p (OP)
+
+/* Stack layout; function entry, exit and calling.  */
+
+/* Define this if pushing a word on the stack
+   makes the stack pointer a smaller address.  */
+#define STACK_GROWS_DOWNWARD
+
+/* Define this to nonzero if the nominal address of the stack frame
+   is at the high-address end of the local variables;
+   that is, each additional local variable allocated
+   goes at a more negative offset in the frame.
+
+   Define to 0 for TMS9900, the frame pointer is the bottom
+   of local variables.  */
+#define FRAME_GROWS_DOWNWARD 0
+
+/* Offset within stack frame to start allocating local variables at.
+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the
+   first local allocated.  Otherwise, it is the offset to the BEGINNING
+   of the first local allocated.  */
+#define STARTING_FRAME_OFFSET 0
+
+/* Offset of first parameter from the argument pointer register value.  */
+#define FIRST_PARM_OFFSET(FNDECL)	0
+
+/* After the prologue, RA is at 0(AP) in the current frame.  */
+#define RETURN_ADDR_RTX(COUNT, FRAME)					\
+  ((COUNT) == 0								\
+   ? gen_rtx_MEM (Pmode, arg_pointer_rtx)                               \
+   : 0)
+
+/* Before the prologue, the top of the frame is at 2(sp).  */
+#define INCOMING_FRAME_SP_OFFSET        0
+
+/* Register to use for pushing function arguments.  */
+#define STACK_POINTER_REGNUM		HARD_SP_REGNUM
+
+/* Base register for access to local variables of the function.  */
+#define FRAME_POINTER_REGNUM		HARD_BP_REGNUM
+
+/* Base register for access to arguments of the function.  */
+#define ARG_POINTER_REGNUM		HARD_AP_REGNUM
+
+/* Register in which static-chain is passed to a function.  */
+#define STATIC_CHAIN_REGNUM	        HARD_R12_REGNUM
+
+/* Definitions for register eliminations.
+
+   This is an array of structures.  Each structure initializes one pair
+   of eliminable registers.  The "from" register number is given first,
+   followed by "to".  Eliminations of the same "from" register are listed
+   in order of preference.
+
+   The pseudo arg pointer and pseudo frame pointer registers can always
+   be eliminated; they are replaced with either the stack or the real
+   frame pointer.  */
+#define ELIMINABLE_REGS \
+  {{ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM},\
+   {ARG_POINTER_REGNUM,   FRAME_POINTER_REGNUM},\
+   {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}
+
+/* Value should be nonzero if functions must have frame pointers.
+   Zero means the frame pointer need not be set up (and parms may be
+   accessed via the stack pointer) in functions that seem suitable.
+   This is computed in `reload', in reload1.c.  */
+#define FRAME_POINTER_REQUIRED	0
+
+#define CAN_DEBUG_WITHOUT_FP 1
+
+/* Given FROM and TO register numbers, say whether this elimination is allowed.
+   Frame pointer elimination is automatically handled.
+
+   All other eliminations are valid.  */
+#define CAN_ELIMINATE(FROM, TO)		1
+
+/* Define the offset between two registers, one to be eliminated, and the other
+   its replacement, at the start of a routine.  */
+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \
+    { OFFSET = tms9900_initial_elimination_offset (FROM, TO); }
+
+/* Passing Function Arguments on the Stack.  */
+
+/* A C expression.  If nonzero, push insns will be used to pass
+   outgoing arguments.  If the target machine does not have a push
+   instruction, set it to zero.  That directs GCC to use an alternate
+   strategy: to allocate the entire argument block and then store the
+   arguments into it.  When `PUSH_ARGS' is nonzero, `PUSH_ROUNDING'
+   must be defined too. */
+#define PUSH_ARGS 0
+
+/* We want the stack and args grow in opposite directions, even if
+   PUSH_ARGS is 0.
+   MGB added, var param lists were not working */
+#define PUSH_ARGS_REVERSED 1
+
+/* Value is 1 if returning from a function call automatically pops the
+   arguments described by the number-of-args field in the call. FUNTYPE is
+   the data type of the function (as a tree), or for a library call it is
+   an identifier node for the subroutine name. */
+#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE)	0
+
+/* MGB to load a byte into a word we need to zero extend it.  Defining this
+ * macro solves some problems with upgrading QI to HI but introduces others
+ * where it extends a QI and then subsequently refers to the reg in QI mode
+ * anyway.  Leaving commented out for now */
+// #define LOAD_EXTEND_OP(MODE) ZERO_EXTEND
+
+/* Passing Arguments in Registers.  */
+
+/* The number of argument registers we can use (R1..R8) */
+/* Limiting this to 4 regs would appear to make more regs available for general
+ * use, but the improvement didn't seem to be worth it */
+// #define TMS9900_ARG_REGS (HARD_R4_REGNUM - HARD_R1_REGNUM + 1)
+#define TMS9900_ARG_REGS (HARD_R8_REGNUM - HARD_R1_REGNUM + 1)
+
+/* Define a data type for recording info about an argument list
+   during the scan of that argument list.  This data type should
+   hold all necessary information about the function itself
+   and about the args processed so far, enough to enable macros
+   such as FUNCTION_ARG to determine where the next arg should go.  */
+typedef struct tms9900_args
+{
+  int nregs;        /* Number of registers used so far */
+  int named_count;  /* Number of named arguments (for varargs) */  
+} CUMULATIVE_ARGS;
+
+/* If defined, a C expression which determines whether, and in which direction,
+   to pad out an argument with extra space.  The value should be of type
+   `enum direction': either `upward' to pad above the argument,
+   `downward' to pad below, or `none' to inhibit padding.
+
+   Structures are stored left shifted in their argument slot.  */
+#define FUNCTION_ARG_PADDING(MODE, TYPE) \
+  tms9900_function_arg_padding ((MODE), (TYPE))
+
+#undef PAD_VARARGS_DOWN
+#define PAD_VARARGS_DOWN \
+  (tms9900_function_arg_padding (TYPE_MODE (type), type) == downward)
+
+/* Initialize a variable CUM of type CUMULATIVE_ARGS for a call to a
+   function whose data type is FNTYPE. For a library call, FNTYPE is 0.  */
+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \
+   (tms9900_init_cumulative_args (&CUM, FNTYPE, LIBNAME))
+
+/* Update the data in CUM to advance over an argument of mode MODE and data
+   type TYPE. (TYPE is null for libcalls where that information may not be
+   available.) */
+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED) \
+    (tms9900_function_arg_advance (&CUM, MODE, TYPE, NAMED))
+
+/* Define where to put the arguments to a function.
+   Value is zero to push the argument on the stack,
+   or a hard register in which to store the argument.
+
+   MODE is the argument's machine mode.
+   TYPE is the data type of the argument (as a tree).
+    This is null for libcalls where that information may
+    not be available.
+   CUM is a variable of type CUMULATIVE_ARGS which gives info about
+    the preceding args and about the function being called.
+   NAMED is nonzero if this argument is a named parameter
+    (otherwise it is an extra parameter matching an ellipsis).  */
+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \
+  (tms9900_function_arg (&CUM, MODE, TYPE, NAMED))
+
+/* This target hook should return `true' if an argument at the
+   position indicated by CUM should be passed by reference.  This
+   predicate is queried after target independent reasons for being
+   passed by reference, such as `TREE_ADDRESSABLE (type)'.
+
+   If the hook returns true, a copy of that argument is made in
+   memory and a pointer to the argument is passed instead of the
+   argument itself.  The pointer is passed in whatever way is
+   appropriate for passing a pointer to that type. */
+/*
+#define TARGET_PASS_BY_REFERENCE(CUM,MODE,TYPE,NAMED) \
+ (TYPE && TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST)
+*/
+
+/* Define the profitability of saving registers around calls.
+
+   Disable this because the saving instructions generated by
+   caller-save need a reload and the way it is implemented,
+   it forbids all spill registers at that point.  Enabling
+   caller saving results in spill failure.  */
+#define CALLER_SAVE_PROFITABLE(REFS,CALLS) 0
+
+/* 1 if N is a possible register number for function argument passing. */
+     // MGBREGS (((N) >= HARD_R1_REGNUM) && ((N) <= HARD_R4_REGNUM))
+#define FUNCTION_ARG_REGNO_P(N)	\
+     (((N) >= HARD_R1_REGNUM) && ((N) <= HARD_R8_REGNUM))
+
+/* 8- and 16-bit values are returned in R1, 32-bit values are
+   passed in R1+R2, The high word is in R1. */
+#define FUNCTION_VALUE(VALTYPE, FUNC) \
+     gen_rtx_REG (TYPE_MODE (VALTYPE), HARD_R1_REGNUM)
+
+/* 8- and 16-bit values are returned in R1, 32-bit values are
+   passed in R1+R2, The high word is in R1. */
+#define LIBCALL_VALUE(MODE)						\
+     gen_rtx_REG (MODE, HARD_R1_REGNUM)
+
+/* 1 if N is a possible register number for a function value.  */
+#define FUNCTION_VALUE_REGNO_P(N) \
+     ((N) == HARD_R1_REGNUM)
+
+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,
+   the stack pointer does not matter.  The value is tested only in functions
+   that have frame pointers. No definition is equivalent to always zero.  */
+#define EXIT_IGNORE_STACK	0
+
+/* Generating Code for Profiling.  */
+
+/* Output assembler code to FILE to increment profiler label # LABELNO
+   for profiling a function entry.  */
+#define FUNCTION_PROFILER(FILE, LABELNO)		\
+    fprintf (FILE, "\tldy\tLP%d\n\tjsr mcount\n", (LABELNO))
+
+/* Let's see whether this works as trampoline:
+     LI Rn, @STATIC	0x0200	0x0000 <- STATIC; Y = STATIC_CHAIN_REGNUM
+     B  FUNCTION	0x0820  0x0000 <- FUNCTION
+*/
+#define TRAMPOLINE_TEMPLATE(FILE)	\
+{					\
+  assemble_aligned_integer (2, GEN_INT (0x0200+STATIC_CHAIN_REGNUM));	\
+  assemble_aligned_integer (2, const0_rtx);				\
+  assemble_aligned_integer (2, GEN_INT(0x0820));			\
+  assemble_aligned_integer (2, const0_rtx);				\
+}
+
+#define TRAMPOLINE_SIZE 8
+#define TRAMPOLINE_ALIGNMENT 16
+
+/* Emit RTL insns to initialize the variable parts of a trampoline.
+   FNADDR is an RTX for the address of the function's pure code.
+   CXT is an RTX for the static chain value for the function.  */
+#define INITIALIZE_TRAMPOLINE(TRAMP,FNADDR,CXT)	\
+{					\
+  emit_move_insn (gen_rtx_MEM (HImode, plus_constant (TRAMP, 2)), CXT); \
+  emit_move_insn (gen_rtx_MEM (HImode, plus_constant (TRAMP, 6)), FNADDR); \
+}
+
+/* The TMS9900 can only do post increment */
+#define HAVE_POST_INCREMENT  (1)
+#define HAVE_PRE_INCREMENT   (0)
+#define HAVE_POST_DECREMENT  (0)
+#define HAVE_PRE_DECREMENT   (0)
+#define HAVE_POST_MODIFY_REG (1)
+
+/* The name of the class to which a valid base register must belong.
+   A base register is one used in an address which is the register
+   value plus a displacement. */
+#define BASE_REG_CLASS	BASE_REGS
+
+/* From https://gcc.gnu.org/onlinedocs/gccint/Register-Classes.html
+ *
+ * "The difference between an index register and a base register is that the
+ * index register may be scaled. "
+ *
+ *  We don't allow any index regs as TMS9900 regs can't be scaled
+ */
+/* The class value for index registers. */
+#define INDEX_REG_CLASS	NO_REGS
+
+/* A C expression which is nonzero if register number NUM is suitable
+   for use as a base register in operand addresses.  It may be either
+   a suitable hard register or a pseudo register that has been
+   allocated such a hard register. 
+   Any hard register except R0 is a valid base */
+#define REGNO_OK_FOR_BASE_P(NUM) \
+   ((NUM) >= HARD_R1_REGNUM && (NUM) <= HARD_R15_REGNUM)
+
+/* A C expression which is nonzero if register number NUM is suitable
+   for use as an index register in operand addresses.  It may be
+   either a suitable hard register or a pseudo register that has been
+   allocated such a hard register. The difference between an index
+   register and a base register is that the index register may be scaled. */
+#define REGNO_OK_FOR_INDEX_P(NUM) 0
+
+/* 1 if X is an rtx for a constant that is a valid address.  */
+/*
+#define CONSTANT_ADDRESS_P(X)	\
+  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF \
+          || CONST_INT_P (X) || GET_CODE (X) == CONST      \
+          || GET_CODE (X) == HIGH)
+*/
+// #define CONSTANT_ADDRESS_P(X)  CONSTANT_P(X)
+#define CONSTANT_ADDRESS_P(X)  tms9900_constant_address_p(X)
+
+/* Maximum number of registers that can appear in a valid memory address */
+#define MAX_REGS_PER_ADDRESS	1
+
+/* The behavior of several macros depend on whether or not we are in 
+   strict mode. Define a constant for this */
+#ifdef REG_OK_STRICT
+#define IS_STRICT_P 1
+#else
+#define IS_STRICT_P 0
+#endif
+
+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression that is a
+   valid memory address for an instruction. The MODE argument is the
+   machine mode for the MEM expression that wants to use this address.  */
+
+/*--------------------------------------------------------------
+   Valid addresses are either direct or indirect (MEM) versions
+   of the following forms:
+	constant		N
+	register		X
+	indexed			N,X
+--------------------------------------------------------------*/
+
+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression
+   that is a valid memory address for an instruction.
+   The MODE argument is the machine mode for the MEM expression
+   that wants to use this address. */
+#define GO_IF_LEGITIMATE_ADDRESS(mode, operand, ADDR) \
+  { \
+  if(tms9900_go_if_legitimate_address(mode, operand, IS_STRICT_P)) \
+    { \
+    goto ADDR; \
+    } \
+  fail: ;\
+  }
+
+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx and check its
+   validity for a certain class.  We have two alternate definitions for each
+   of them.  The usual definition accepts all pseudo regs; the other rejects
+   them unless they have been allocated suitable hard regs.  The symbol
+   REG_OK_STRICT causes the latter definition to be used.
+  
+   Most source files want to accept pseudo regs in the hope that they will
+   get allocated to the class that the insn wants them to be in. Source files
+   for reload pass need to be strict. After reload, it makes no difference,
+   since pseudo regs have been eliminated by then.  */
+#define REG_OK_FOR_BASE_P(X) (tms9900_reg_ok_for_base(IS_STRICT_P, X)) 
+
+/* Nonzero if X is a hard reg that can be used as an index.  */
+#define REG_OK_FOR_INDEX_P(X) (0)
+
+
+/* Try machine-dependent ways of modifying an illegitimate address
+   to be legitimate.  If we find one, return the new, valid address.
+   This macro is used in only one place: `memory_address' in explow.c.
+  
+   OLDX is the address as it was before break_out_memory_refs was called.
+   In some cases it is useful to look at this to decide what needs to be done.
+  
+   MODE and WIN are passed so that this macro can use
+   GO_IF_LEGITIMATE_ADDRESS.
+  
+   It is always safe for this macro to do nothing.
+   It exists to recognize opportunities to optimize the output.  */
+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)
+  
+/* Go to LABEL if ADDR (a legitimate address expression)
+   has an effect that depends on the machine mode it is used for.  */
+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)
+
+/* Nonzero if the constant value X is a legitimate general operand.
+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */
+
+/* "TARGET_CANNOT_FORCE_CONST_MEM should not be defined to be true for an
+    ordinary constant.  It should only return true for special cases like
+    the address of a TLS symbol.
+ 
+    gcc will automatically generate a constant pool when it sees a
+    constant which is not LEGITIMATE_CONSTANT_P." */
+
+// #define LEGITIMATE_CONSTANT_P(X)	1
+// #define LEGITIMATE_CONSTANT_P(X)	(GET_CODE(X)!=CONST_INT)
+#define LEGITIMATE_CONSTANT_P(X) tms9900_legitimate_constant_p(X)
+
+/* Tell final.c how to eliminate redundant test instructions.  */
+#define NOTICE_UPDATE_CC(EXP, INSN) \
+{ if (GET_CODE (EXP) == SET)					\
+    {								\
+      notice_update_cc_on_set(EXP, INSN);			\
+    }								\
+  else if (GET_CODE (EXP) == PARALLEL				\
+	   && GET_CODE (XVECEXP (EXP, 0, 0)) == SET)		\
+    {								\
+      notice_update_cc_on_set(XVECEXP (EXP, 0, 0), INSN);	\
+    }								\
+  else if (GET_CODE (EXP) == CALL)				\
+    { /* all bets are off */ CC_STATUS_INIT; }			\
+  if (cc_status.value1 && GET_CODE (cc_status.value1) == REG	\
+      && cc_status.value2					\
+      && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2)) \
+    { 								\
+      cc_status.value2 = 0;					\
+    }								\
+}
+
+/*   A C expression for the cost of moving data of mode MODE from a
+     register in class FROM to one in class TO.  The classes are
+     expressed using the enumeration values such as `GENERAL_REGS'.  A
+     value of 2 is the default; other values are interpreted relative to
+     that.
+
+     It is not required that the cost always equal 2 when FROM is the
+     same as TO; on some machines it is expensive to move between
+     registers if they are not general registers.
+
+     If reload sees an insn consisting of a single `set' between two
+     hard registers, and if `REGISTER_MOVE_COST' applied to their
+     classes returns a value of 2, reload does not check to ensure that
+     the constraints of the insn are met.  Setting a cost of other than
+     2 will allow reload to verify that the constraints are met.  You
+     should do this if the `movM' pattern's constraints do not allow
+     such copying. */
+#define REGISTER_MOVE_COST(MODE, FROM, TO) 4
+
+/* A C expression for the cost of moving data of mode MODE between a
+   register of class CLASS and memory; IN is zero if the value is to
+   be written to memory, nonzero if it is to be read in.  This cost
+   is relative to those in `REGISTER_MOVE_COST'.  If moving between
+   registers and memory is more expensive than between two registers,
+   you should define this macro to express the relative cost
+
+   For the TMS9900, memory access is four times slower than registers
+   MGB I don't think it is 4x more expensive, but lowering it to 4 caused some
+   code bloat so changing it back to 16 */
+#define MEMORY_MOVE_COST(MODE,CLASS,IN)	16
+
+/* A C expression for the cost of a branch instruction.  A value of 1
+   is the default; other values are interpreted relative to that.
+
+   Pretend branches are cheap because GCC generates sub-optimal code
+   for the default value.  */
+#define BRANCH_COST(speed_p, predictable_p) 0
+
+/* Nonzero if access to memory by bytes is slow and undesirable.  */
+#define SLOW_BYTE_ACCESS 0
+
+/* Defining the Output Assembler Language.  */
+
+/* A default list of other sections which we might be "in" at any given
+   time.  For targets that use additional sections (e.g. .tdesc) you
+   should override this definition in the target-specific file which
+   includes this file.  */
+
+/* Output before read-only data.  */
+#define TEXT_SECTION_ASM_OP	("\tpseg")
+
+/* Output before writable data.  */
+#define DATA_SECTION_ASM_OP	("\tdseg")
+
+/* Output before uninitialized data.  */
+#define BSS_SECTION_ASM_OP 	("\tcseg")
+
+/* Define this macro to be an expression with a nonzero value if jump tables
+   (for tablejump insns) should be output in the text section, along with the
+   assembler instructions. Otherwise, the readonly data section is used. */
+#define JUMP_TABLES_IN_TEXT_SECTION 1
+
+
+/* Define the pseudo-ops used to switch to the .ctors and .dtors sections.
+
+   Same as config/elfos.h but don't mark these section SHF_WRITE since
+   there is no shared library problem.  */
+/*EMW - Neglect C++ for now...
+#undef CTORS_SECTION_ASM_OP
+#define CTORS_SECTION_ASM_OP	"\t.section\t.ctors,\"a\""
+
+#undef DTORS_SECTION_ASM_OP
+#define DTORS_SECTION_ASM_OP	"\t.section\t.dtors,\"a\""
+
+#define TARGET_ASM_CONSTRUCTOR  tms9900_asm_out_constructor
+#define TARGET_ASM_DESTRUCTOR   tms9900_asm_out_destructor
+EMW*/
+
+/* Comment character */
+#define ASM_COMMENT_START	"*"
+
+/* Output to assembler file text saying following lines
+   may contain character constants, extra white space, comments, etc.  */
+#define ASM_APP_ON 		"* Begin inline assembler code\n"
+
+/* Output to assembler file text saying following lines
+   no longer contain unusual constructs.  */
+#define ASM_APP_OFF 		"* End of inline assembler code\n"
+
+/* output external reference */
+#undef ASM_OUTPUT_EXTERNAL
+#define ASM_OUTPUT_EXTERNAL(FILE,DECL,NAME) \
+  {fputs ("\tref\t", FILE); \
+  assemble_name (FILE, NAME); \
+  fputs ("\n", FILE);}
+
+#define ASM_OUTPUT_LABEL(FILE,NAME) \
+  {							\
+    assemble_name ((FILE), (NAME));			\
+    fputc ('\n', (FILE));				\
+  }
+
+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,NAME) \
+  {							\
+    assemble_name ((FILE), (NAME));			\
+    fputc ('\n', (FILE));				\
+  }
+
+/* Print operand X (an rtx) in assembler syntax to file FILE.
+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.
+   For `%' followed by punctuation, CODE is the punctuation and X is null. */
+#define PRINT_OPERAND(FILE, X, CODE)  		\
+{ if (CODE == '#') fprintf (FILE, "#");		\
+  else if (GET_CODE (X) == REG)			\
+    fprintf (FILE, "%s", reg_names[REGNO (X)]);	\
+  else if (GET_CODE (X) == MEM)			\
+    output_address (XEXP (X, 0));		\
+  else if (GET_CODE (X) == PC)			\
+    fprintf (FILE, "$");			\
+  else if (GET_CODE (X) == CONST_INT)		\
+    fprintf (FILE, ">%X", (unsigned short)(INTVAL(X) & 0xFFFF));	\
+  else output_addr_const (FILE, X);}
+
+/* Print a memory operand whose address is ADDR, on file FILE.  */
+#define PRINT_OPERAND_ADDRESS(FILE, ADDR) \
+   print_operand_address (FILE, ADDR)
+
+/* This is how to output an insn to push/pop a register on the stack.
+   It need not be very fast code.  
+
+   Don't define because we don't know how to handle that with
+   the STATIC_CHAIN_REGNUM (soft register).  Saving the static
+   chain must be made inside FUNCTION_PROFILER.  */
+#undef ASM_OUTPUT_REG_PUSH
+#undef ASM_OUTPUT_REG_POP
+
+/* This is how to output an element of a case-vector that is relative.  */
+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \
+  fprintf (FILE, "\t%s\tL%d-L%d\n", integer_asm_op (2, TRUE), VALUE, REL)
+
+/* This is how to output an element of a case-vector that is absolute.  */
+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \
+  fprintf (FILE, "\t%s\tL%d\n", integer_asm_op (2, TRUE), VALUE)
+
+/* Advance to the next word boundary */
+#undef ALIGN_ASM_OP
+#define ALIGN_ASM_OP "\teven\t"
+
+/* This is how to output an assembler line that says to advance the
+   location counter to a multiple of 2**LOG bytes.  */
+#define ASM_OUTPUT_ALIGN(FILE,LOG)      \
+  switch (LOG)                          \
+    {                                   \
+      case 0:                           \
+        break;                          \
+      case 1:                           \
+        fprintf (FILE, "\teven\n");     \
+        break;                          \
+      default:                          \
+        gcc_unreachable ();             \
+    }
+
+/* Assembler Commands for Exception Regions.  */
+
+/* Default values provided by GCC should be ok. Assuming that DWARF-2
+   frame unwind info is ok for this platform.  */
+#define DWARF2_DEBUGGING_INFO 1
+
+/* Prefer dwarf format for debugging info */
+#undef PREFERRED_DEBUGGING_TYPE
+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG
+
+/* Use 16-bit values for dwarf address pointers */
+#define DWARF2_ADDR_SIZE 2
+
+/* Enable support for source line debugging in emitted assembly code */
+#define HAVE_AS_DWARF2_DEBUG_LINE 1
+
+/* Only emit ".file" and ".loc" directives if debugging is enabled */
+#define DWARF2_ASM_LINE_DEBUG_INFO (write_symbols != NO_DEBUG)
+
+/* This flag is true if the target supports `TARGET_ASM_NAMED_SECTION'. */
+#define TARGET_HAVE_NAMED_SECTIONS 1
+
+/* Output assembly directives to switch to section NAME.  The section
+   should have attributes as specified by FLAGS, which is a bit mask
+   of the `SECTION_*' flags defined in `output.h'.  If ALIGN is
+   nonzero, it contains an alignment in bytes to be used for the
+   section, otherwise some target default should be used.  Only
+   targets that must specify an alignment within the section
+   directive need pay attention to ALIGN - we will still use
+   `ASM_OUTPUT_ALIGN'. */
+#define TARGET_ASM_NAMED_SECTION  default_elf_asm_named_section
+
+/* The prefix for local labels.  You should be able to define this as
+   an empty string, or any arbitrary string (such as ".", ".L%", etc)
+   without having to make any other changes to account for the specific
+   definition.  Note it is a string literal, not interpreted by printf
+   and friends.  */
+/*#define LOCAL_LABEL_PREFIX "."*/
+
+/* Directive to give a symbol global scope */
+#define GLOBAL_ASM_OP   "\tdef\t"
+
+/* Miscellaneous Parameters.  */
+
+/* Specify the machine mode that this machine uses
+   for the index in the tablejump instruction.  */
+#define CASE_VECTOR_MODE	Pmode
+
+/* This flag, if defined, says the same insns that convert to a signed fixnum
+   also convert validly to an unsigned one.  */
+#define FIXUNS_TRUNC_LIKE_FIX_TRUNC
+
+/* Max number of bytes we can move from memory to memory in one
+   reasonably fast instruction.  */
+#define MOVE_MAX 		2
+
+/* MOVE_RATIO is the number of move instructions that is better than a
+   block move.  Make this small, since the code size grows very
+   large with each move.  */
+#define MOVE_RATIO(speed)	3
+
+/* Define if shifts truncate the shift count which implies one can omit
+   a sign-extension or zero-extension of a shift count.  */
+#define SHIFT_COUNT_TRUNCATED	1
+
+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits
+   is done just by pretending it is already truncated.  */
+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC)	0
+
+/* Specify the machine mode that pointers have. After generation of rtl, the
+   compiler makes no further distinction between pointers and any other
+   objects of this machine mode.  */
+#define Pmode			HImode
+
+/* An alias for the machine mode used for memory references to
+   functions being called, in `call' RTL expressions.  On most CISC
+   machines, where an instruction can begin at any byte address, this
+   should be `QImode'.  On most RISC machines, where all instructions
+   have fixed size and alignment, this should be a mode with the same
+   size and alignment as the machine instruction words - typically
+   `SImode' or `HImode'. */
+#define FUNCTION_MODE		HImode
+
+/* A C statement (sans semicolon) to output a reference to
+   `SYMBOL_REF' SYM.  If not defined, `assemble_name' will be used to
+   output the name of the symbol.  This macro may be used to modify
+   the way a symbol is referenced depending on information encoded by
+   `TARGET_ENCODE_SECTION_INFO'. */
+#define ASM_GENERATE_INTERNAL_LABEL(STRING, PREFIX, NUM) \
+  sprintf (STRING, "*%s%ld", PREFIX, (long)(NUM))
+
+/* A C statement to output to the stdio stream STREAM an assembler
+   instruction to advance the location counter by NBYTES bytes.
+   Those bytes should be zero when loaded.  NBYTES will be a C
+   expression of type `unsigned HOST_WIDE_INT'. */
+#define ASM_OUTPUT_SKIP(STREAM, NBYTES) \
+   fprintf(STREAM, "\tbss %lu\n", NBYTES);
+
+/* A C statement (sans semicolon) to output to the stdio stream
+   STREAM the assembler definition of uninitialized global DECL named
+   NAME whose size is SIZE bytes.  The variable ROUNDED is the size
+   rounded up to whatever alignment the caller wants. */
+#define ASM_OUTPUT_ALIGNED_BSS(STREAM, DECL, NAME, SIZE, ALIGNMENT)     \
+  do{\
+  if(ALIGNMENT > 1) fprintf ((STREAM), "\n\teven\n");                   \
+  asm_output_aligned_bss ((STREAM), (DECL), (NAME), (SIZE), (ALIGNMENT)); }while(0)
+
+/* A C statement (sans semicolon) to output to the stdio stream
+   STREAM the assembler definition of a common-label named NAME whose
+   size is SIZE bytes.  The variable ROUNDED is the size rounded up
+   to whatever alignment the caller wants. */
+#define ASM_OUTPUT_ALIGNED_COMMON(STREAM, NAME, SIZE, ALIGNMENT)           \
+do {                                                                       \
+     switch_to_section (bss_section);                                      \
+     if(ALIGNMENT > 1) fprintf ((STREAM), "\n\teven");                     \
+     fprintf ((STREAM), "\n\tdef %s\n", (NAME));                           \
+     assemble_name ((STREAM), (NAME));                                     \
+     fprintf ((STREAM), "\n\tbss %u\n", (int)(SIZE));                      \
+} while (0)
+
+/* A C statement (sans semicolon) to output to the stdio stream
+   STREAM the assembler definition of a local-common-label named NAME
+   whose size is SIZE bytes.  The variable ROUNDED is the size
+   rounded up to whatever alignment the caller wants. */
+#define ASM_OUTPUT_ALIGNED_LOCAL(STREAM, NAME, SIZE, ALIGNMENT)            \
+do {                                                                       \
+     switch_to_section (bss_section);                                      \
+     if(ALIGNMENT > 1) fprintf ((STREAM), "\n\teven\n");                   \
+     assemble_name ((STREAM), (NAME));                                     \
+     fprintf ((STREAM), "\n\tbss %u\n", (int)(SIZE));                      \
+} while (0)
+
+/* A C statement to output to the stdio stream STREAM an assembler
+   instruction to assemble a string constant containing the LEN bytes
+   at PTR.  PTR will be a C expression of type `char *' and LEN a C
+   expression of type `int'. */
+#define ASM_OUTPUT_ASCII(STREAM, PTR, LEN) \
+   tms9900_output_ascii(STREAM, PTR, LEN)
+
+#define ASM_OUTPUT_DWARF_DELTA(FILE,SIZE,LABEL1,LABEL2)  \
+   tms9900_asm_output_dwarf_delta (FILE, SIZE, LABEL1, LABEL2)
+
+#define ASM_OUTPUT_DWARF_OFFSET(FILE,SIZE,LABEL,BASE)  \
+   tms9900_asm_output_dwarf_offset (FILE, SIZE, LABEL, BASE)
+
+/* Put references to global constructors in a .init section. The crt0 code
+   will invoke these constructors at startup, before calling main. */
+#define INIT_SECTION_ASM_OP
+
+#undef  SIZE_ASM_OP
+#undef  TYPE_ASM_OP
+#define SIZE_ASM_OP     "\t.size\t"
+#define TYPE_ASM_OP     "\t.type\t"
+
+#undef TYPE_OPERAND_FMT
+#define TYPE_OPERAND_FMT        "@%s"
+
+#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)                    \
+  do {                                                                  \
+     if (!flag_inhibit_size_directive)                                  \
+      ASM_OUTPUT_MEASURED_SIZE (FILE, FNAME);                           \
+  } while (0)
+
+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)                       \
+do {                                                                    \
+  ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, "object");                     \
+  size_directive_output = 0;                                            \
+  if (!flag_inhibit_size_directive && DECL_SIZE (DECL))                 \
+    {                                                                   \
+      size_directive_output = 1;                                        \
+      ASM_OUTPUT_SIZE_DIRECTIVE (FILE, NAME,                            \
+                                 int_size_in_bytes (TREE_TYPE (DECL))); \
+    }                                                                   \
+  ASM_OUTPUT_LABEL(FILE, NAME);                                         \
+} while (0)
+
+
+#undef ASM_FINISH_DECLARE_OBJECT
+#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)        \
+  do {                                                                  \
+    const char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);             \
+    HOST_WIDE_INT size;                                                 \
+    if (!flag_inhibit_size_directive                                    \
+        && DECL_SIZE (DECL)                                             \
+        && ! AT_END && TOP_LEVEL                                        \
+        && DECL_INITIAL (DECL) == error_mark_node                       \
+        && !size_directive_output                                       \
+        && (size = int_size_in_bytes (TREE_TYPE (DECL))) > 0)           \
+      {                                                                 \
+        size_directive_output = 1;                                      \
+        ASM_OUTPUT_SIZE_DIRECTIVE (FILE, name, size);                   \
+      }                                                                 \
+  } while (0)
+
+
+#ifdef FILE
+void tms9900_asm_output_dwarf_delta (FILE *file, int size,
+                               const char *lab1, const char *lab2);
+#endif
+
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/tms9900.md gcc-4.4.0/gcc/config/tms9900/tms9900.md
--- gcc-4.4.0-orig/gcc/config/tms9900/tms9900.md	2024-07-28 14:42:12.633792695 +0100
+++ gcc-4.4.0/gcc/config/tms9900/tms9900.md	2024-10-06 09:16:07.620555312 +0100
@@ -0,0 +1,3375 @@
+;;- Machine description for the TMS9900 for GNU C compiler
+;; Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2004, 2005
+;; 2007, 2008 Free Software Foundation, Inc.
+
+;; Copyright 2009 Eric Welser (EMW)
+;; Copyright 2023 Mark Burkley (MGB)
+
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+;; SI is 32 bit
+;; HI is 16 bit
+;; QI is 8 bit 
+
+;; MGB NOTES
+;;    - rtx notation is insn(dst,src) but tms asm notation is <op> src,dst so
+;;      beware of operand ordering
+;;    - all byte (QI) ops need to have expands to cater for the fact that in
+;;      TMS9900 a 16-bit operation can't be done on a reg that contains an 8-bit value
+;;      unless it has been shifted by 8
+;;    - Many byte insns are restricted to registers only as TMS9900 doesn't have
+;;      byte version of abs, neg, etc.
+;;    - Insns like extend, trunc, abs, etc, are done in place but passed two
+;;      distinct params.  This is ok, the compiler is forced to move src and dst to the
+;;      same reg by the "0" constraint.
+;;    - optimiser doesn't understand opcodes, just insns.  So keep insns as
+;;      short as possible.  One opcode preferable, two max.  Any more, use an expand instead
+;;    - TODO expands are not available at later optimisioation stages 
+;;    - byte immediates can be problematic as immediates are 16-bit only and the
+;;      other byte is an unknown.  In these cases, byte immediates are re-written in an
+;;      expand to refer to a label in a constant pool using force_const_mem
+;;    - I'm avoiding clobbers in expands and declaring temp rtx regs inside code
+;;      instead.  Also using r0 as a scratch reg since it cannot be used as a general
+;;      reg.
+;;    - 32-bit arith insns have been moved to C code.  Emitting lengthy opcode
+;;      sequences shouldn't be part of a md file.
+
+;; Description of class IDs
+;;   'L' is for 2 or -2
+;;   'M' is for -1
+;;   'N' is for 1
+;;   'O' is for 0
+;;   'Q' is for memory references that need an extra word after the opcode.
+;;   'R' is for memory references which are encoded within the opcode.
+
+;;- See file "rtl.def" for documentation on define_insn, match_*, et. al.
+
+;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code
+;;- updates for most instructions.
+
+;;- Operand classes for the register allocator:
+
+;; Compare instructions.
+
+
+;; define attributes
+;; currently type is only fpu or arith or unknown, maybe branch later ?
+;; default is arith
+(define_attr "type" "unknown,arith,fp" (const_string "arith"))
+
+;; length default is 1 words each
+(define_attr "length" "" (const_int 2))
+
+;; a user's asm statement
+(define_asm_attributes
+  [(set_attr "type" "unknown")
+; all bets are off how long it is - make it 256, forces long jumps 
+; whenever jumping around it !!!
+   (set_attr "length" "256")])
+
+;;-------------------------------------------------------------------
+;;  UNSPEC Definitions
+;;-------------------------------------------------------------------
+(define_constants
+  [(UNSPEC_RETURN  0)])
+
+
+;;-------------------------------------------------------------------
+;;  Predicate Definitions
+;;-------------------------------------------------------------------
+
+;;-------------------------------------------------------------------
+;;  Function Calls
+;;-------------------------------------------------------------------
+
+
+;;-------------------------------------------------------------------
+;; Jump to a subroutine which returns a value
+(define_insn "call"
+  [(call (match_operand:HI 0 "general_operand" "rR,Q")
+         (match_operand:HI 1 "general_operand"  "g,g"))
+  ]
+  ""
+  {
+    tms9900_debug_operands ("call", insn, operands, 2);
+    if(SIBLING_CALL_P(insn))
+      output_asm_insn("b    %0", operands);
+    else
+      output_asm_insn("bl   %0", operands);
+    return("");
+  }
+  [(set_attr "length" "2,4")]
+)
+
+
+;-------------------------------------------------------------------
+; Jump to a subroutine which returns a value
+(define_insn "call_value"
+  [(set (match_operand 0 "" "")
+        (call (match_operand:HI 1 "general_operand" "rR,Q")
+	      (match_operand:HI 2 "general_operand" "g,g")))
+  ]
+  ""
+  {
+    tms9900_debug_operands ("call_value", insn, operands, 3);
+    if(SIBLING_CALL_P(insn))
+      output_asm_insn("b    %1", operands);
+    else
+      output_asm_insn("bl   %1", operands);
+    return("");
+  }
+  [(set_attr "length" "2,4")]
+)
+
+;; The O2 and O3 optimise options replace BL @xxx with LI Ry,xxx and BL *Ry
+;; when the BL is inside a loop, even though the LI is also inside the loop,
+;; which makes it less efficient.  This peephole undoes this "optimisation"
+
+; There is an issue with this when the register used to hold the jump address
+; gets spilled to the stack.  The resulting attempt to do call @6[sp] fails of
+; course.  Popping from stack needs to go through a reg.  But why spill a label
+; address to stack?  That makes no sense.
+
+; This peephole is disabled due to the above failure.  It's recomended instead
+; to use -fno-function-cse to prevent gcc from replacing labels with regs
+
+; (define_peephole2
+;   [(set (match_operand:HI 0 "general_operand" "")
+; 	(match_operand:HI 1 "general_operand" ""))
+;    (set (match_operand:HI 2 "general_operand" "")
+; 	(call (mem:HI (match_dup 0))
+;               (match_operand:HI 3 "general_operand" "")))]
+;   ""
+;   [(set (match_dup 2)
+;         (call (mem:HI (match_dup 1))
+;               (match_dup 3)))]
+;   "")
+
+
+
+;;-------------------------------------------------------------------
+;; Define function prologue
+(define_expand "prologue"
+  [(const_int 0)]
+  ""
+{
+  tms9900_debug_operands ("prologue", NULL_RTX, NULL, 0);
+  tms9900_expand_prologue();
+  DONE;
+})
+
+
+;;-------------------------------------------------------------------
+;; Define function epilogue
+(define_expand "epilogue"
+  [(return)]
+  ""
+{
+  tms9900_debug_operands ("epilogue", NULL_RTX, NULL, 0);
+  tms9900_expand_epilogue(false);
+  DONE;
+})
+
+(define_expand "sibcall_epilogue"
+  [(return)]
+  ""
+{
+  tms9900_debug_operands ("sibcall_epilogue", NULL_RTX, NULL, 0);
+  tms9900_expand_epilogue(true);
+  DONE;
+})
+
+
+;;-------------------------------------------------------------------
+;; Define function return
+(define_insn "*rt"
+  [(unspec [(match_operand:HI 0 "general_operand" "")] UNSPEC_RETURN)]
+  ""
+  {
+    tms9900_debug_operands ("*rt", insn, operands, 1);
+    return("b    *r11");
+  }
+  [(set_attr "length" "2")])
+
+
+;;-------------------------------------------------------------------
+;;  Comparison Instructions
+;;-------------------------------------------------------------------
+
+;; cmp to zero is done explicitly or implicitly so can just do a mov to self to
+;; compare.  BUT if self is a ROM target then that could invoke unintended side
+;; effects like bank switching, so mov to temp reg r0 instead.  This also saves
+;; 2 bytes for mem label compares.
+
+;;-------------------------------------
+(define_insn "tsthi"
+  [(set (cc0)
+	(match_operand:HI 0 "nonimmediate_operand" "rR,Q"))]
+  ""
+  {
+    tms9900_debug_operands ("tsthi", insn, operands, 1);
+    return("mov  %0, r0");
+  }
+  [(set_attr "length" "2,6")])
+
+
+;;-------------------------------------
+(define_insn "tstqi"
+  [(set (cc0)
+	(match_operand:QI 0 "nonimmediate_operand" "rR,Q"))]
+  ""
+  {
+    tms9900_debug_operands ("tstqi", insn, operands, 1);
+    return("movb %0, r0");
+  }
+  [(set_attr "length" "2,6")])
+ 
+;;-------------------------------------
+;; Compare 2 16-bit values.
+;;
+;; If we are comparing a memory value to an immediate, it is cheaper to
+;; compare to a literal than load an immediate to a scratch reg and compare to that
+;; reg, so define insn as a split with the condition that op0 is not a reg and
+;; op1 is a constant int.  If so, rewrite as a compare to a forced mem const.
+
+(define_insn_and_split "cmphi"
+  [(set (cc0)
+	(compare (match_operand:HI 0 "nonimmediate_operand" "rR,rR,Q,Q,r")
+		 (match_operand:HI 1 "general_operand"      "rR,Q,rR,Q,i")))]
+  ""
+  {
+    tms9900_debug_operands ("split_cmphi", insn, operands, 2);
+
+    if (which_alternative < 4)
+      return "c    %0, %1";
+    else
+      return "ci   %0, %1";
+  }
+  "CONST_INT_P (operands[1]) && !REG_P (operands[0])"
+  [(set (cc0)
+	(compare (match_dup 0)
+		 (match_dup 1)))]
+  {
+    tms9900_debug_operands ("split_cmphi", NULL_RTX, operands, 2);
+
+    int val = INTVAL (operands[1]) & 0xffff;
+    operands[1] = force_const_mem (HImode, GEN_INT (val));
+  }
+  [(set_attr "length" "2,4,4,6,4")]
+)
+
+;;-------------------------------------
+;
+; TODO expand to nonimmediate, not just memory
+;
+;  Disabled - seems there are cases where this breaks code
+;
+; Replace:
+;   mov @x, r1
+;   cmp @y, r1
+;
+; With:
+;   cmp @y, @x
+
+; (define_peephole2
+;   [(set (match_operand:HI 0 "register_operand" "")
+; 	(match_operand:HI 1 "memory_operand" ""))
+;    (set (cc0)
+;         (compare (match_operand:HI 2 "memory_operand" "")
+;                  (match_dup 0)))]
+;   "peep2_reg_dead_p(3, operands[0])"
+;   [(set (cc0) 
+;         (compare (match_dup 2)
+;                  (match_dup 1)))]
+;   {
+;     tms9900_debug_operands ("peep-movhi-cmphi", NULL_RTX, operands, 3);
+;   }
+; )
+
+;;-------------------------------------
+;
+; Replace:
+;   movb @x,r1 
+;   cmpb @y,r1
+;
+; With:
+;   cmpb @y,@x
+
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "")
+	(match_operand:QI 1 "memory_operand" ""))
+   (set (cc0)
+        (compare (match_operand:QI 2 "memory_operand" "")
+                 (match_dup 0)))]
+  ""
+  [(set (cc0) 
+        (compare (match_dup 2)
+                 (match_dup 1)))]
+  {
+    tms9900_debug_operands ("peep-movqi-cmpqi", NULL_RTX, operands, 3);
+  }
+)
+
+;;-------------------------------------
+;; Compare 2 8-bit values.
+;;
+;; Byte compares using immediates are problematic since the lower 8 bits are
+;; unpredictable, so immediates are not allowed.  Compares to immediates are
+;; handled by a split which replaces the immediate with a memory ref to a literal.
+;;
+;; The exception for compare to zero has been removed as adding a clr
+;; instruction is longer than storing a zero byte in the constant pool 
+;; 
+;; Emitting a constant doesn't work if done as an insn.  Forcing a constant in an
+;; expand doesn't work either in all cases.  Defining a split caused a compliation
+;; abort when the cmpqi insn didn't have a match for a comparison to an immediate.
+;; Using define_insn_and_split seems to solve the problem for all cases so far.
+;;
+;; This is a good candidate for define_insn_and_rewrite but this doesn't exist yet
+;; in gcc4.4.0
+;;
+;; For some unknown reason, adding specific constraints here causes a reload error.
+;; Making a general constraint with a worst-case length of 6 bytes avoid the issue.
+
+(define_insn_and_split "cmpqi"
+  [(set (cc0)
+	(compare (match_operand:QI 0 "nonimmediate_operand" "=g")
+		 (match_operand:QI 1 "general_operand"      "g")))]
+  ""
+  "cb   %0, %1"
+  "CONST_INT_P (operands[1])"
+  [(set (cc0)
+ 	(compare (match_dup 0)
+ 		 (match_dup 1)))]
+  {
+    tms9900_debug_operands ("split_cmpqi", NULL_RTX, operands, 2);
+    int val = INTVAL (operands[1]) & 0xff;
+    operands[1] = force_const_mem (QImode, GEN_INT (val));
+  }
+  [(set_attr "length" "6")]
+)
+
+;;-------------------------------------
+;; Target specific insns to clr (set to 0) and seto (set to -1) for byte and
+;; word.  NOTE CLR and SETO operate on 16-bit values so QI variants are constrained
+;; to registers only
+
+(define_insn "tms9900_clrqi"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+        (const_int 0))]
+  ""
+  "clr  %0"
+  [(set_attr "length" "2")])
+
+(define_insn "tms9900_setoqi"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+        (const_int 255))]
+  ""
+  "seto %0"
+  [(set_attr "length" "2")])
+
+(define_insn "tms9900_clrhi"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
+        (const_int 0))]
+  ""
+  "clr  %0"
+  [(set_attr "length" "2,4")])
+
+(define_insn "tms9900_setohi"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
+        (const_int 65535))]
+  ""
+  "seto %0"
+  [(set_attr "length" "2,4")])
+
+;;-------------------------------------------------------------------
+;;  Move Operations
+;;-------------------------------------------------------------------
+  ; "movb %1, %0"
+  ;
+  ;  We need a constraint of i or we get the error "insn does not satisfy its
+  ; constraints".  Confusing since the split should remove the immediate.  If we
+  ; change general to nonimmed then we get "unrecognizable insn" so it seems we
+  ; need to add alternate 4 even though it never actually can be used.
+  ;
+  ; nvm setoqi had register_operand as constraint
+
+(define_expand "movqi"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "")
+        (match_operand:QI 1 "general_operand"      ""))]
+  ""
+  {
+    tms9900_debug_operands ("movqi", NULL_RTX, operands, 2);
+
+    if (CONST_INT_P (operands[1]))
+    {
+      int val = INTVAL (operands[1]) & 0xff;
+      if (val == 0 && REG_P (operands[0]))
+      {
+        emit_insn (gen_tms9900_clrqi (operands[0]));
+        DONE;
+      }
+
+      if (val == 0xff && REG_P (operands[0]))
+      {
+        emit_insn (gen_tms9900_setoqi (operands[0]));
+        DONE;
+      }
+
+      tms9900_inline_debug ("; movqi replace const with label\n");
+      operands[1] = force_const_mem (QImode, operands[1]);
+    }
+
+    emit_insn (gen_tms9900_movqi (operands[0], operands[1]));
+    DONE;
+  }
+)
+
+;;-------------------------------------------------------------------
+;; Native move byte value
+;;
+;; NOTE - this native method does not allow immediates
+
+(define_insn "tms9900_movqi"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=r,rR>,Q,  rR>,Q")
+        (match_operand:QI 1 "general_operand"      "r, rR>,rR>,Q,  Q"))]
+  ""
+  {
+    tms9900_debug_operands ("tms9900_movqi", insn, operands, 2);
+
+    /* Register to Register - If src has an offset, then it has been downgraded from a
+     * HI, so move the entire 16-bit word and do a byte swap */
+
+    if (which_alternative == 0 &&
+        REG_P (operands[1]) && REG_OFFSET (operands[1]) == 1 &&
+        ORIGINAL_REGNO (operands[1]) == REGNO (operands[1]))
+    {
+      output_asm_insn ("mov  %1, %0", operands);
+      output_asm_insn ("swpb %0 ; movqi subreg truncate", operands);
+    }
+    else
+      output_asm_insn ("movb %1, %0", operands);
+
+    return "";
+  }
+  [(set_attr "length" "4,2,4,4,6")]
+)
+
+; Attempting to do post inc through peephole or insn
+;
+; (define_peephole2
+;   [(set (mem:HI (match_operand:HI 0 "register_operand" ""))
+;         (match_operand:QI 1 "nonimmediate_operand" ""))
+;    (set (match_dup 0)
+;         (plus (match_dup 0) (const_int 1)))]
+;   ""
+;   TODO
+;
+; set (mem:SI (plus:SI (reg:SI 3) (const_int -16))P
+
+
+;  mem:QI (reg/f:HI 2 r2 [orig:21 x.0 ] [21]) [0 S1 A8])
+;         (reg:QI 1 r1 [ c ])) 11 {tms9900_movqi} (expr_list:REG_DEAD (reg:QI 1 r1 [ c ])
+;         (nil)))
+
+;        movb r1, *r2
+
+; addhi3-9 : (insn 9 8 19 <stdin>:4 (set (reg/f:HI 2 r2 [orig:21 x.0 ] [21])
+;         (plus:HI (reg/f:HI 2 r2 [orig:21 x.0 ] [21])
+;             (const_int 1 [0x1]))) 63 {addhi3} (nil))
+
+;;-------------------------------------------------------------------
+;; Move two-byte value
+;;
+;; Constraints O and M are listed as separate alternatives to allow SETO or CLR
+;; to be used which would have a different length to LI.  SETO and CLR can also
+;; work with R and Q.
+
+(define_expand "movhi"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "")
+        (match_operand:HI 1 "general_operand"      ""))]
+  ""
+  {
+    tms9900_debug_operands ("movhi", NULL_RTX, operands, 2);
+
+    if (CONST_INT_P (operands[1]))
+    {
+      int val = INTVAL(operands[1]) & 0xffff;
+
+      if (val == 0)
+      {
+        emit_insn (gen_tms9900_clrhi (operands[0]));
+        DONE;
+      }
+
+      if (val == 0xffff)
+      {
+        emit_insn (gen_tms9900_setohi (operands[0]));
+        DONE;
+      }
+
+      if (!REG_P (operands[0]))
+      {
+        tms9900_inline_debug ("; movhi replace const with label\n");
+        operands[1] = force_const_mem (HImode, operands[1]);
+      }
+    }
+
+    emit_insn (gen_tms9900_movhi (operands[0], operands[1]));
+    DONE;
+  }
+)
+
+(define_insn "tms9900_movhi"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,  Q,r")
+        (match_operand:HI 1 "general_operand"      "rR>, Q,  rR>,Q,i"))]
+  ""
+  {
+    tms9900_debug_operands ("movhi", insn, operands, 2);
+    tms9900_inline_debug ("; movhi alt=%d\n", which_alternative);
+
+    if (which_alternative == 4)
+    {
+      return("li   %0, %1");
+    }
+    else
+    {
+      return("mov  %1, %0");
+    }
+  }
+  [(set_attr "length" "2,4,4,6,4")])
+
+;;-------------------------------------------------------------------
+;; Move four-byte value as two 2-byte regs.  If immediate, emit two movhi insns
+;; with high and low part of constants.  Constraints O and M are allowed so we
+;; can issue seto or clr for -1 and 0 respectively
+;;
+;; Making this SI mov insn into an expand into 2 HI mov insns BUT since expands are
+;; not used in the optimisation passes, and expand can fail with unrecognisable insn
+;; is the optimiser actually does need to move a SI.
+;;
+;; Can use a split to break out constants but there does need to be an insn as well
+;;-------------------------------------------------------------------
+;; (define_insn_and_split "movsi"
+;;  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR>,rR>,Q,  Q,r, r")
+;;	(match_operand:SI 1 "general_operand"      "rR>, Q,  rR>,Q,OM,n"))]
+(define_expand "movsi"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "")
+	(match_operand:SI 1 "general_operand"      ""))]
+  ""
+  {
+    tms9900_debug_operands ("movsi", NULL_RTX, operands, 2);
+
+    rtx args[2];
+    if (CONST_INT_P (operands[1]))
+    {
+      /*  NOTE : for some strange reason, compilation aborts with unrecognizable insn for movhi if the value passed to
+       *  movhi is an
+       *  unsigned 16-bit qty between 0x8000 and 0xffff.  I'm guessing this must be something to do with some sign extension code
+       *  checking in gcc.  It works if a negative value is passed.  Since there is no gen_rtx_CONST_UINT I am creating
+       *  signed shorts as temps and then doing gen_rtx_CONST_INT on those.  It looks redundant, but Without this step, compilation fails. */
+      tms9900_inline_debug ("; movsi const\n");
+      int16_t hi, lo;
+      hi = (UINTVAL(operands[1])&0xffff0000)>>16;
+      lo = UINTVAL(operands[1])&0xffff;
+
+      // args[0] = gen_rtx_CONST_INT (HImode, ((UINTVAL(operands[1])&0xffff0000)>>16));
+      // args[1] = gen_rtx_CONST_INT (HImode, (UINTVAL(operands[1])&0xffff));
+      args[0] = gen_rtx_CONST_INT (HImode, hi);
+      args[1] = gen_rtx_CONST_INT (HImode, lo);
+    }
+    else
+    {
+    tms9900_inline_debug ("; movsi nonconst\n");
+      args[0] = gen_highpart(HImode, operands[1]);
+      args[1] = gen_lowpart(HImode, operands[1]);
+    }
+
+    // emit_move_insn (gen_highpart (HImode, operands[0]), args[0]);
+    // emit_move_insn (gen_lowpart (HImode, operands[0]), args[1]);
+    emit_insn (gen_tms9900_movhi (gen_highpart (HImode, operands[0]), args[0]));
+
+    // TODO temp comment out this to isolate unrecog. ffff works but fff9 doesn't.  That seems to imply 
+    // something going wrong with LMN constraints.  Is it that movsi uses n not i ?
+    // 0 works.  42 works. 32767 works, 32768 does not, -7 does
+
+    // args[1]=gen_rtx_CONST_INT(HImode,0xffff);
+    // args[1]=gen_rtx_CONST_INT(HImode,0xfff9);
+    // args[1]=gen_rtx_CONST_UINT(HImode,0xfff9);
+    // args[1]=gen_rtx_CONST_INT(HImode,0xfffffff9);
+    // args[1]=gen_rtx_CONST_INT(HImode,-7);
+    // args[1]=gen_rtx_CONST_INT(HImode,32768);
+    emit_insn (gen_tms9900_movhi (gen_lowpart (HImode, operands[0]), args[1]));
+    DONE;
+  })
+
+;; Called at later stage when expand isn't available
+
+(define_insn "tms9900_movsi"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR>,rR>,Q,  Q,r, r")
+	(match_operand:SI 1 "general_operand"      "rR>, Q,  rR>,Q,OM,n"))]
+  ""
+  {
+    tms9900_debug_operands ("tms9900_movsi", insn, operands, 2);
+    tms9900_inline_debug ("; tms9900_movsi alt=%d\n", which_alternative);
+
+    // Split the 32-bit op into 2 x 16-bit ops
+    rtx args[4];
+    args[0] = gen_highpart(HImode, operands[0]);
+    args[1] = gen_lowpart(HImode, operands[0]);
+    args[2] = gen_highpart(HImode, operands[1]);
+    args[3] = gen_lowpart(HImode, operands[1]);
+
+    if (which_alternative == 4)
+    {
+      if (INTVAL(operands[1]) == 0)
+      {
+        output_asm_insn ("clr  %0", args);
+        output_asm_insn ("clr  %1", args);
+      }
+      else if((INTVAL(operands[1]) & 0xFFFFFFFF) == 0xFFFFFFFF)
+      {
+        output_asm_insn ("seto  %0", args);
+        output_asm_insn ("seto  %1", args);
+      }
+      else
+        gcc_unreachable();
+    }
+    else if (which_alternative == 5)
+    {
+      output_asm_insn ("li   %0, %2", args);
+      output_asm_insn ("li   %1, %3", args);
+    }
+    else
+    {
+      output_asm_insn ("mov  %2, %0", args);
+      output_asm_insn ("mov  %3, %1", args);
+    }
+
+    return "";
+  }
+  [(set_attr "length" "4,8,8,12,4,8")])
+
+;;-------------------------------------------------------------------
+;; Type Conversions
+;;-------------------------------------------------------------------
+
+(define_insn "*zero_extendqihi2_subreg"
+  [(set (match_operand:HI 0 "register_operand" "=r,r,r")
+	(zero_extend:HI (subreg:HI (match_operand:QI 1 "nonimmediate_operand" "0,R,Q") 0)))]
+  ""
+  {
+    tms9900_debug_operands ("zero_extendqihi2_subreg", insn, operands, 2);
+
+    if (which_alternative > 0)
+    {
+      output_asm_insn ("movb %1, %0", operands);
+    }
+    output_asm_insn ("srl  %0, 8", operands);
+    return("");
+  }
+  [(set_attr "length" "2,4,6")])
+
+;;-------------------------------------------------------------------
+;; Zero Extend
+;; If op1 is not a register, we need to mov the value to op0 first.  As a
+;; result, R and Q constraints are different length to r.
+;;-------------------------------------
+
+(define_insn "zero_extendqihi2"
+  [(set (match_operand:HI 0 "register_operand" "=r,r,r")
+	(zero_extend:HI (match_operand:QI 1 "nonimmediate_operand" "0,R,Q")))]
+  ""
+  {
+    tms9900_debug_operands ("zero_extendqihi2", insn, operands, 2);
+
+    if (which_alternative > 0)
+    {
+      output_asm_insn ("movb %1, %0", operands);
+    }
+    output_asm_insn ("srl  %0, 8", operands);
+    return("");
+  }
+  [(set_attr "length" "2,4,6")])
+
+;;-------------------------------------
+; TODO Could do a gen_lowpart into op0 to prevent the tmp
+(define_expand "zero_extendqisi2"
+  [(set (match_operand:SI 0 "register_operand" "")
+	(zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "")))]
+  ""
+  {
+    tms9900_debug_operands ("zero_extendqisi2", NULL_RTX, operands, 2);
+    rtx tmp = gen_reg_rtx (HImode);
+    emit_insn (gen_zero_extendqihi2 (tmp, operands[1]));
+    emit_insn (gen_zero_extendhisi2 (operands[0], tmp));
+    DONE;
+  }
+)
+
+(define_insn "zero_extendhisi2"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR,Q")
+	(zero_extend:SI (match_operand:HI 1 "general_operand" "g,g")))]
+  ""
+  {
+    tms9900_debug_operands ("zero_extendhisi2", insn, operands, 2);
+    rtx args[3];
+    args[0] = gen_highpart (HImode, operands[0]);
+    args[1] = gen_lowpart (HImode, operands[0]);
+    args[2] = operands[1];
+
+    output_asm_insn("mov  %2, %1", args);
+    output_asm_insn("clr  %0", args);
+    return("");
+  }
+  [(set_attr "length" "4,8")])
+
+
+;;-------------------------------------------------------------------
+;; Sign Extend
+;;-------------------------------------------------------------------
+
+(define_insn "extendqihi2"
+  [(set (match_operand:HI 0 "register_operand" "=r,r,r")
+	(sign_extend:HI (match_operand:QI 1 "nonimmediate_operand" "0,R,Q")))]
+  ""
+  {
+    tms9900_debug_operands ("extendqihi2", insn, operands, 2);
+    if (which_alternative > 0)
+    {
+      output_asm_insn ("movb %1, %0", operands);
+    }
+    output_asm_insn("sra  %0, 8", operands);
+    return("");
+  }
+  [(set_attr "length" "2,4,6")])
+			 
+
+(define_expand "extendqisi2"
+  [(set (match_operand:SI 0 "register_operand" "")
+	(sign_extend:SI (match_operand:QI 1 "nonimmediate_operand" "")))]
+  ""
+  {
+    tms9900_debug_operands ("extendqisi2", NULL_RTX, operands, 2);
+    rtx tmp = gen_reg_rtx (HImode);
+    emit_insn (gen_extendqihi2 (tmp, operands[1]));
+    emit_insn (gen_extendhisi2 (operands[0], tmp));
+    DONE;
+  }
+)
+
+;;-------------------------------------
+(define_insn "extendhisi2"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR,Q")
+	(sign_extend:SI (match_operand:HI 1 "general_operand" "g,g")))]
+  ""
+  {
+    tms9900_debug_operands ("extendhisi2", insn, operands, 2);
+    rtx args[3];
+    rtx offset[1];
+    args[0] = gen_highpart (HImode, operands[0]);
+    args[1] = gen_lowpart (HImode, operands[0]);
+    args[2] = operands[1];
+
+    if(which_alternative == 1)
+      offset[0] = GEN_INT(6);
+    else
+      offset[0] = GEN_INT(4);
+
+    output_asm_insn("mov  %2, %1", args);
+    /* sign extend.  If highpart is negative, seto, else clr.  This is slightly
+     * cheaper (either 20 or 30 cycles) than doing sra 16 (44 cycles) */
+    output_asm_insn("seto %0", args);
+    output_asm_insn("jlt  $+%0", offset);
+    output_asm_insn("clr  %0", args);
+    return("");
+  }
+  [(set_attr "length" "8,12")])
+
+;;-------------------------------------------------------------------
+;; Truncate
+;
+;  swpb will suffice for non-strict in place truncation.  There is no strict variant of
+;  truncate so I am assuming we doesn't care about unused bits.
+;;-------------------------------------
+
+(define_insn "trunchiqi2"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,Q")
+	(truncate:QI (match_operand:HI 1 "nonimmediate_operand" "0,0")))]
+  ""
+  {
+    tms9900_debug_operands ("trunchiqi2", insn, operands, 2);
+    return ("swpb %0");
+  }
+  [(set_attr "length" "2,4")])
+
+;; Seeing unrecog for init HI with const in func taking long as param.  Test to see if this is because
+;; the const is a SI by adding constraings for i.  This shouldn't be affecting the matching though?
+(define_insn "truncsihi2"
+  [(set (match_operand:HI 0 "nonimmediate_operand"              "=rR>,rR>,Q,  Q")
+	(truncate:HI (match_operand:SI 1 "nonimmediate_operand" "rR>, Q,  rR>,Q")))]
+  ""
+  {
+    tms9900_debug_operands ("truncsihi2", insn, operands, 2);
+    operands[1] = gen_lowpart (HImode, operands[1]);
+    return "mov  %1, %0";
+  }
+  [(set_attr "length" "2,4,4,6")])
+
+(define_expand "truncsiqi2"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "")
+	(truncate:QI (match_operand:SI 1 "nonimmediate_operand" "")))]
+  ""
+  {
+    tms9900_debug_operands ("truncsiqi2", NULL_RTX, operands, 2);
+    emit_insn (gen_truncsihi2 (operands[0], operands[0]));
+    emit_insn (gen_trunchiqi2 (operands[0], operands[0]));
+    DONE;
+  }
+)
+
+;;-------------------------------------------------------------------
+;;  Branch Instructions
+;;-------------------------------------------------------------------
+
+
+;;-------------------------------------------------------------------
+;; Jump if equal
+(define_insn "beq"
+  [(set (pc)
+	(if_then_else (eq (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  {
+    tms9900_debug_operands ("beq", insn, operands, 1);
+    return(output_branch("jeq", "jne", get_attr_length(insn)));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 12)))])
+
+
+;;-------------------------------------
+;; Jump if equal, reversed comparison operands
+(define_insn "*beq_reversed"
+  [(set (pc)
+	(if_then_else (eq (cc0)
+			  (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  {
+    tms9900_debug_operands ("*beq_reversed", insn, operands, 1);
+    return(output_branch("jne", "jeq", get_attr_length(insn)));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 12)))])
+
+
+;;-------------------------------------------------------------------
+;; Jump if not equal
+(define_insn "bne"
+  [(set (pc)
+	(if_then_else (ne (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  {
+    tms9900_debug_operands ("bne", insn, operands, 1);
+    return output_branch(\"jne\", \"jeq\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 12)))])
+
+
+;;-------------------------------------
+;; Jump if not equal, reversed comparison operands
+(define_insn "*bne_reversed"
+  [(set (pc)
+	(if_then_else (ne (cc0)
+			  (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  {
+    tms9900_debug_operands ("*bne_reversed", insn, operands, 1);
+    return output_branch(\"jeq\", \"jne\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 12)))])
+
+
+;;-------------------------------------------------------------------
+;; Jump if unsigned less than
+(define_insn "bltu"
+  [(set (pc)
+	(if_then_else (ltu (cc0)
+			   (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  {
+    tms9900_debug_operands ("bltu", insn, operands, 1);
+    return output_branch(\"jl\", \"jhe\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 12)))])
+
+
+;;-------------------------------------
+;; Jump if unsigned less than, reversed comparison operands
+(define_insn "*bltu_reversed"
+  [(set (pc)
+	(if_then_else (ltu (cc0)
+			   (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  {
+    tms9900_debug_operands ("*bltu_reversed", insn, operands, 1);
+    return output_branch(\"jhe\", \"jl\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 12)))])
+
+
+;;-------------------------------------------------------------------
+;; Jump if unsigned less than or equal
+(define_insn "bleu"
+  [(set (pc)
+	(if_then_else (leu (cc0)
+			   (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  {
+    tms9900_debug_operands ("bleu", insn, operands, 1);
+    return output_branch(\"jle\", \"jh\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 12)))])
+
+
+;;-------------------------------------
+;; Jump if unsigned less than or equal, reversed comparison operands
+(define_insn "*bleu_reversed"
+  [(set (pc)
+	(if_then_else (leu (cc0)
+			   (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  {
+    tms9900_debug_operands ("*bleu_reversed", insn, operands, 1);
+    return output_branch(\"jh\", \"jle\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 12)))])
+
+
+;;-------------------------------------------------------------------
+;; Jump if unsigned greater than
+(define_insn "bgtu"
+  [(set (pc)
+	(if_then_else (gtu (cc0)
+			   (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  {
+    tms9900_debug_operands ("bgtu", insn, operands, 1);
+    return output_branch(\"jh\", \"jle\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 12)))])
+
+
+;;-------------------------------------
+;; Jump if unsigned greater than, reversed comparison operands
+(define_insn "*bgtu_reversed"
+  [(set (pc)
+	(if_then_else (gtu (cc0)
+			   (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  {
+    tms9900_debug_operands ("*bgtu_reversed", insn, operands, 1);
+    return output_branch(\"jle\", \"jh\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 12)))])
+
+
+;;-------------------------------------------------------------------
+;; Jump if unsigned greater than or equal
+(define_insn "bgeu"
+  [(set (pc)
+	(if_then_else (geu (cc0)
+			   (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  {
+    tms9900_debug_operands ("bgeu", insn, operands, 1);
+    return output_branch(\"jhe\", \"jl\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 12)))])
+
+
+;;-------------------------------------
+;; Jump if unsigned greater than or equal, reversed comparison operands
+(define_insn "*bgeu_reversed"
+  [(set (pc)
+	(if_then_else (geu (cc0)
+			   (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  {
+    tms9900_debug_operands ("*bgeu_reversed", insn, operands, 1);
+    return output_branch(\"jl\", \"jhe\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 12)))])
+
+
+;;-------------------------------------------------------------------
+;; Jump if less than
+(define_insn "blt"
+  [(set (pc)
+	(if_then_else (lt (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  {
+    tms9900_debug_operands ("blt", insn, operands, 1);
+    return output_branch(\"jlt\", \"GE\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 18)
+				      (const_int 12)))])
+
+
+;;-------------------------------------
+;; Jump if less than, reversed comparison operands
+; Was commented out
+(define_insn "*blt_reversed"
+  [(set (pc)
+	(if_then_else (lt (cc0)
+			  (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  {
+    tms9900_debug_operands ("*blt_reversed", insn, operands, 1);
+    return output_branch(\"GE\", \"jlt\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 14)))])
+
+
+;;-------------------------------------------------------------------
+;; Jump if less than or equal
+(define_insn "ble"
+  [(set (pc)
+	(if_then_else (le (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  {
+    tms9900_debug_operands ("ble", insn, operands, 1);
+    return output_branch(\"LE\", \"jgt\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 14)))])
+
+
+;;-------------------------------------
+;; Jump if less than or equal, reversed comparison operands
+(define_insn "*ble_reversed"
+  [(set (pc)
+	(if_then_else (le (cc0)
+			  (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  {
+    tms9900_debug_operands ("*ble_reversed", insn, operands, 1);
+    return output_branch(\"jgt\", \"LE\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 18)
+				      (const_int 12)))])
+
+
+;;-------------------------------------------------------------------
+;; Jump if greater than
+(define_insn "bgt"
+  [(set (pc)
+	(if_then_else (gt (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  {
+    tms9900_debug_operands ("bgt", insn, operands, 1);
+    return output_branch(\"jgt\", \"LE\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 18)
+				      (const_int 12)))])
+
+
+;;-------------------------------------
+;; Jump if greater than, reversed comparison operands
+; Was commented out
+(define_insn "*bgt_reversed"
+  [(set (pc)
+	(if_then_else (gt (cc0)
+			  (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  {
+    tms9900_debug_operands ("*bgt_reversed", insn, operands, 1);
+    return output_branch(\"LE\", \"jgt\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 14)))])
+
+
+;;-------------------------------------------------------------------
+;; Jump if greater than or equal
+; Was commented out
+(define_insn "bge"
+  [(set (pc)
+	(if_then_else (ge (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  {
+    tms9900_debug_operands ("bge", insn, operands, 1);
+    return output_branch(\"GE\", \"jlt\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 16)
+				      (const_int 14)))])
+
+
+;;-------------------------------------
+;; Jump if greater than or equal, reversed comparison operands
+(define_insn "*bge_reversed"
+  [(set (pc)
+	(if_then_else (ge (cc0)
+			  (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  {
+    tms9900_debug_operands ("*bge_reversed", insn, operands, 1);
+    return output_branch(\"jlt\", \"GE\", get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 18)
+				      (const_int 12)))])
+
+
+;;-------------------------------------------------------------------
+;;  Jump Operations
+;;-------------------------------------------------------------------
+
+
+;;-------------------------------------------------------------------
+;; Unconditional jump to label
+(define_insn "jump"
+  [(set (pc)
+	(label_ref (match_operand 0 "" "")))]
+  ""
+  {
+    tms9900_debug_operands ("jump", insn, operands, 1);
+    return output_jump(get_attr_length(insn));
+  }
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+						      (pc))
+					       (const_int -252))
+					   (ge (minus (match_dup 0)
+						      (pc))
+					       (const_int 256)))
+				      (const_int 14)
+				      (const_int 12)))])
+
+
+;;-------------------------------------------------------------------
+;; Unconditional jump using pointer
+(define_insn "indirect_jump"
+  [(set (pc) (match_operand:HI 0 "nonimmediate_operand" "r,Q"))]
+  ""
+  {
+    tms9900_debug_operands ("indirect_jump", insn, operands, 1);
+    return "b    %0";
+  }
+  [(set_attr "length" "2,4")])
+
+
+;;-------------------------------------------------------------------
+;; Unconditional jump using jump table
+(define_insn "tablejump"
+  [(set (pc) (match_operand:HI 0 "nonimmediate_operand" "rR,Q"))
+   (use (label_ref (match_operand 1 "" "")))]
+  ""
+  {
+    tms9900_debug_operands ("tablejump", insn, operands, 1);
+    output_asm_insn("mov  %0, r0", operands);
+    output_asm_insn("b    *r0",    operands);
+    return(""); 
+  }
+  [(set_attr "length" "4,6")])
+
+
+;;-------------------------------------------------------------------
+;;  Bit Shift Operations
+;;-------------------------------------------------------------------
+
+;; NOTE : On the TMS9900 a shift count of 0 is interpreted as
+;; shift by 16, so test for 0 and jump over the shift if true.  Do the same in
+;; all other shift by register insns as well.
+
+;; Accept any shift count but if it is not a constant, load it into r0 first.
+
+;; If we are asked to shift by a constant 0 then the
+;; compiler is being stupid so detect this (constraint 'O') and emit nothing
+
+;; The shift count may be a dropped extend subreg.  Detect this and shift right by 8
+
+;; It does not appear byte variants (ashrqi3 etc) are used.  Comment them out for now 
+
+;;-------------------------------------------------------------------
+;; Arithmetic shift left.
+;;
+;;-------------------------------------------------------------------
+(define_insn "ashlhi3"
+  [(set (match_operand:HI 0 "register_operand" "=r,r,r,r")
+	(ashift:HI (match_operand:HI 1 "register_operand" "0,0,0,0")
+		   (match_operand:HI 2 "general_operand" "rR,Q,O,i")))]
+  ""
+  {
+    tms9900_debug_operands ("ashlhi3", insn, operands, 3);
+
+    if(!CONST_INT_P (operands[2]))
+    {
+      output_asm_insn("mov  %2, r0",   operands);
+
+      if (tms9900_operand_subreg_offset (operands[2], HImode))
+      {
+        tms9900_inline_debug ("; ashlhi3, op[2] off %d\n", REG_OFFSET (operands[2]));
+        output_asm_insn ("sra  r0,8 ; ashrhi3 extend op2", operands);
+      }
+
+      output_asm_insn("jeq  $+4",    operands);
+      output_asm_insn("sla  %0, 0",  operands);
+    }
+    else
+    {
+      int count = INTVAL (operands[2]);
+
+      // TODO - check if this is correct - wouldn't a swpb be better?
+      /* If operand 1 is a subreg with an offset, then byte is in wrong place so
+       * subtract 8 from shift count.  If this results in a shift count of zero
+       * then do nothing. */
+      if (tms9900_operand_subreg_offset (operands[1], HImode))
+        count -= 8;
+
+      if ((count & 15) != 0)
+      {
+        operands[2] = GEN_INT (count);
+        output_asm_insn("sla  %0, %2", operands);
+      }
+    }
+    return(""); 
+  }
+  [(set_attr "length" "6,8,0,2")])
+
+
+;;-------------------------------------
+(define_insn "ashrhi3"
+  [(set (match_operand:HI 0 "register_operand" "=r,r,r,r")
+	(ashiftrt:HI (match_operand:HI 1 "register_operand" "0,0,0,0")
+		     (match_operand:HI 2 "general_operand" "rR,Q,O,i")))]
+  ""
+  {
+    tms9900_debug_operands ("ashrhi3", insn, operands, 3);
+    if(which_alternative < 2)
+    {
+      output_asm_insn("mov  %2, r0",   operands);
+
+      if (tms9900_operand_subreg_offset (operands[2], HImode))
+      {
+        tms9900_inline_debug ("; ashrhi3, op[2] off %d\n", REG_OFFSET (operands[2]));
+        output_asm_insn ("sra  r0,8 ; ashrhi3 extend op2", operands);
+      }
+
+      output_asm_insn("jeq  $+4",    operands);
+      output_asm_insn("sra  %0, 0",  operands);
+    }
+    else if (which_alternative > 2)
+    {
+      // TODO couldn't this be a subreg as per ashlhi3 ?
+      output_asm_insn("sra  %0, %2", operands);
+    }
+    return(""); 
+  }
+  [(set_attr "length" "6,8,0,2")])
+
+;;-------------------------------------
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "r,r")
+	(sign_extend:HI(match_operand:QI 1 "register_operand" "r,r")))
+   (set (match_operand:HI 3 "register_operand" "r,r")
+	(ashiftrt:HI (match_operand:HI 4 "register_operand" "0,0")
+		     (match_operand:HI 5 "general_operand" "rRQ,i")))
+   (set (match_operand:QI 6 "register_operand" "r,r")
+        (subreg:QI (match_operand:HI 7 "register_operand" "3,3") 1))]
+  ""
+  [(set (match_dup 6)
+        (match_dup 1))
+   (set (match_dup 6)
+        (ashiftrt:QI (match_dup 6)
+                     (match_dup 5)))]
+  {
+    tms9900_debug_operands ("peep-asrhi", NULL_RTX, operands, 8);
+  }
+)
+
+
+;;-------------------------------------------------------------------
+;; Logical shift right
+
+
+
+;;-------------------------------------
+(define_insn "lshrhi3"
+  [(set (match_operand:HI 0 "register_operand" "=r,r,r,r")
+	(lshiftrt:HI (match_operand:HI 1 "register_operand" "0,0,0,0")
+		     (match_operand:HI 2 "general_operand" "rR,Q,O,i")))]
+  ""
+  {
+    tms9900_debug_operands ("lshrhi3", insn, operands, 3);
+    if(which_alternative < 2)
+    {
+      output_asm_insn("mov  %2, r0",  operands);
+
+      if (tms9900_operand_subreg_offset (operands[2], HImode))
+      {
+        tms9900_inline_debug ("; lshrhi3, op[2] off %d\n", REG_OFFSET (operands[2]));
+        output_asm_insn ("sra  r0,8 ; lshrhi3 extend op2", operands);
+      }
+
+      output_asm_insn("jeq  $+4",    operands);
+      output_asm_insn("srl  %0, 0",  operands);
+    }
+    else if (which_alternative > 2)
+    {
+      output_asm_insn("srl  %0, %2", operands);
+    }
+    return(""); 
+  }
+  [(set_attr "length" "6,8,0,2")])
+
+
+;;-------------------------------------
+; shift right 8 (extend) followed by truncate (swpb) negate each other so remove
+; by emitting a nop (const_int 0)
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "")
+	(lshiftrt:HI (match_dup 0)
+		     (const_int 8)))
+   (set (match_operand:QI 1 "register_operand" "")
+	(truncate:QI(match_dup 0)))]
+  ""
+  [(const_int 0)]
+  {
+    tms9900_debug_operands ("peep-lsrhi", NULL_RTX, operands, 2);
+  }
+)
+
+;;-------------------------------------
+; same for arith shift 8
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "")
+	(ashiftrt:HI (match_dup 0)
+		     (const_int 8)))
+   (set (match_operand:QI 1 "register_operand" "")
+	(truncate:QI(match_dup 0)))]
+  ""
+  [(const_int 0)]
+  {
+    tms9900_debug_operands ("peep-asrhi", NULL_RTX, operands, 2);
+  }
+)
+
+;;-------------------------------------
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "r,r")
+	(sign_extend:HI(match_operand:QI 1 "register_operand" "r,r")))
+   (set (match_operand:HI 3 "register_operand" "r,r")
+	(lshiftrt:HI (match_operand:HI 4 "register_operand" "0,0")
+		     (match_operand:HI 5 "general_operand" "rRQ,i")))
+   (set (match_operand:QI 6 "register_operand" "r,r")
+        (subreg:QI (match_operand:HI 7 "register_operand" "3,3") 1))]
+  ""
+  [(set (match_dup 6)
+        (match_dup 1))
+   (set (match_dup 6)
+        (lshiftrt:QI (match_dup 6)
+                     (match_dup 5)))]
+  {
+    tms9900_debug_operands ("peep-lsrhi", NULL_RTX, operands, 8);
+  }
+)
+
+;;-------------------------------------------------------------------
+;; Rotate - not used?
+
+;;-------------------------------------------------------------------
+;;  Bitwise Operations
+;;-------------------------------------------------------------------
+
+;;-------------------------------------------------------------------
+;; And
+;;
+;; Uses r0 as a clobber
+;;-------------------------------------
+(define_insn "andhi3"
+  [(set (match_operand:HI 0 "nonimmediate_operand"         "=rR>,rR>,Q,  Q,r,r,r,R>,Q")
+	(and:HI (match_operand:HI 1 "nonimmediate_operand" "0,   0,  0,  0,0,0,0,0, 0")
+		(match_operand:HI 2 "general_operand"      "rR>, Q,  rR>,Q,O,M,i,i, i")))]
+  ""
+  {
+    tms9900_debug_operands ("andhi3", insn, operands, 3);
+
+    /*  If the optimiser sees that we are doing an and operation with a constant
+     *  that is 0xFF or less then it assumes there is no need to extend any byte
+     *  parameters.  This is not true for tms9900 as we need to shift the MSB
+     *  into the LSB.  Check for offsets in the operands and emit shifts to get
+     *  the bytes into the right place. */
+
+    if (tms9900_operand_subreg_offset (operands[1], HImode))
+    {
+      tms9900_inline_debug ("; andhi3, op[1] off %d\n", REG_OFFSET (operands[1]));
+
+      /*  If the mask is a constant int of one byte then cheaper to do a swpb
+       *  than sra. */
+      if (CONST_INT_P (operands[2]) &&
+          (INTVAL (operands[2]) & 0xff) == INTVAL (operands[2]))
+        output_asm_insn ("swpb %1 ; andhi extend op1", operands);
+      else
+        output_asm_insn ("sra  %1,8 ; andhi extend op1", operands);
+    }
+
+    if(which_alternative == 4)
+    {
+      /* Some paranoia here - confirm O constraint really has given us a const int of
+       * zero */
+      if (!CONST_INT_P (operands[2]) || (INTVAL(operands[2]) & 0xFFFF) != 0)
+        gcc_unreachable();
+
+      /* Result will be zero */
+      return("clr  %0");
+    }
+    else if(which_alternative == 5)
+    {
+      if (!CONST_INT_P (operands[2]) || (INTVAL(operands[2]) & 0xFFFF) != 0xFFFF)
+        gcc_unreachable();
+
+      /* No operation required */
+      return("");
+    }
+    else if(which_alternative == 6)
+    {
+      /* AND const value and register */
+      output_asm_insn("andi %0, %2", operands);
+    }
+    else if(which_alternative >= 7)
+    {
+      /* AND const value and memory */
+      if (!CONST_INT_P (operands[2]))
+        gcc_unreachable();
+
+      int val = ~INTVAL(operands[2]);
+      operands[2] = GEN_INT(val & 0xFFFF);
+      output_asm_insn("li   r0, %2", operands);
+      output_asm_insn("szc  r0, %0", operands);
+    }
+    else
+    {
+      /* AND against non-const value.  Copy to R0 as clobber, invert and SZC */
+      output_asm_insn("mov  %2, r0", operands);
+      output_asm_insn("inv  r0",     operands);
+      output_asm_insn("szc  r0, %0", operands);
+    }
+    return(""); 
+  }
+  [(set_attr "length" "6,8,8,10,2,0,4,6,8")])
+
+
+(define_insn "*andnothi"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
+	(and:HI (match_operand:HI 1 "nonimmediate_operand" "0,0,0,0")
+		(not:HI (match_operand:HI 2 "nonimmediate_operand" "rR>,Q,rR>,Q"))))]
+  ""
+  {
+    tms9900_debug_operands ("*andnothi", insn, operands, 3);
+    return "szc  %2, %0";
+  }
+  [(set_attr "length" "2,4,4,6")])
+
+
+; This handles reverse-order not-and combinations
+(define_insn "*not_andhi"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
+	(and:HI (not:HI (match_operand:HI 1 "nonimmediate_operand" "rR>,Q,rR>,Q"))
+                (match_operand:HI 2 "nonimmediate_operand" "0,0,0,0")))]
+  ""
+  {
+    tms9900_debug_operands ("*not_andhi", insn, operands, 3);
+    return "szc  %1, %0";
+  }
+  [(set_attr "length" "2,4,4,6")])
+
+
+;;-------------------------------------
+;;
+;; NOTE - we assume that constraint 'i' will only pass a CONST_INT as labels
+;; etc don't make sense in the context of a byte operation.  Assert if assumption
+;; not true.  If the constant evaluates to 0x00 or 0xFF then apply a short circuit.
+;; This will mean length is shorter than declared but that should not matter.
+;;
+(define_insn "andqi3"
+  [(set (match_operand:QI 0 "nonimmediate_operand"         "=rR>,rR>,Q,  Q,r,R>,Q")
+	(and:QI (match_operand:QI 1 "nonimmediate_operand" "0,   0,  0,  0,0,0, 0")
+		(match_operand:QI 2 "general_operand"      "rR>, Q,  rR>,Q,i,i, i")))]
+  ""
+  {
+    tms9900_debug_operands ("andqi3", insn, operands, 3);
+    if(which_alternative >= 4)
+    {
+      if (!CONST_INT_P (operands[2]))
+        gcc_unreachable();
+
+      int val = (INTVAL(operands[2]) << 8) & 0xFF00;
+
+      /* AND const value and register */
+      if(val == 0xff00)
+        return("");
+
+      if (which_alternative == 4)
+      {
+        /* AND const value and register */
+        operands[2] = GEN_INT(val);
+        output_asm_insn ("andi %0, %2", operands);
+      }
+      else
+      {
+        /* AND const value and memory */
+        operands[2] = GEN_INT(~val);
+        output_asm_insn("li   r0, %2", operands);
+        output_asm_insn("szcb r0, %0", operands);
+      }
+    }
+    else
+    {
+      output_asm_insn("movb %2, r0", operands);
+      output_asm_insn("inv  r0", operands);
+      output_asm_insn("szcb r0, %0", operands);
+    }
+    return("");
+  }
+  [(set_attr "length" "6,8,8,10,4,6,8")])
+
+
+(define_insn "*andnotqi"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
+	(and:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0")
+		(not:QI (match_operand:QI 2 "nonimmediate_operand" "rR>,Q,rR>,Q"))))]
+  ""
+  {
+    tms9900_debug_operands ("*not_andhi", insn, operands, 3);
+    return "szcb %2, %0";
+  }
+  [(set_attr "length" "2,4,4,6")])
+
+
+; This handles reverse-order not-and combinations
+(define_insn "*not_andqi"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
+	(and:QI (not:QI (match_operand:QI 1 "nonimmediate_operand" "rR>,Q,rR>,Q"))
+                (match_operand:QI 2 "nonimmediate_operand" "0,0,0,0")))]
+  ""
+  {
+    tms9900_debug_operands ("*not_andhi", insn, operands, 3);
+    return "szcb %1, %0";
+  }
+  [(set_attr "length" "2,4,4,6")])
+
+
+;;-------------------------------------------------------------------
+;; Or
+
+
+;;-------------------------------------
+(define_insn "iorhi3"
+  [(set (match_operand:HI 0 "nonimmediate_operand"         "=rR>,rR>,Q,  Q,r,r,r")
+	(ior:HI (match_operand:HI 1 "nonimmediate_operand" "%0,  0,  0,  0,0,0,0")
+		(match_operand:HI 2 "general_operand"      "rR>, Q,  rR>,Q,O,M,n")))]
+  ""
+  {
+    tms9900_debug_operands ("iorhi3", insn, operands, 3);
+
+    if (which_alternative < 4)
+      return("soc  %2, %0");
+    else
+    {
+      if (!CONST_INT_P (operands[2]))
+        gcc_unreachable();
+
+      int val = INTVAL(operands[2]) & 0xFFFF;
+      if(val == 0xFFFF)
+        return "seto %0";
+      else if(val == 0)
+        return "";
+
+      return "ori  %0, %2";
+    }
+  }
+  [(set_attr "length" "2,4,4,6,0,2,4")])
+
+
+;;-------------------------------------
+(define_insn "iorqi3"
+   [(set (match_operand:QI 0 "nonimmediate_operand"        "=rR>,Q,  rR>,Q,r")
+	(ior:QI (match_operand:QI 1 "nonimmediate_operand" "0,   0,  0,  0,0")
+		(match_operand:QI 2 "general_operand"      "rR>, rR>,Q,  Q,n")))]
+  ""
+  {
+    tms9900_debug_operands ("iorqi3", insn, operands, 3);
+
+    if (which_alternative < 4)
+      return ("socb %2, %0");
+    else
+    {
+      if (!CONST_INT_P (operands[2]))
+        gcc_unreachable();
+
+      int val = (INTVAL(operands[2]) << 8) & 0xFF00;
+      tms9900_inline_debug ("; iorqi3 val=%X\n", val);
+      rtx args[2];
+      args[0] = operands[0];
+      args[1] = GEN_INT(val);
+      /* AND const value and register */
+      if(val == 0)
+        return("");
+      else if(val == 0xff00)
+        output_asm_insn("seto %0", args);
+      else
+        output_asm_insn("ori  %0, %1", args);
+    }
+    return("");
+  }
+  [(set_attr "length" "2,4,4,6,4")])
+
+
+;;-------------------------------------------------------------------
+;; Xor
+
+
+;;-------------------------------------
+(define_insn "xorhi3"
+  [(set (match_operand:HI 0 "register_operand" "=r,r")
+	(xor:HI (match_operand:HI 1 "register_operand" "%0,0")
+		(match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
+  ""
+  {
+    tms9900_debug_operands ("xorhi3", insn, operands, 3);
+    return "xor  %2, %0";
+  }
+  [(set_attr "length" "2,4")])
+
+
+;;-------------------------------------
+;; This works for regs only as xor is 16-bit only and should not be used on
+;; memory locations as it will affect the neighbouring byte
+(define_insn "xorqi3"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+	(xor:QI (match_operand:QI 1 "register_operand" "%0")
+		(match_operand:QI 2 "nonimmediate_operand" "r")))]
+  ""
+  {
+    tms9900_debug_operands ("xorqi3", insn, operands, 3);
+    return "xor  %2, %0";
+  }
+  [(set_attr "length" "2")])
+
+
+;;-------------------------------------------------------------------
+;; Not
+;;-------------------------------------
+(define_insn "one_cmplhi2"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
+        (not:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))]
+  ""
+  {
+    tms9900_debug_operands ("one_cmplhi2", insn, operands, 2);
+    return "inv  %0";
+  }
+  [(set_attr "length" "2,4")])
+
+
+;;-------------------------------------
+;; This works for regs only as inv is 16-bit only and should not be used on
+;; memory locations as it will affect the neighbouring byte
+(define_insn "one_cmplqi2"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=r")
+        (not:QI (match_operand:QI 1 "nonimmediate_operand" "0")))]
+  ""
+  {
+    tms9900_debug_operands ("one_cmplqi2", insn, operands, 2);
+    return "inv  %0";
+  }
+  [(set_attr "length" "2")])
+
+
+;;-------------------------------------------------------------------
+;;  Arithmetic Operations
+;;-------------------------------------------------------------------
+
+
+;;-------------------------------------------------------------------
+;; Add
+;;
+;; Define addhi3 as an insn and split.  If operand[2] is a constant and
+;; operand[0] is not a register, then it is cheaper to add a memory constant than
+;; to load into an intermediate register and do add immediate.
+;;
+;; The constraints LMN are broken out separately as these can be done using
+;; inc[t] or dec[t] directly on a reg or memory location.
+;;
+;; The first two constraints with a dest of register only try to catch a missing
+;; extend where a subreg with an offset is passed in either operands[1] or
+;; operands[2].  This needs to be corrected using SRA.  A subreg with an offset
+;; will only appear in a register.  It is also assumed this will only happen
+;; when the destination is a register.
+;;-------------------------------------
+(define_insn_and_split "addhi3"
+  [(set (match_operand:HI 0 "nonimmediate_operand"          "=r, r,rR>,Q,  r,R>, R>,Q,  Q")
+	(plus:HI (match_operand:HI 1 "nonimmediate_operand" "%0, 0,0,  0,  0,0,  0, 0,  0")
+		 (match_operand:HI 2 "general_operand"      "rR>,Q,LMN,LMN,i,rR>,Q, rR>,Q")))]
+  ""
+  {
+    tms9900_debug_operands ("addhi3", insn, operands, 3);
+    tms9900_inline_debug ("; addhi3, alt=%d\n", which_alternative);
+
+    /* Either op[1] or op[2] may be a subreg with an offset. Correct them
+     * first.  Worst case length for these alternatives are 8 and 10 bytes */
+
+    if (tms9900_operand_subreg_offset (operands[2], HImode))
+    {
+      tms9900_inline_debug ("; addhi3, op[2] off %d\n", REG_OFFSET (operands[2]));
+      if (!find_regno_note (insn, REG_DEAD, REGNO (operands[2])))
+      {
+        /* operands[2] has an offset but is not dead so we cannot change it.
+         * Move to an intermediate and swap there.  Replace op[2] with
+         * scratch reg R0 */
+        output_asm_insn ("mov  %2,r0 ; addhi op2 to scratch", operands);
+        output_asm_insn ("sra  r0,8 ; addhi extend op2", operands);
+        operands[2] = gen_rtx_REG (HImode, HARD_R0_REGNUM);
+      }
+      else
+      {
+        /* operands[2] dies here so extend in place */
+        output_asm_insn ("sra  %2,8 ; addhi extend op2", operands);
+      }
+    }
+
+    /* check for subreg in operand[1].  If the source register is the same as
+     * the original register, or the original is a not mem expression, then
+     * the offset refers to the register, so correction is needed */
+    if (tms9900_operand_subreg_offset (operands[1], HImode))
+    {
+      tms9900_inline_debug ("; addhi3, op[1] off %d\n", REG_OFFSET (operands[1]));
+      output_asm_insn ("sra  %1,8 ; addhi extend op1", operands);
+    }
+
+    if (which_alternative == 2 || which_alternative == 3)
+    {
+      switch(INTVAL(operands[2]))
+      {
+      case 1:  return("inc  %0");
+      case -1: return("dec  %0");
+      case 2:  return("inct %0");
+      case -2: return("dect %0");
+      default: gcc_unreachable();
+      }
+    }
+    else if (which_alternative == 4)
+      return("ai   %0, %2");
+    else
+      return ("a    %2, %0");
+  }
+  "CONST_INT_P (operands[2]) && !REG_P (operands[0])"
+  [(set (match_dup 0)
+	(plus:HI (match_dup 1)
+		 (match_dup 2)))]
+  {
+    tms9900_debug_operands ("split_addhi3", NULL_RTX, operands, 2);
+
+    /*  Only force a constant if it is not a value we could use inc[t] or dec[t]
+     *  instead. */
+    if (INTVAL (operands[2]) < -2 && INTVAL (operands[2]) > 2)
+        operands[2] = force_const_mem (HImode, operands[2]);
+  }
+  [(set_attr "length" "8,10,4,2,2,2,4,4,6")])
+
+
+;;-------------------------------------
+;; Add byte non immediate
+;;
+;; Immediates are not allowed here.  The expand will have replaced them with mem
+;; consts
+;;-------------------------------------
+(define_insn "tms9900_addqi3"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
+	(plus:QI (match_operand:QI 1 "nonimmediate_operand" "%0,0,0,0")
+		 (match_operand:QI 2 "general_operand" "rR>,Q,rR>,Q")))]
+  ""
+  {
+    tms9900_debug_operands ("tms9900_addqi3", insn, operands, 3);
+    return("ab   %2, %0");
+  }
+  [(set_attr "length" "2,4,4,6")])
+
+;;-------------------------------------
+;; Add byte
+;;
+;; Expand that ensures op0 == op1 and replaces an immediate op2 with a mem const
+;;-------------------------------------
+(define_expand "addqi3"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "")
+	(plus:QI (match_operand:QI 1 "nonimmediate_operand" "")
+		 (match_operand:QI 2 "general_operand" "")))]
+  ""
+  {
+    tms9900_debug_operands ("addqi3", NULL_RTX, operands, 3);
+    if (!rtx_equal_p (operands[0], operands[1]))
+    {
+      if (!rtx_equal_p (operands[0], operands[2]))
+      {
+        // We have 3 distinct operands.  Copy op1 to op0 and then proceed
+        emit_move_insn (operands[0], operands[1]);
+      }
+      else
+      {
+        // op0 and op2 are the same but we need op0 and op1 to be the same so
+        // swap 1 and 2
+        rtx tmp = operands[1];
+        operands[1] = operands[2];
+        operands[2] = tmp;
+      }
+    }
+
+    if (CONST_INT_P (operands[2]))
+    {
+      tms9900_inline_debug ("; addqi3 replace const with label\n");
+      operands[2] = force_const_mem (QImode, operands[2]);
+    }
+
+    emit_insn (gen_tms9900_addqi3 (operands[0], operands[1], operands[2]));
+    DONE;
+  }
+)
+
+;;-------------------------------------------------------------------
+;; Subtract
+;;
+;; See comment on addhi3
+;;
+;; Immediates are not allowed; they will be handled by negating the constant and
+;; adding with addhi3
+;;
+;; As with addhi3, the first two constraints break out op0 as a register to
+;; allow a more conservative length when subreg offset corrections are applied.
+;;
+;; NOTE: no @ on constraints for op1 as subtract is not commutative
+;;-------------------------------------
+(define_insn "subhi3"
+  [(set (match_operand:HI 0 "nonimmediate_operand"           "=r, r,R>, R>,Q,  Q")
+        (minus:HI (match_operand:HI 1 "nonimmediate_operand" "0,  0,0,  0, 0,  0")
+                  (match_operand:HI 2 "nonimmediate_operand" "rR>,Q,rR>,Q, rR>,Q")))]
+  ""
+  {
+    tms9900_debug_operands ("subhi3", insn, operands, 3);
+    tms9900_inline_debug ("; addhi3, alt=%d\n", which_alternative);
+
+    /* Either op[1] or op[2] may be a subreg with an offset. Correct them
+     * first.  Worst case length for these alternatives are 8 and 10 bytes */
+
+    if (tms9900_operand_subreg_offset (operands[2], HImode))
+    {
+      tms9900_inline_debug ("; subhi3, op[2] off %d\n", REG_OFFSET (operands[2]));
+      if (!find_regno_note (insn, REG_DEAD, REGNO (operands[2])))
+      {
+        /* operands[2] has an offset but is not dead so we cannot change it.
+         * Move to an intermediate and swap there.  Replace op[2] with
+         * scratch reg R0 */
+        output_asm_insn ("mov  %2,r0 ; subhi op2 to scratch", operands);
+        output_asm_insn ("sra  r0,8 ; subhi extend op2", operands);
+        operands[2] = gen_rtx_REG (HImode, HARD_R0_REGNUM);
+      }
+      else
+      {
+        /* operands[2] dies here so extend in place */
+        output_asm_insn ("sra  %2,8 ; subhi extend op2", operands);
+      }
+    }
+
+    /* check for subreg in operand[1]. */
+    if (tms9900_operand_subreg_offset (operands[1], HImode))
+    {
+      tms9900_inline_debug ("; subhi3, op[1] off %d\n", REG_OFFSET (operands[1]));
+      output_asm_insn ("sra  %1,8 ; addhi extend op1", operands);
+    }
+
+    return "s    %2, %0";
+  }
+  [(set_attr "length" "8,10,2,4,4,6")])
+
+;;-------------------------------------
+;; Reverse subtract
+;;
+;; This case covers subtracting a register from an immediate by adding the
+;; immediate and then negating the result.
+;;
+;; Reduces +/-1 and +/-2 to inc(t) or dec(t)
+;;-------------------------------------
+
+(define_insn "tms9900_rsubihi"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(minus:HI (match_operand:HI 1 "immediate_operand" "i")
+		  (match_operand:HI 2 "register_operand" "0")))]
+  ""
+  {
+    tms9900_debug_operands ("tms9900_rsubihi", insn, operands, 3);
+    if (INTVAL(operands[1]) == -1)
+      output_asm_insn("inc  %0",operands);
+    else if (INTVAL(operands[1]) == 1)
+      output_asm_insn("dec  %0",operands);
+    else if (INTVAL(operands[1]) == -2)
+      output_asm_insn("inct %0",operands);
+    else if (INTVAL(operands[1]) == 2)
+      output_asm_insn("dect %0",operands);
+    else
+    {
+      operands[1] = GEN_INT(-INTVAL(operands[1]));
+      output_asm_insn("ai   %0, %1",operands);
+    }
+    output_asm_insn("neg  %0",operands);
+    return "";
+  }
+  [(set_attr "length" "6")])
+
+;;-------------------------------------
+;; op0 = op1 - op2(i)      movb op1,op0 
+;;                         sb op2,op0
+;; 
+;; op0 = op1(i) - op2      movb op2,op0
+;;                         neg op0
+;;                         ab op1,op0
+;; 
+;; op0 = op0 - op2         sb op2,op0
+;; 
+;; op0 = op1 - op0         neg op0 
+;;                         ab op1,op0
+;;
+;; no immediates - removed by expand
+;; we don't need to be concerned with subtract immediate, the compiler will
+;;   negate the constant and do an add
+;; if operation is subtract from then we need to negate the result but the neg
+;; opcode is 16-bit only so if the target is not a register we need to use r0 as a
+;; scratch for the negation
+;;-------------------------------------
+(define_insn "tms9900_subqi3"
+  [(set (match_operand:QI 0 "nonimmediate_operand"           "=rR>,Q,  rR>,Q,rR>,Q,  rR>,Q")
+	(minus:QI (match_operand:QI 1 "nonimmediate_operand" "0,   0,  0,  0,rR>,rR>,Q,  Q")
+		  (match_operand:QI 2 "nonimmediate_operand" "rR>, rR>,Q,  Q,0,  0,  0,  0")))]
+  ""
+  {
+    tms9900_debug_operands ("tms9900_subqi3", insn, operands, 3);
+    if(which_alternative < 4)
+    {
+      output_asm_insn("sb   %2, %0",operands);
+    }
+    else // if (which_alternative < 6)
+    {
+      // NOTE - subtracting from a number is the same as negating and adding but since we are a byte operation we don't
+      // know the contents of the LSB.  So use inv instead of neg to ensure the value in the LSB does not contribute to
+      // the negation.  Inverting requires adding one so add 0x100 in the case of bytes - yuk!
+      //
+      // Probably easier just to swap the bytes - lets try that
+
+      // op0 = op1 - op0
+      // sb op0,op1 puts result in op1 which is not what we want so put op1 into r0 first
+
+      output_asm_insn("movb %1,0",operands);
+      output_asm_insn("sb   %0,0",operands);
+      output_asm_insn("movb 0,%0",operands);
+    }
+    #if 0
+    else
+    {
+      // subtract non reg from non reg  x = y - x 
+      // op0 = op1 - op0
+      output_asm_insn("mov  %0,0",operands);
+      output_asm_insn("inv  0",operands);
+      output_asm_insn("ab   %1,0",operands);
+      output_asm_insn("movb 0,%0",operands);
+    }
+    #endif
+    return "";
+  }
+  [(set_attr "length" "2,4,4,6,6,10,8,12")])
+
+(define_expand "subqi3"
+  [(set (match_operand:QI 0 "nonimmediate_operand"      "")
+	(minus:QI (match_operand:QI 1 "general_operand" "")
+		  (match_operand:QI 2 "general_operand" "")))]
+  ""
+  {
+    tms9900_debug_operands ("subqi3", NULL_RTX, operands, 3);
+
+    if (CONST_INT_P (operands[1]))
+    {
+      tms9900_inline_debug ("; subqi3 replace const with label\n");
+      operands[1] = force_const_mem (QImode, operands[1]);
+    }
+
+    if (CONST_INT_P (operands[2]))
+    {
+      tms9900_inline_debug ("; subqi3 replace const with label\n");
+      operands[2] = force_const_mem (QImode, operands[2]);
+    }
+
+    emit_insn (gen_tms9900_subqi3 (operands[0], operands[1], operands[2]));
+    DONE;
+  }
+)
+
+;;-------------------------------------------------------------------
+;; Multiply
+;;
+;;-------------------------------------
+; Expand for signed HI = QI x QI
+; TODO check sign of highpart of HI
+(define_expand "mulqihi3"
+   [(set (match_operand:HI 0 "register_operand" "=r")
+        (mult:HI (match_operand:QI 1 "register_operand" "r")
+                 (match_operand:QI 2 "register_operand" "rRQ>")))]
+  ""
+  {
+    tms9900_debug_operands ("mulqihi3", NULL_RTX, operands, 3);
+
+    rtx result = gen_reg_rtx (SImode);
+    rtx op1 = gen_reg_rtx (HImode);
+    rtx op2 = gen_reg_rtx (HImode);
+    emit_insn (gen_extendqihi2 (op1, operands[1]));
+    emit_insn (gen_extendqihi2 (op2, operands[2]));
+    emit_move_insn(gen_highpart (HImode, result), op1);
+    // emit_insn (gen_tms9900_movhi (gen_highpart (HImode, result), op1));
+    emit_insn (gen_tms9900_mulhisi3 (result, result, op2));
+    emit_move_insn (operands[0], gen_lowpart (HImode, result));
+    // emit_insn (gen_tms9900_movhi (operands[0], gen_lowpart (HImode, result)));
+    DONE;
+  }
+)
+
+;;-------------------------------------
+; Expand for unsigned HI = QI x QI
+;
+(define_expand "umulqihi3"
+   [(set (match_operand:HI 0 "register_operand" "=r")
+        (mult:HI (match_operand:QI 1 "register_operand" "r")
+                 (match_operand:QI 2 "register_operand" "rRQ>")))]
+  ""
+  {
+    tms9900_debug_operands ("umulqihi3", NULL_RTX, operands, 3);
+
+    // This was segfaulting - but the issue is within the mov insn I think not anything in this code
+    #if 1
+    rtx result = gen_reg_rtx (SImode);
+    rtx op1 = gen_reg_rtx (HImode);
+    rtx op2 = gen_reg_rtx (HImode);
+
+    /* Extend expects both regs to be the same but passing two operands is legit
+     * as it forces the compiler to copy them to one reg first */
+    emit_insn (gen_zero_extendqihi2 (op1, operands[1]));
+    emit_insn (gen_zero_extendqihi2 (op2, operands[2]));
+    emit_move_insn(gen_highpart (HImode, result), op1);
+    // emit_insn (gen_tms9900_movhi (gen_highpart (HImode, result), op1));
+    emit_insn (gen_tms9900_mulhisi3(result, result, op2));
+    emit_move_insn (operands[0], gen_lowpart (HImode, result));
+    // emit_insn (gen_tms9900_movhi (operands[0], gen_lowpart (HImode, result)));
+    #endif
+    DONE;
+  }
+)
+
+;;-------------------------------------
+; Expand for signed SI = HI x HI
+;
+(define_expand "mulhisi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(mult:SI (zero_extend (match_operand:HI 1 "register_operand" "=r,r"))
+		 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
+  ""
+  {
+    tms9900_debug_operands ("mulqihi3", NULL_RTX, operands, 3);
+    tms9900_inline_debug ("; mulhisi3 alt=%d\n", which_alternative);
+
+    rtx result = gen_reg_rtx (SImode);
+    emit_move_insn(gen_highpart (HImode, result), operands[1]);
+    emit_insn(gen_tms9900_mulhisi3(result, result, operands[2]));
+    emit_move_insn (operands[0], result);
+    DONE;
+  }
+)
+
+;;-------------------------------------
+; Expand for unsigned SI = HI x HI
+;
+(define_expand "umulhisi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(mult:SI (zero_extend (match_operand:HI 1 "register_operand" "=r,r"))
+		 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
+  ""
+  {
+    tms9900_debug_operands ("umulhisi3", NULL_RTX, operands, 3);
+    tms9900_inline_debug ("; umulhisi3 alt=%d\n", which_alternative);
+
+    rtx result = gen_reg_rtx (SImode);
+    emit_move_insn(gen_highpart (HImode, result), operands[1]);
+    emit_insn(gen_tms9900_mulhisi3(result, result, operands[2]));
+    emit_move_insn (operands[0], result);
+    DONE;
+  }
+)
+
+;;-------------------------------------
+; expand HI=HIxHI to native SI=SIxHI
+
+(define_expand "mulhi3"
+  [(set (match_operand:HI 0 "register_operand" "=r,r")
+        (mult:HI (match_operand:HI 1 "register_operand" "+0,0")
+                 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
+  ""
+  {
+    tms9900_debug_operands ("mulhi3", NULL_RTX, operands, 3);
+    tms9900_inline_debug ("; mulhi3 alt=%d\n", which_alternative);
+
+    rtx result = gen_reg_rtx (SImode);
+    emit_move_insn(gen_highpart (HImode, result), operands[1]);
+    emit_insn(gen_tms9900_mulhisi3(result, result, operands[2]));
+    emit_move_insn (operands[0], gen_lowpart (HImode, result));
+    DONE;
+   }
+)
+
+;;-------------------------------------
+; This is the native multiplication on the tms9900.  SI=HIxHI
+;  Note it is expected that op1 == op0 so we specify that op1 is SI.
+;  All other variants, QIxQI, etc, should expand to this insn.
+;  Also, mpy is unsigned so signed variants need to expand differently.
+;  Signed vs unsigned makes no difference if operands and results are the same
+;  size but will yield wrong results if result is wider than operands.
+
+;  NOTE it does not appear subreg offsets are ever passed to this insn
+
+(define_insn "tms9900_mulhisi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(mult:SI (match_operand:SI 1 "register_operand" "0,0")
+		 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
+  ""
+  {
+    tms9900_debug_operands ("tms9900_mulhisi3", insn, operands, 3);
+    return ("mpy  %2, %0");
+  }
+  [(set_attr "length" "2,4")])
+
+;;-------------------------------------
+;; byte mul can only work in registers as we need to expand to HI mode
+
+(define_expand "udivmodqi4"
+  [(parallel [
+     (set (match_operand:QI 0 "register_operand" "=r")
+          (div:QI (match_operand:QI 1 "register_operand" "0")
+                  (match_operand:QI 2 "register_operand" "r")))
+     (set (match_operand:QI 3 "register_operand" "=r")
+          (mod:QI (match_dup 1) 
+                  (match_dup 2)))])]
+  ""
+  {
+    tms9900_debug_operands ("udivmodqi4", NULL_RTX, operands, 4);
+
+    /* Move and extend QI dividend to SI */
+    rtx dividend = gen_reg_rtx (SImode);
+    rtx scratch = gen_reg_rtx (HImode);
+    emit_insn(gen_zero_extendqihi2 (scratch, operands[1]));
+    emit_insn(gen_zero_extendhisi2 (dividend, scratch));
+
+    /* Extend the divisor */
+    rtx divisor = gen_reg_rtx (HImode);
+    emit_insn(gen_zero_extendqihi2 (divisor, operands[2]));
+
+    /* Do the division */
+    emit_insn(gen_udivmodsihi3(dividend, dividend, divisor));
+
+    /* Convert and store quotient from HI to QI */
+    rtx quotient = gen_reg_rtx (HImode);
+    emit_move_insn (quotient, gen_highpart (HImode, dividend));
+    emit_insn(gen_trunchiqi2 (operands[0], quotient));
+
+    /* Convert and store quotient from HI to QI */
+    rtx remainder = gen_reg_rtx (HImode);
+    emit_move_insn (remainder, gen_lowpart (HImode, dividend));
+    emit_insn(gen_trunchiqi2 (operands[3], remainder));
+    DONE;
+  })
+
+(define_expand "udivmodhi4"
+  [(parallel [
+     (set (match_operand:HI 0 "register_operand" "=r,r")
+          (div:HI (match_operand:HI 1 "register_operand" "+0,0")
+                  (match_operand:HI 2 "nonimmediate_operand" "+rR>,Q")))
+     (set (match_operand:HI 3 "register_operand" "=r,r")
+          (mod:HI (match_dup 1) 
+                  (match_dup 2)))])]
+  ""
+  {
+    tms9900_debug_operands ("udivmodhi4", NULL_RTX, operands, 4);
+    tms9900_inline_debug ("; udivmodhi4 alt=%d\n", which_alternative);
+    rtx dividend = gen_reg_rtx (SImode);
+    rtx tmp = gen_reg_rtx (HImode);
+    emit_move_insn(tmp, operands[1]);
+    emit_insn(gen_zero_extendhisi2 (dividend, tmp));
+    emit_insn(gen_udivmodsihi3(dividend, dividend, operands[2]));
+    emit_move_insn (operands[0], gen_highpart (HImode, dividend));
+    emit_move_insn (operands[3], gen_lowpart (HImode, dividend));
+    DONE;
+  })
+
+
+;;-------------------------------------
+;; Signed div/mod.  Native method is unsigned so record the sign of the result
+;; by xor'ing operands together to examine highest bit.  Then take abs of operands.
+;; Correct the sign of the quotient after the operation
+(define_expand "divmodqi4"
+  [(parallel [
+     (set (match_operand:QI 0 "register_operand" "=r,r")
+          (div:QI (match_operand:QI 1 "register_operand" "0,0")
+                  (match_operand:QI 2 "nonimmediate_operand" "rR>,Q")))
+     (set (match_operand:QI 3 "register_operand" "=r,r")
+          (mod:QI (match_dup 1) 
+                  (match_dup 2)))])]
+  ""
+  {
+    tms9900_debug_operands ("divmodqi4", NULL_RTX, operands, 4);
+    tms9900_inline_debug ("; divmodqi4 alt=%d\n", which_alternative);
+
+    /* Find quotient sign */
+    rtx sign = gen_reg_rtx (HImode); // sign of quotient
+    emit_insn(gen_extendqihi2 (operands[1], sign));
+    // emit_move_insn(sign, operands[1]);
+    emit_insn(gen_extendqihi2 (operands[2], operands[2]));
+    emit_insn(gen_xorhi3(sign, sign, operands[2]));
+
+    /* Use temp for operand2 and get abs value */
+    rtx divisor = gen_reg_rtx (HImode);
+    emit_move_insn(divisor, operands[2]);
+    emit_insn(gen_abshi2(divisor, divisor));
+
+    /* Use temp for operand1, get absolute value and extend to SI.  We don't
+     * have abssi2 so do abs on a tmp before extend  */
+    rtx dividend = gen_reg_rtx (SImode);
+    rtx tmp = gen_reg_rtx (HImode);
+    emit_move_insn(tmp, operands[1]);
+    emit_insn(gen_abshi2(tmp, tmp));
+    emit_insn(gen_extendhisi2 (dividend, tmp));
+
+    /* Perform division and modulus */
+    emit_insn(gen_udivmodsihi3(dividend, dividend, divisor));
+
+    /* Convert and store quotient from HI to QI */
+    rtx quotient = gen_reg_rtx (HImode);
+    emit_move_insn (quotient, gen_highpart (HImode, dividend));
+
+    /* Correct sign of quotient */
+    emit_insn(gen_divfixuphi2(quotient, sign));
+
+    /* Convert and store quotient from HI to QI */
+    emit_insn(gen_trunchiqi2 (operands[0], quotient));
+
+    /* Convert and store remainder from HI to QI */
+    rtx remainder = gen_reg_rtx (HImode);
+    emit_move_insn (remainder, gen_lowpart (HImode, dividend));
+    emit_insn(gen_trunchiqi2 (operands[3], remainder));
+
+    DONE;
+  }
+)
+
+
+(define_expand "divmodhi4"
+  [(parallel [
+     (set (match_operand:HI 0 "register_operand" "=r,r")
+          (div:HI (match_operand:HI 1 "register_operand" "0,0")
+                  (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))
+     (set (match_operand:HI 3 "register_operand" "=r,r")
+          (mod:HI (match_dup 1) 
+                  (match_dup 2)))])]
+  ""
+  {
+    tms9900_debug_operands ("divmodhi4", NULL_RTX, operands, 4);
+    tms9900_inline_debug ("; divmodhi4 alt=%d\n", which_alternative);
+    // rtx insn, div_equal, mod_equal, equal;
+
+    /* Find quotient sign */
+    rtx sign = gen_reg_rtx (HImode); // sign of quotient
+    emit_move_insn(sign, operands[1]);
+    emit_insn(gen_xorhi3(sign, sign, operands[2]));
+
+    /* Use temp for operand2 and get abs value */
+    rtx divisor = gen_reg_rtx (HImode);
+    emit_move_insn(divisor, operands[2]);
+    emit_insn(gen_abshi2(divisor, divisor));
+
+    /* Use temp for operand1, get absolute value and extend to SI.  We don't
+     * have abssi2 so do abs on a tmp before extend  */
+    rtx dividend = gen_reg_rtx (SImode);
+    rtx tmp = gen_reg_rtx (HImode);
+    emit_move_insn(tmp, operands[1]);
+    emit_insn(gen_abshi2(tmp, tmp));
+    emit_insn(gen_extendhisi2 (dividend, tmp));
+
+    /* Perform division and modulus */
+    emit_insn(gen_udivmodsihi3(dividend, dividend, divisor));
+    emit_move_insn (operands[0], gen_highpart (HImode, dividend));
+    emit_move_insn (operands[3], gen_lowpart (HImode, dividend));
+
+    /* Correct sign of quotient */
+    emit_insn(gen_divfixuphi2(operands[0], sign));
+
+    DONE;
+  }
+)
+
+
+;;-------------------------------------------------------------------
+;; Divide and Modulus
+;; native method HI = SI / HI , HI = SI % HI
+;;-------------------------------------
+(define_insn "udivmodsihi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (ior:SI
+          (ashift:SI
+            (zero_extend:SI
+              (div:HI (match_operand:SI 1 "register_operand" "0,0")
+                      (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))
+            (const_int 16))
+          (zero_extend:SI 
+            (mod:HI (match_dup 1)
+                    (match_dup 2)))))]
+  ""
+  {
+    tms9900_debug_operands ("udivmodsihi3", insn, operands, 3);
+    output_asm_insn ("div  %2, %0", operands);
+    return("");
+  }
+  [(set_attr "length" "2,4")])
+
+
+
+(define_insn "divfixuphi2"
+  [(set (match_operand:HI 1 "register_operand" "=r")
+        (not:HI (match_dup 1)))
+   (set (match_operand:HI 0 "register_operand" "=r")
+        (if_then_else:HI (lt:HI (match_dup 1) (const_int 0))
+           (neg:HI (match_dup 0)) (match_dup 0)))]
+  ""
+  {
+    tms9900_debug_operands ("divfixuphi2", insn, operands, 2);
+    output_asm_insn("inv  %1", operands);
+    output_asm_insn("jlt  $+4", operands);
+    output_asm_insn("neg  %0", operands);
+    return("");
+  }
+  [(set_attr "length" "6")])
+
+
+;;-------------------------------------------------------------------
+;; Absolute Value
+;;-------------------------------------
+(define_insn "abshi2"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
+	(abs:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))]
+  ""
+  {
+    tms9900_debug_operands ("abshi2", insn, operands, 2);
+    output_asm_insn ("abs  %0", operands);
+    return("");
+  }
+  [(set_attr "length" "2,4")])
+
+
+;;-------------------------------------
+;; register only as abs is 16-bit
+(define_insn "absqi2"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+	(abs:QI (match_operand:QI 1 "register_operand" "0")))]
+  ""
+  {
+    tms9900_debug_operands ("absqi2", insn, operands, 2);
+    output_asm_insn ("abs  %0", operands);
+    return("");
+  }
+  [(set_attr "length" "2")])
+
+
+;;-------------------------------------------------------------------
+;; Negate
+;;-------------------------------------
+(define_insn "neghi2"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
+	(neg:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))]
+  ""
+  {
+    tms9900_debug_operands ("neghi2", insn, operands, 2);
+    output_asm_insn("neg  %0", operands);
+    return("");
+  }
+  [(set_attr "length" "2,4")])
+
+
+;;-------------------------------------
+;; TODO andi only reqiured for strict
+(define_insn "negqi2"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+	(neg:QI (match_operand:QI 1 "register_operand" "0")))]
+  ""
+  {
+    tms9900_debug_operands ("negqi2", insn, operands, 2);
+    output_asm_insn("andi %0, 0xFF00", operands);
+    output_asm_insn("neg  %0", operands);
+    return("");
+  }
+  [(set_attr "length" "6")])
+
+
+;;-------------------------------------------------------------------
+;; Other Instructions
+;;-------------------------------------------------------------------
+
+
+;;-------------------------------------------------------------------
+;; No-op
+(define_insn "nop"
+  [(const_int 0)]
+  ""
+  "nop"
+  [(set_attr "length" "2")])
+
+
+;;-------------------------------------------------------------------
+;;  Optimizations For Byte Compares
+;;-------------------------------------------------------------------
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (unsigned char)X > N
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "=r")
+        (match_operand:QI 1 "const_int_operand" "i"))
+   (set (cc0)
+        (compare (match_operand:QI 2 "register_operand" "r")
+                 (match_dup 0)))
+   (set (pc) (if_then_else (gtu (cc0) (const_int 0))
+                           (label_ref (match_operand 3 "" ""))
+                           (pc)))]
+  "peep2_reg_dead_p(3, operands[0])"
+  [(set (cc0)
+        (compare (match_dup 2)
+                 (plus:HI (const_int 255)
+                          (mult:HI (match_dup 1)
+                                   (const_int 256)))))
+   (set (pc) (if_then_else (gtu (cc0) (const_int 0))
+                           (label_ref (match_dup 3))
+                           (pc)))]
+  {
+    tms9900_debug_operands ("peep-A", NULL_RTX, operands, 4);
+  }
+)
+
+;; TODO assume this can be deleted
+(define_insn "*cmpqi_as_hi"
+  [(set (cc0)
+      (compare (match_operand:QI 0 "register_operand" "r")
+         (plus:HI (match_operand:HI 1 "const_int_operand" "i")
+            (mult:HI (match_operand:HI 2 "const_int_operand" "i")
+               (match_operand:HI 3 "const_int_operand" "i")))))]
+  "INTVAL(operands[3]) == 256 && (INTVAL(operands[1]) == 0 || INTVAL(operands[1]) == 255)"
+  {
+    tms9900_debug_operands ("*cmpqi_as_hi", insn, operands, 3);
+    operands[1] = GEN_INT(INTVAL(operands[2]) * 256 + INTVAL(operands[1]));
+    return("ci   %0, %1");
+  }
+  [(set_attr "length" "4")])
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (unsigned char)X < N
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "=r")
+        (match_operand:QI 1 "const_int_operand" "i"))
+   (set (cc0)
+        (compare (match_operand:QI 2 "register_operand" "r")
+                 (match_dup 0)))
+   (set (pc) (if_then_else (ltu (cc0) (const_int 0))
+                           (label_ref (match_operand 3 "" ""))
+                           (pc)))]
+  "peep2_reg_dead_p(3, operands[0])"
+  [(set (cc0)
+        (compare (match_dup 2)
+                 (plus:HI (const_int 0)
+                          (mult:HI (match_dup 1)
+                                   (const_int 256)))))
+   (set (pc) (if_then_else (ltu (cc0) (const_int 0))
+                           (label_ref (match_dup 3))
+                           (pc)))]
+  {
+    tms9900_debug_operands ("peep-cmpqi_lt_hi", NULL_RTX, operands, 4);
+  }
+)
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (unsigned char)X >= N
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "=r")
+        (match_operand:QI 1 "const_int_operand" "i"))
+   (set (cc0)
+        (compare (match_operand:QI 2 "register_operand" "r")
+                 (match_dup 0)))
+   (set (pc) (if_then_else (geu (cc0) (const_int 0))
+                           (label_ref (match_operand 3 "" ""))
+                           (pc)))]
+  "peep2_reg_dead_p(3, operands[0])"
+  [(set (cc0)
+        (compare (match_dup 2)
+                 (plus:HI (const_int 0)
+                          (mult:HI (match_dup 1)
+                                   (const_int 256)))))
+   (set (pc) (if_then_else (geu (cc0) (const_int 0))
+                           (label_ref (match_dup 3))
+                           (pc)))]
+  {
+    tms9900_debug_operands ("peep-cmpqi_ge_hi", NULL_RTX, operands, 3);
+  }
+)
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (unsigned char)X <= N
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "=r")
+        (match_operand:QI 1 "const_int_operand" "i"))
+   (set (cc0)
+        (compare (match_operand:QI 2 "register_operand" "r")
+                 (match_dup 0)))
+   (set (pc) (if_then_else (leu (cc0) (const_int 0))
+                           (label_ref (match_operand 3 "" ""))
+                           (pc)))]
+  "peep2_reg_dead_p(3, operands[0])"
+  [(set (cc0)
+        (compare (match_dup 2)
+                 (plus:HI (const_int 255)
+                          (mult:HI (match_dup 1)
+                                   (const_int 256)))))
+   (set (pc) (if_then_else (leu (cc0) (const_int 0))
+                           (label_ref (match_dup 3))
+                           (pc)))]
+  {
+    tms9900_debug_operands ("peep-cmpqi_le_hi", NULL_RTX, operands, 3);
+  }
+)
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (char)X > N
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "=r")
+        (match_operand:QI 1 "const_int_operand" "i"))
+   (set (cc0)
+        (compare (match_operand:QI 2 "register_operand" "r")
+                 (match_dup 0)))
+   (set (pc) (if_then_else (gt (cc0) (const_int 0))
+                           (label_ref (match_operand 3 "" ""))
+                           (pc)))]
+  "peep2_reg_dead_p(3, operands[0])"
+  [(set (cc0)
+        (compare (match_dup 2)
+                 (plus:HI (const_int 255)
+                          (mult:HI (match_dup 1)
+                                  (const_int 256)))))
+   (set (pc) (if_then_else (gt (cc0) (const_int 0))
+                           (label_ref (match_dup 3))
+                           (pc)))]
+  {
+    tms9900_debug_operands ("peep-cmpqi_gt_hi", NULL_RTX, operands, 3);
+  }
+)
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (char)X < N
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "=r")
+        (match_operand:QI 1 "const_int_operand" "i"))
+   (set (cc0)
+        (compare (match_operand:QI 2 "register_operand" "r")
+                 (match_dup 0)))
+   (set (pc) (if_then_else (lt (cc0) (const_int 0))
+                           (label_ref (match_operand 3 "" ""))
+                           (pc)))]
+  "peep2_reg_dead_p(3, operands[0])"
+  [(set (cc0)
+        (compare (match_dup 2)
+                 (plus:HI (const_int 0)
+                          (mult:HI (match_dup 1)
+                                   (const_int 256)))))
+   (set (pc) (if_then_else (lt (cc0) (const_int 0))
+                           (label_ref (match_dup 3))
+                           (pc)))]
+  {
+    tms9900_debug_operands ("peep-cmpsqi_lt_hi", NULL_RTX, operands, 3);
+  }
+)
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (char)X >= N
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "=r")
+        (match_operand:QI 1 "const_int_operand" "i"))
+   (set (cc0)
+        (compare (match_operand:QI 2 "register_operand" "r")
+                 (match_dup 0)))
+   (set (pc) (if_then_else (ge (cc0) (const_int 0))
+                           (label_ref (match_operand 3 "" ""))
+                           (pc)))]
+  "peep2_reg_dead_p(3, operands[0])"
+  [(set (cc0)
+        (compare (match_dup 2)
+                 (plus:HI (const_int 0)
+                          (mult:HI (match_dup 1)
+                                   (const_int 256)))))
+   (set (pc) (if_then_else (ge (cc0) (const_int 0))
+                           (label_ref (match_dup 3))
+                           (pc)))]
+  {
+    tms9900_debug_operands ("peep-cmpsqi_ge_hi", NULL_RTX, operands, 3);
+  }
+)
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (char)X <= N
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "=r")
+        (match_operand:QI 1 "const_int_operand" "i"))
+   (set (cc0)
+        (compare (match_operand:QI 2 "register_operand" "r")
+                 (match_dup 0)))
+   (set (pc) (if_then_else (le (cc0) (const_int 0))
+                           (label_ref (match_operand 3 "" ""))
+                           (pc)))]
+  "peep2_reg_dead_p(3, operands[0])"
+  [(set (cc0)
+        (compare (match_dup 2)
+                 (plus:HI (const_int 255)
+                          (mult:HI (match_dup 1)
+                                   (const_int 256)))))
+   (set (pc) (if_then_else (le (cc0) (const_int 0))
+                           (label_ref (match_dup 3))
+                           (pc)))]
+  {
+    tms9900_debug_operands ("peep-cmpsqi_le_hi", NULL_RTX, operands, 3);
+  }
+)
+
+
+;;-------------------------------------------------------------------
+;;  Optimizations For Bit Shift And Cast
+;;-------------------------------------------------------------------
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (char)X = (int X) >> N
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (ashiftrt:HI (match_dup 0)
+            (match_operand:HI 1 "const_int_operand" "i")))
+   (set (match_operand:QI 2 "register_operand" "=r")
+        (subreg:QI (match_dup 0) 1))]
+  "REGNO(operands[0]) == REGNO(operands[2])"
+  [(set (match_dup 0)
+        (ashiftrt:HI (match_dup 0)
+            (minus:HI (match_dup 1) 
+                      (const_int 8))))]
+  {
+    tms9900_debug_operands ("peep-movqi_hi_sh", NULL_RTX, operands, 3);
+  }
+)
+
+(define_insn "*ashiftrt_hi_to_qi"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (ashiftrt:HI (match_dup 0)
+            (minus:HI (match_operand:HI 1 "const_int_operand" "i") 
+                      (match_operand:HI 2 "const_int_operand" "i"))))]
+  ""
+  {
+    tms9900_debug_operands ("*ashiftrt_hi_to_qi", insn, operands, 3);
+    int shift = INTVAL (operands[1]);
+    if(shift < 8)
+    {
+      operands[1] = GEN_INT(8 - shift);
+      output_asm_insn("sla  %0, %1", operands);
+    }
+    else if(shift > 8)
+    {
+      operands[1] = GEN_INT(shift - 8);
+      output_asm_insn("sra  %0, %1", operands);
+    }
+    return "";
+  }
+  [(set_attr "length" "2")])
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (unsigned char)X = (unsigned int X) >> N
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (lshiftrt:HI (match_dup 0)
+            (match_operand:HI 1 "const_int_operand" "i")))
+   (set (match_operand:QI 2 "register_operand" "=r")
+        (subreg:QI (match_dup 0) 1))]
+  "REGNO(operands[0]) == REGNO(operands[2])"
+  [(set (match_dup 0)
+        (lshiftrt:HI (match_dup 0)
+            (minus:HI (match_dup 1) 
+                      (const_int 8))))]
+  {
+    tms9900_debug_operands ("peep-movqi_uhi_sh", NULL_RTX, operands, 3);
+  }
+)
+
+
+(define_insn "*lshiftrt_hi_to_qi"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (lshiftrt:HI (match_dup 0)
+            (minus:HI (match_operand:HI 1 "const_int_operand" "i") 
+                      (match_operand:HI 2 "const_int_operand" "i"))))]
+  ""
+  {
+    tms9900_debug_operands ("*lshiftrt_hi_to_qi", insn, operands, 3);
+    int shift = INTVAL (operands[1]);
+    if(shift < 8)
+    {
+      operands[1] = GEN_INT(8 - shift);
+      output_asm_insn("sla  %0, %1", operands);
+    }
+    else if(shift > 8)
+    {
+      operands[1] = GEN_INT(shift - 8);
+      output_asm_insn("srl  %0, %1", operands);
+    }
+    return "";
+  }
+  [(set_attr "length" "2")])
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (char)X = (int X) << N
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (ashift:HI (match_dup 0)
+            (match_operand:HI 1 "const_int_operand" "i")))
+   (set (match_operand:QI 2 "register_operand" "=r")
+        (subreg:QI (match_dup 0) 1))]
+  "REGNO(operands[0]) == REGNO(operands[2])"
+  [(set (match_dup 0)
+        (ashift:HI (match_dup 0)
+            (plus:HI (match_dup 1) 
+                      (const_int 8))))]
+  {
+    tms9900_debug_operands ("peep-movqi_hi_lsh", NULL_RTX, operands, 3);
+  }
+)
+
+
+(define_insn "*ashift_hi_to_qi"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (ashift:HI (match_dup 0)
+            (plus:HI (match_operand:HI 1 "const_int_operand" "i") 
+                      (match_operand:HI 2 "const_int_operand" "i"))))]
+  ""
+  {
+    tms9900_debug_operands ("*ashift_hi_to_qi", insn, operands, 3);
+    operands[1] = GEN_INT(8 + INTVAL (operands[1]));
+    output_asm_insn("sla  %0, %1", operands);
+    return("");
+  }
+  [(set_attr "length" "2")])
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (int)X = (char X) >> N
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "=r")
+        (ashiftrt:QI (match_dup 0)
+            (match_operand:HI 1 "const_int_operand" "i")))
+   (set (match_operand:HI 2 "register_operand" "=r")
+        (sign_extend:HI (match_dup 0)))]
+  "REGNO(operands[0]) == REGNO(operands[2])"
+  [(set (match_dup 2)
+        (ashiftrt:HI (match_dup 2)
+            (plus:HI (match_dup 1) 
+                      (const_int 8))))]
+  {
+    tms9900_debug_operands ("peep-movhi_qi_rsh", NULL_RTX, operands, 3);
+  }
+)
+
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(sign_extend:HI (match_operand:QI 1 "register_operand" "0")))
+   (set (match_operand:HI 2 "register_operand" "=r")
+        (ashiftrt:HI (match_dup 2)
+            (match_operand:HI 3 "const_int_operand" "i")))]
+  "REGNO(operands[0]) == REGNO(operands[2])"
+  [(set (match_dup 2)
+        (ashiftrt:HI (match_dup 2)
+            (plus:HI (match_dup 3) 
+                      (const_int 8))))]
+  {
+    tms9900_debug_operands ("peep-sign-ext", NULL_RTX, operands, 4);
+  }
+)
+
+
+(define_insn "*ashiftrt_qi_to_hi"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (ashiftrt:HI (match_dup 0)
+            (plus:HI (match_operand:HI 1 "const_int_operand" "i") 
+                      (match_operand:HI 2 "const_int_operand" "i"))))]
+  ""
+  {
+    tms9900_debug_operands ("*ashiftrt_qi_to_hi", insn, operands, 3);
+    int shift = INTVAL (operands[1]) + 8;
+    if(shift > 15) shift = 15;
+    operands[1] = GEN_INT(shift);
+    output_asm_insn("sra  %0, %1", operands);
+    return("");
+  }
+  [(set_attr "length" "2")])
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (int)X = (unsigned char X) >> N
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (lshiftrt:HI (match_operand:HI 1 "register_operand" "0")
+            (match_operand:HI 2 "const_int_operand" "i")))
+   (set (match_operand:HI 3 "register_operand" "=r")
+        (and:HI (match_operand:HI 4 "const_int_operand" "2")
+                (match_operand:HI 5 "const_int_operand" "i")))]
+  "(REGNO(operands[0]) == REGNO(operands[3])) && (INTVAL(operands[5]) == (1<<(8-INTVAL(operands[2])))-1)"
+  [(set (match_dup 0)
+        (lshiftrt:HI (match_dup 0)
+            (plus:HI (match_dup 2) 
+                      (const_int 8))))]
+  {
+    tms9900_debug_operands ("peep-lsh-and", NULL_RTX, operands, 6);
+  }
+)
+
+
+(define_insn "*lshiftrt_qi_to_hi"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (lshiftrt:HI (match_dup 0)
+            (plus:HI (match_operand:HI 1 "const_int_operand" "i") 
+                      (match_operand:HI 2 "const_int_operand" "i"))))]
+  ""
+  {
+    tms9900_debug_operands ("*lshiftrt_qi_to_hi", insn, operands, 3);
+    int shift = INTVAL (operands[1]) + 8;
+    if(shift > 15) shift = 15;
+    operands[1] = GEN_INT(shift);
+    output_asm_insn("srl  %0, %1", operands);
+    return("");
+  }
+  [(set_attr "length" "2")])
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (int)X = ((int)(char X)) << N
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (sign_extend:HI (match_operand:QI 1 "register_operand" "0")))
+   (set (match_operand:HI 3 "register_operand" "=r")
+        (ashift:HI (match_operand:HI 4 "register_operand" "3")
+                   (match_operand:HI 5 "const_int_operand" "i")))]
+  "(REGNO(operands[0]) == REGNO(operands[3]))"
+  [(set (match_dup 0)
+        (ashiftrt:HI (const_int 8)
+            (ashift:HI (match_dup 0) 
+                       (match_dup 5))))]
+  {
+    tms9900_debug_operands ("peep-sign-ext-ash", NULL_RTX, operands, 6);
+  }
+)
+
+(define_insn "*qi_hi_shift"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (ashiftrt:HI (match_operand:HI 1 "const_int_operand" "i")
+            (ashift:HI (match_operand:HI 2 "register_operand" "0") 
+                       (match_operand:HI 3 "const_int_operand" "i"))))]
+  ""
+  {
+    tms9900_debug_operands ("*qi_hi_shift", insn, operands, 3);
+    int shift = INTVAL(operands[3]);
+    if(shift == 0) {
+      output_asm_insn("swpb %0", operands);
+      }
+    else if(shift >= 1 && shift <= 7) { 
+      operands[3] = GEN_INT(8-shift);
+      output_asm_insn("sra  %0, %3", operands);
+      }
+    else if(shift >= 9 && shift <= 15) {
+      operands[3] = GEN_INT(shift-8);
+      output_asm_insn("sla  %0, %3", operands);
+      }
+
+    operands[3] = GEN_INT(0x00FF << shift);
+    output_asm_insn("andi %0, %3", operands);
+   
+    return("");
+  }
+  [(set_attr "length" "6")])
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (unsigned int)X = ((unsigned int)(unsigned char X)) << N
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (zero_extend:HI (match_operand:QI 1 "register_operand" "0")))
+   (set (match_operand:HI 3 "register_operand" "=r")
+        (ashift:HI (match_operand:HI 4 "register_operand" "3")
+                   (match_operand:HI 5 "const_int_operand" "i")))]
+  "(REGNO(operands[0]) == REGNO(operands[3]))"
+  [(set (match_dup 0)
+        (lshiftrt:HI (const_int 8)
+            (ashift:HI (match_dup 0) 
+                       (match_dup 5))))]
+  {
+    tms9900_debug_operands ("peep-zero-ext-ash", NULL_RTX, operands, 6);
+  }
+)
+
+
+(define_insn "*unsigned_qi_hi_shift"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (lshiftrt:HI (match_operand:HI 1 "const_int_operand" "i")
+            (ashift:HI (match_operand:HI 2 "register_operand" "0") 
+                       (match_operand:HI 3 "const_int_operand" "i"))))]
+  ""
+  {
+    tms9900_debug_operands ("*unsigned_qi_hi_shift", insn, operands, 3);
+    int shift = INTVAL(operands[3]);
+    if(shift >= 0 && shift <= 7) { 
+      operands[3] = GEN_INT(8-shift);
+      output_asm_insn("srl  %0, %3", operands);
+      }
+    else if(shift >= 9 && shift <= 15) {
+      operands[3] = GEN_INT(shift-8);
+      output_asm_insn("sla  %0, %3", operands);
+      }
+
+    operands[3] = GEN_INT(0xFFFF << shift);
+    output_asm_insn("andi %0, %3", operands);
+   
+    return("");
+  }
+  [(set_attr "length" "6")])
+
+
+;;-------------------------------------------------------------------
+;; Optimization for (unsigned long)X = (unsigned long Y) >> 16
+;;   Original code:
+;;     mov  r3, r6
+;;     mov  r4, r7
+;;     mov  r6, r7
+;;     clr  r6
+;;
+;;   Optimized:
+;;     mov r3, r7
+;;     clr r6
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (match_operand:HI 1 "register_operand" "r"))
+   (set (match_operand:HI 2 "register_operand" "=r")
+        (match_operand:HI 3 "register_operand" "r"))
+   (parallel[
+    (clobber (match_operand:HI 4 "register_operand" "r"))
+    (set (match_operand:SI 5 "register_operand" "=r")
+         (lshiftrt:SI (match_operand:SI 6 "register_operand" "5")
+                      (match_operand:HI 7 "const_int_operand" "i")))
+   ])]
+  "((REGNO(operands[0]) == REGNO(operands[5])) &&
+    (REGNO(operands[2]) == (REGNO(operands[0])+1)) &&
+    (INTVAL(operands[7]) == 16)
+   )"
+  [(set (match_dup 2) (match_dup 1))
+   (set (match_dup 0) (const_int 0))]
+  {
+    tms9900_debug_operands ("peep-mov-squash", NULL_RTX, operands, 8);
+  }
+)
+
+(define_insn "tms9900_consthi2"
+  [(set (match_operand:HI 0 "register_operand" "=r, r")
+        (match_operand:HI 1 "const_int_operand" "OM,n"))]
+  ""
+  {
+    tms9900_debug_operands ("tms9900_consthi2", insn, operands, 3);
+    if (which_alternative == 0)
+    {
+      if (INTVAL(operands[1]) == 0)
+        return "clr  %0";
+      else if((INTVAL(operands[1]) & 0xFFFF) == 0xFFFF)
+        return "seto  %0";
+      else
+        gcc_unreachable();
+    }
+    else
+    {
+      return "li   %0, %1";
+    }
+  }
+  [(set_attr "length" "2,4")])
+
+;;-------------------------------------------------------------------
+;; Optimization for X = Y << 16
+;;   Original code:
+;;     mov  r4, r6
+;;     mov  r5, r7
+;;     mov  r7, r6
+;;     clr  r7
+;;
+;;   Optimized:
+;;     mov r5, r6
+;;     clr r7
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (match_operand:HI 1 "register_operand" "r"))
+   (set (match_operand:HI 2 "register_operand" "=r")
+        (match_operand:HI 3 "register_operand" "r"))
+   (parallel[
+    (clobber (match_operand:HI 4 "register_operand" "r"))
+    (set (match_operand:SI 5 "register_operand" "=r")
+         (ashift:SI (match_operand:SI 6 "register_operand" "5")
+                      (match_operand:HI 7 "const_int_operand" "i")))
+   ])]
+  "((REGNO(operands[0]) == REGNO(operands[5])) &&
+    (REGNO(operands[2]) == (REGNO(operands[0])+1)) &&
+    (INTVAL(operands[7]) == 16)
+   )"
+  [(set (match_dup 0) (match_dup 3))
+   (set (match_dup 2) (const_int 0))]
+  {
+    tms9900_debug_operands ("peep-movsi-squash", NULL_RTX, operands, 8);
+  }
+)
+
+
+;-------------------------------------------------------------------
+;; Optimization for byte array initializations
+; This handles sequences like:
+;   li   r1, >1200
+;   movb r1, *r2
+;   li   r1, >3400
+;   movb r1, @1(r2)
+;
+; and converts to:
+;   li   r1, >1234
+;   movb r1, *r2
+;   swpb r1
+;   movb r1, @1(r2)
+;
+; This saves two bytes and is slightly faster
+(define_peephole2
+  [(match_scratch:HI 6 "r,r")
+   (set (match_operand:QI 0 "register_operand" "=r,r")
+        (match_operand:QI 1 "const_int_operand" "i,i"))
+   (set (match_operand:QI 2 "nonimmediate_operand" "=R>,Q")
+        (match_dup 0))
+   (set (match_operand:QI 3 "register_operand" "=r,r")
+        (match_operand:QI 4 "const_int_operand" "i,i"))
+   (set (match_operand:QI 5 "nonimmediate_operand" "=R>,Q")
+        (match_dup 3))]
+  "peep2_reg_dead_p(4, operands[0]) && peep2_reg_dead_p(4, operands[3])"
+  [(set (match_dup 6)
+        (ior:HI (ashift:HI (match_dup 1) 
+                     (const_int 8))
+             (match_dup 4)))
+   (set (match_dup 2)
+        (subreg:QI (ashiftrt:HI (match_dup 6) (const_int 8)) 1))
+   (set (match_dup 5)
+        (subreg:QI (ashiftrt:HI (match_dup 6) (const_int 0)) 1))]
+  {
+    tms9900_debug_operands ("peep-hi-swpb-mov", NULL_RTX, operands, 6);
+  }
+)
+
+
+(define_insn "*movhi_combine_consts"
+  [(set (match_operand:HI 0 "register_operand" "")
+        (ior:HI (ashift:HI (match_operand:QI 1 "const_int_operand" "")
+                           (match_operand:QI 2 "const_int_operand" ""))
+                (match_operand:QI 3 "const_int_operand" "")))]
+  ""
+  {
+    tms9900_debug_operands ("*movhi_combine_consts", insn, operands, 3);
+    operands[1] = GEN_INT(((INTVAL(operands[1]) & 0xFF) << 8) |
+                           (INTVAL(operands[3]) & 0xFF));
+    return "li   %0, %1";
+  }
+  [(set_attr "length" "4")])
+
+
+;; TODO will this help the case where char c = (int) x >> 8; ??
+
+(define_insn "*movqi_for_initializer"
+  [(set (match_operand:QI 0 "memory_operand" "=rR>,Q")
+        (subreg:QI (ashiftrt:HI (match_operand:HI 1 "register_operand" "r,r")
+                              (match_operand:HI 2 "const_int_operand" "i,i")) 1))]
+  ""
+  {
+    tms9900_debug_operands ("*movqi_for_initializer", insn, operands, 3);
+    if(INTVAL(operands[2]) == 8)
+    {
+      output_asm_insn("movb %1, %0", operands);
+    }
+    else if(INTVAL(operands[2]) == 0)
+    {
+      output_asm_insn("swpb %1", operands);
+      output_asm_insn("movb %1, %0", operands);
+    }
+   return("");
+  }
+  [(set_attr "length" "2,4")])
+
+
+;;-------------------------------------------------------------------
+;; Optimization for memory-to-memory copies
+;; Combine a mem-reg-mem copy into a mem-mem copy
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "")
+        (match_operand:HI 1 "memory_operand" ""))
+   (set (match_operand:HI 2 "memory_operand" "")
+        (match_dup 0))]
+  "peep2_reg_dead_p(2, operands[0])"
+  [(set (match_operand:HI 2 "memory_operand" "")
+        (match_operand:HI 1 "memory_operand" ""))]
+  {
+    tms9900_debug_operands ("peep-mov-mem-mem", NULL_RTX, operands, 3);
+  }
+)
+
+   
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "")
+        (match_operand:QI 1 "memory_operand" ""))
+   (set (match_operand:QI 2 "memory_operand" "")
+        (match_dup 0))]
+  "peep2_reg_dead_p(2, operands[0])"
+  [(set (match_operand:QI 2 "memory_operand" "")
+        (match_operand:QI 1 "memory_operand" ""))]
+  {
+    tms9900_debug_operands ("peep-movqi-mem-mem", NULL_RTX, operands, 3);
+  }
+)
+
+
+(define_insn "*andi_const"
+  [(set (match_operand:HI 0 "register_operand" "")
+        (and:HI (match_dup 0)
+                (match_operand:HI 1 "const_int_operand" "")))]
+  ""
+  {
+    tms9900_debug_operands ("*andi_const", insn, operands, 3);
+    int val = INTVAL(operands[1]) & 0xFFFF;
+    if(val == 0)
+      return "clr  %0";
+    else if(val == 0xFFFF)
+      return "";
+    else
+      return "andi %0, %1";
+  }
+  [(set_attr "length" "4")])
+
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/tms9900.opt gcc-4.4.0/gcc/config/tms9900/tms9900.opt
--- gcc-4.4.0-orig/gcc/config/tms9900/tms9900.opt	2024-10-05 07:13:03.798413408 +0100
+++ gcc-4.4.0/gcc/config/tms9900/tms9900.opt	2024-10-05 07:13:04.138411017 +0100
@@ -0,0 +1,34 @@
+; Options for the TMS9900 port of the compiler.
+
+; Copyright (C) 2005, 2007 Free Software Foundation, Inc.
+;
+; Copyright 2023 Mark Burkley (MGB)
+;
+; This file is part of GCC.
+;
+; GCC is free software; you can redistribute it and/or modify it under
+; the terms of the GNU General Public License as published by the Free
+; Software Foundation; either version 3, or (at your option) any later
+; version.
+;
+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+; WARRANTY; without even the implied warranty of MERCHANTABILITY or
+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+; for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with GCC; see the file COPYING3.  If not see
+; <http://www.gnu.org/licenses/>.
+
+mno-ti99-float
+Target RejectNegative Report Mask(NO_TI99_FLOAT)
+Generate IEEE compatible doubles and floats
+
+mti99-float
+Target RejectNegative Report InverseMask(NO_TI99_FLOAT)
+Generate TI console ROM compatible doubles and floats
+
+minline_rtl
+Target RejectNegative Report Mask(TI99_INLINE_RTL)
+Generate RTL dumps as inline comments in assembly output
+
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/tms9900-protos.h gcc-4.4.0/gcc/config/tms9900/tms9900-protos.h
--- gcc-4.4.0-orig/gcc/config/tms9900/tms9900-protos.h	2024-07-28 14:42:12.625792757 +0100
+++ gcc-4.4.0/gcc/config/tms9900/tms9900-protos.h	2024-10-05 07:13:04.106411242 +0100
@@ -0,0 +1,65 @@
+/* Definitions of target machine for GNU compiler, for the TMS9900
+
+Copyright 2009 Eric Welser (EMW)
+Copyright 2023 Mark Burkley (MGB)
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* declarations */
+#ifdef RTX_CODE
+extern int simple_memory_operand (rtx, enum machine_mode);
+extern void print_operand_address (FILE *, rtx);
+extern int legitimate_address_p (enum machine_mode, rtx);
+extern void notice_update_cc_on_set (rtx, rtx);
+#endif /* RTX_CODE */
+
+extern const char *output_branch (const char *, const char *, int);
+extern const char *output_jump (int);
+
+extern int tms9900_function_arg_padding (enum machine_mode mode, 
+                                         const_tree type);
+
+extern void tms9900_function_arg_advance (CUMULATIVE_ARGS *cum, 
+                                          enum machine_mode mode,
+                                          tree type,
+                                          int named ATTRIBUTE_UNUSED);
+
+extern void tms9900_init_cumulative_args (CUMULATIVE_ARGS *cum,
+                                          tree fntype ATTRIBUTE_UNUSED,
+                                          rtx libname ATTRIBUTE_UNUSED);
+
+extern rtx tms9900_function_arg (CUMULATIVE_ARGS *cum, 
+                                 enum machine_mode mode,
+                                 tree type ATTRIBUTE_UNUSED,
+                                 int named);
+
+extern int tms9900_initial_elimination_offset (int from, int to);
+extern rtx tms9900_function_value (const_tree valtype);
+extern void tms9900_output_ascii(FILE* stream, const char* ptr, int len);
+extern void tms9900_expand_prologue (void);
+extern void tms9900_expand_epilogue (bool is_sibcall);
+extern int tms9900_starting_frame_offset(void);
+extern int tms9900_reg_ok_for_base(int strict, rtx reg);
+extern int tms9900_go_if_legitimate_address(enum machine_mode mode ATTRIBUTE_UNUSED, rtx operand, int strict);
+
+extern void tms9900_register_mode_set (rtx operand, int mode);
+extern void tms9900_register_convert (rtx operand, int mode, int sign);
+extern bool tms9900_legitimate_constant_p (rtx x);
+extern bool tms9900_constant_address_p (rtx x);
+extern bool tms9900_operand_subreg_offset (rtx operand, int mode);
+extern void tms9900_inline_debug (const char *fmt,...);
+extern void tms9900_debug_operands (const char *name, rtx insn, rtx ops[], int count);
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/t-tms9900 gcc-4.4.0/gcc/config/tms9900/t-tms9900
--- gcc-4.4.0-orig/gcc/config/tms9900/t-tms9900	2024-10-05 07:13:03.798413408 +0100
+++ gcc-4.4.0/gcc/config/tms9900/t-tms9900	2024-10-05 07:13:04.098411299 +0100
@@ -0,0 +1,43 @@
+LIB1ASMSRC    = tms9900/lib1funcs.asm
+LIB1ASMFUNCS  = _divsi3 _udivsi3 _modsi3 _umodsi3 _divmod_common \
+_ashrsi3 _ashlsi3 _lshrsi3
+
+# Exclude funcs from libgcc2.c that we implement using calls to TI99/4A console
+# ROM
+LIB2FUNCS_EXCLUDE = __adddf3 __subdf3 __muldf3 __divdf3 __eqdf2 \
+ __gedf2 __gtdf2 __ledf2 __ltdf2
+
+# Exclude funcs where we provide our own C implementation
+LIB2FUNCS_EXCLUDE += _divdi3 _moddi3 _udivdi3 _umoddi3
+
+# Exclude other 64-bit functions we don't need (yet)
+LIB2FUNCS_EXCLUDE += _muldi3 _negdi2  _cmpdi2 _ucmpdi2 _lshrdi3 _ashldi3 \
+_ashrdi3 _addvDI3 _subvDI3 \
+__udivmoddi4
+
+LIB2FUNCS_EXTRA = \
+ $(srcdir)/config/tms9900/ftoa.c \
+ $(srcdir)/config/tms9900/atof.c \
+ $(srcdir)/config/tms9900/double.c\
+ $(srcdir)/config/tms9900/d_adj_neg_pos.c \
+ $(srcdir)/config/tms9900/d_compare.c \
+ $(srcdir)/config/tms9900/eqdf2.c \
+ $(srcdir)/config/tms9900/gedf2.c \
+ $(srcdir)/config/tms9900/gtdf2.c \
+ $(srcdir)/config/tms9900/ledf2.c \
+ $(srcdir)/config/tms9900/ltdf2.c \
+ $(srcdir)/config/tms9900/longdivmod.c \
+ $(srcdir)/config/tms9900/ulongdivmod.c
+
+# Tell make where to find headers for above
+LIBGCC2_INCLUDES += -I$(srcdir)/config/tms9900
+
+# Assemble startup files.  TODO Do we need these?
+$(T)crti.o: $(srcdir)/config/tms9900/crti.asm $(GCC_PASSES)
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \
+	-c -o $(T)crti.o -x assembler-with-cpp $(srcdir)/config/tms9900/crti.asm
+
+$(T)crtn.o: $(srcdir)/config/tms9900/crtn.asm $(GCC_PASSES)
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \
+	-c -o $(T)crtn.o -x assembler-with-cpp $(srcdir)/config/tms9900/crtn.asm
+
diff -ru gcc-4.4.0-orig/gcc/config/tms9900/ulongdivmod.c gcc-4.4.0/gcc/config/tms9900/ulongdivmod.c
--- gcc-4.4.0-orig/gcc/config/tms9900/ulongdivmod.c	2024-10-05 07:13:03.802413379 +0100
+++ gcc-4.4.0/gcc/config/tms9900/ulongdivmod.c	2024-10-05 07:13:04.146410961 +0100
@@ -0,0 +1,51 @@
+/* ulongdivmod.c
+   These methods provide unsigned long division and modulus.
+   change log:
+   12/26/2023 initial version
+*/
+
+// #include <ulongdivmod.h>
+
+unsigned long numerator_u32_cache = 0;
+unsigned long denominator_u32_cache = 0;
+volatile unsigned long quotient_u32_cache;
+volatile unsigned long remainder_u32_cache;
+
+void divmod_u32 (long numerator, long denominator) {
+
+   unsigned long t;
+
+   quotient_u32_cache  = 0;
+   remainder_u32_cache = 0;
+
+   int i;
+   for (i = 31 ; i >= 0; i--) {
+      remainder_u32_cache = remainder_u32_cache << 1;
+      t                   = (long) 1 << i;
+      t                   = t & numerator;
+      t                   = t >> i;
+      remainder_u32_cache = remainder_u32_cache | t;
+      if (remainder_u32_cache >= denominator) {
+         remainder_u32_cache = remainder_u32_cache - denominator;
+         quotient_u32_cache  = quotient_u32_cache | ((long) 1 << i);
+      }
+   }
+}
+
+long __udivsi3 (unsigned long numerator, unsigned long denominator) {
+   if (numerator != numerator_u32_cache || denominator != denominator_u32_cache) {
+      numerator_u32_cache   = numerator;
+      denominator_u32_cache = denominator;
+      divmod_u32 (numerator_u32_cache, denominator_u32_cache);
+   }
+   return quotient_u32_cache;
+}
+
+unsigned long __umodsi3 (unsigned long numerator, unsigned long denominator) {
+   if (numerator != numerator_u32_cache || denominator != denominator_u32_cache) {
+      numerator_u32_cache   = numerator;
+      denominator_u32_cache = denominator;
+      divmod_u32 (numerator_u32_cache, denominator_u32_cache);
+   }
+   return remainder_u32_cache;
+}
diff -ru gcc-4.4.0-orig/gcc/config.gcc gcc-4.4.0/gcc/config.gcc
--- gcc-4.4.0-orig/gcc/config.gcc	2009-04-17 12:58:41.000000000 +0100
+++ gcc-4.4.0/gcc/config.gcc	2024-10-05 07:13:03.970412198 +0100
@@ -2314,6 +2314,9 @@
 	c_target_objs="${c_target_objs} spu-c.o"
 	cxx_target_objs="${cxx_target_objs} spu-c.o"
 	;;
+tms9900-*-*)
+	tmake_file=tms9900/t-tms9900
+	;;
 v850e1-*-*)
 	target_cpu_default="TARGET_CPU_v850e1"
 	tm_file="dbxelf.h elfos.h svr4.h v850/v850.h"
diff -ru gcc-4.4.0-orig/gcc/cp/cfns.h gcc-4.4.0/gcc/cp/cfns.h
--- gcc-4.4.0-orig/gcc/cp/cfns.h	2009-02-18 21:01:03.000000000 +0000
+++ gcc-4.4.0/gcc/cp/cfns.h	2023-12-23 10:48:53.525244337 +0000
@@ -1,4 +1,4 @@
-/* ANSI-C code produced by gperf version 3.0.1 */
+/* ANSI-C code produced by gperf version 3.0.4 */
 /* Command-line: gperf -o -C -E -k '1-6,$' -j1 -D -N libc_name_p -L ANSI-C ../../gcc/cp/cfns.gperf  */
 
 #if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
@@ -36,6 +36,7 @@
 static unsigned int hash (const char *, unsigned int);
 #ifdef __GNUC__
 __inline
+__attribute__ ((__gnu_inline__))
 #endif
 const char * libc_name_p (const char *, unsigned int);
 /* maximum key range = 391, duplicates = 0 */
@@ -57,13 +58,13 @@
       400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
       400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
       400, 400, 400, 400, 400, 400, 400, 400,   0,   0,
-	1, 400, 400, 400, 400, 400, 400, 400, 400, 400,
+        1, 400, 400, 400, 400, 400, 400, 400, 400, 400,
       400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
       400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
       400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
       400, 400, 400, 400, 400, 400, 400,  28,  90,   0,
        95,   0,  51,  93, 114,  26, 109, 124,   5,   1,
-	6,  13,  37, 128,   3,   0,   0,  49,  38,   0,
+        6,  13,  37, 128,   3,   0,   0,  49,  38,   0,
       104,  45,   0, 400, 400, 400, 400, 400, 400, 400,
       400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
       400, 400, 400, 400, 400, 400, 400, 400, 400, 400,
@@ -84,29 +85,32 @@
   switch (hval)
     {
       default:
-	hval += asso_values[(unsigned char)str[5]+1];
+        hval += asso_values[(unsigned char)str[5]+1];
       /*FALLTHROUGH*/
       case 5:
-	hval += asso_values[(unsigned char)str[4]];
+        hval += asso_values[(unsigned char)str[4]];
       /*FALLTHROUGH*/
       case 4:
-	hval += asso_values[(unsigned char)str[3]];
+        hval += asso_values[(unsigned char)str[3]];
       /*FALLTHROUGH*/
       case 3:
-	hval += asso_values[(unsigned char)str[2]];
+        hval += asso_values[(unsigned char)str[2]];
       /*FALLTHROUGH*/
       case 2:
-	hval += asso_values[(unsigned char)str[1]];
+        hval += asso_values[(unsigned char)str[1]];
       /*FALLTHROUGH*/
       case 1:
-	hval += asso_values[(unsigned char)str[0]];
-	break;
+        hval += asso_values[(unsigned char)str[0]];
+        break;
     }
   return hval + asso_values[(unsigned char)str[len - 1]];
 }
 
 #ifdef __GNUC__
 __inline
+#if defined __GNUC_STDC_INLINE__ || defined __GNUC_GNU_INLINE__
+__attribute__ ((__gnu_inline__))
+#endif
 #endif
 const char *
 libc_name_p (register const char *str, register unsigned int len)
@@ -329,17 +333,17 @@
       register int key = hash (str, len);
 
       if (key <= MAX_HASH_VALUE && key >= 0)
-	{
-	  register int index = lookup[key];
+        {
+          register int index = lookup[key];
 
-	  if (index >= 0)
-	    {
-	      register const char *s = wordlist[index];
-
-	      if (*str == *s && !strcmp (str + 1, s + 1))
-		return s;
-	    }
-	}
+          if (index >= 0)
+            {
+              register const char *s = wordlist[index];
+
+              if (*str == *s && !strcmp (str + 1, s + 1))
+                return s;
+            }
+        }
     }
   return 0;
 }
diff -ru gcc-4.4.0-orig/gcc/DATESTAMP gcc-4.4.0/gcc/DATESTAMP
--- gcc-4.4.0-orig/gcc/DATESTAMP	2024-10-05 07:13:03.762413661 +0100
+++ gcc-4.4.0/gcc/DATESTAMP	2024-10-06 10:07:47.490985166 +0100
@@ -1 +1 @@
-20090421
+20241006
diff -ru gcc-4.4.0-orig/gcc/DEV-PHASE gcc-4.4.0/gcc/DEV-PHASE
--- gcc-4.4.0-orig/gcc/DEV-PHASE	2009-04-21 09:48:37.000000000 +0100
+++ gcc-4.4.0/gcc/DEV-PHASE	2024-10-06 10:07:47.494985133 +0100
@@ -0,0 +1 @@
+TMS9900 patch
diff -ru gcc-4.4.0-orig/gcc/df-core.c gcc-4.4.0/gcc/df-core.c
--- gcc-4.4.0-orig/gcc/df-core.c	2008-12-06 22:52:43.000000000 +0000
+++ gcc-4.4.0/gcc/df-core.c	2024-05-26 13:40:53.984313110 +0100
@@ -1804,7 +1804,7 @@
 	    fprintf (file, " [%s]", reg_names[i]);
 	}
     }
-  fprintf (file, "\n");
+  // fprintf (file, "\n");
 }
 
 
diff -ru gcc-4.4.0-orig/gcc/dfp.c gcc-4.4.0/gcc/dfp.c
--- gcc-4.4.0-orig/gcc/dfp.c	2024-10-05 07:13:03.810413323 +0100
+++ gcc-4.4.0/gcc/dfp.c	2024-10-05 07:13:04.154410905 +0100
@@ -355,6 +355,10 @@
 
 /* Helper to round_for_format, handling decimal float types.  */
 
+#ifdef TMS9900
+extern const struct real_format tms9900_real_format;
+#endif
+
 void
 decimal_round_for_format (const struct real_format *fmt, REAL_VALUE_TYPE *r)
 {
@@ -392,7 +396,12 @@
       decimal64FromNumber (&d64, &dn, &set);
       decimal64ToNumber (&d64, &dn);
     }
-  else
+#ifdef TMS9900
+  else if (fmt == &tms9900_real_format)
+    {
+      return;
+    }
+#endif
     gcc_unreachable ();
 
   decimal_from_decnumber (r, &dn, &set);
diff -ru gcc-4.4.0-orig/gcc/doc/cppopts.texi gcc-4.4.0/gcc/doc/cppopts.texi
--- gcc-4.4.0-orig/gcc/doc/cppopts.texi	2024-10-06 08:31:26.878724695 +0100
+++ gcc-4.4.0/gcc/doc/cppopts.texi	2024-10-06 08:31:27.030723697 +0100
@@ -758,7 +758,7 @@
 Enable special code to work around file systems which only permit very
 short file names, such as MS-DOS@.
 
-@itemx --help
+@item --help
 @itemx --target-help
 @opindex help
 @opindex target-help
diff -ru gcc-4.4.0-orig/gcc/doc/c-tree.texi gcc-4.4.0/gcc/doc/c-tree.texi
--- gcc-4.4.0-orig/gcc/doc/c-tree.texi	2024-10-06 08:31:26.870724748 +0100
+++ gcc-4.4.0/gcc/doc/c-tree.texi	2024-10-06 08:31:27.022723749 +0100
@@ -2338,13 +2338,13 @@
 not matter.  The type of the operands and that of the result are
 always of @code{BOOLEAN_TYPE} or @code{INTEGER_TYPE}.
 
-@itemx POINTER_PLUS_EXPR
+@item POINTER_PLUS_EXPR
 This node represents pointer arithmetic.  The first operand is always
 a pointer/reference type.  The second operand is always an unsigned
 integer type compatible with sizetype.  This is the only binary
 arithmetic operand that can operate on pointer types.
 
-@itemx PLUS_EXPR
+@item PLUS_EXPR
 @itemx MINUS_EXPR
 @itemx MULT_EXPR
 These nodes represent various binary arithmetic operations.
diff -ru gcc-4.4.0-orig/gcc/doc/gcc.texi gcc-4.4.0/gcc/doc/gcc.texi
--- gcc-4.4.0-orig/gcc/doc/gcc.texi	2024-10-06 08:31:26.886724642 +0100
+++ gcc-4.4.0/gcc/doc/gcc.texi	2024-10-06 08:31:27.038723644 +0100
@@ -84,11 +84,11 @@
 Published by:
 @multitable @columnfractions 0.5 0.5
 @item GNU Press
-@tab Website: www.gnupress.org
+@tab Website: @uref{http://www.gnupress.org}
 @item a division of the
-@tab General: @tex press@@gnu.org @end tex
+@tab General: @email{press@@gnu.org}
 @item Free Software Foundation
-@tab Orders:  @tex sales@@gnu.org @end tex
+@tab Orders:  @email{sales@@gnu.org}
 @item 51 Franklin Street, Fifth Floor
 @tab Tel 617-542-5942
 @item Boston, MA 02110-1301 USA
diff -ru gcc-4.4.0-orig/gcc/doc/install.texi gcc-4.4.0/gcc/doc/install.texi
--- gcc-4.4.0-orig/gcc/doc/install.texi	2009-03-16 13:23:13.000000000 +0000
+++ gcc-4.4.0/gcc/doc/install.texi	2024-10-06 08:31:27.074723408 +0100
@@ -2746,7 +2746,8 @@
 <!-- -------- host/target specific issues start here ---------------- -->
 <hr />
 @end html
-@heading @anchor{alpha-x-x}alpha*-*-*
+@anchor{alpha-x-x}
+@heading alpha*-*-*
 
 This section contains general configuration information for all
 alpha-based platforms using ELF (in particular, ignore this section for
@@ -2761,7 +2762,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{alpha-dec-osf}alpha*-dec-osf*
+@anchor{alpha-dec-osf}
+@heading alpha*-dec-osf*
 Systems using processors that implement the DEC Alpha architecture and
 are running the DEC/Compaq Unix (DEC OSF/1, Digital UNIX, or Compaq
 Tru64 UNIX) operating system, for example the DEC Alpha AXP systems.
@@ -2834,14 +2836,16 @@
 @html
 <hr />
 @end html
-@heading @anchor{arc-x-elf}arc-*-elf
+@anchor{arc-x-elf}
+@heading arc-*-elf
 Argonaut ARC processor.
 This configuration is intended for embedded systems.
 
 @html
 <hr />
 @end html
-@heading @anchor{arm-x-elf}arm-*-elf
+@anchor{arm-x-elf}
+@heading arm-*-elf
 ARM-family processors.  Subtargets that use the ELF object format
 require GNU binutils 2.13 or newer.  Such subtargets include:
 @code{arm-*-freebsd}, @code{arm-*-netbsdelf}, @code{arm-*-*linux}
@@ -2850,7 +2854,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{arm-x-coff}arm-*-coff
+@anchor{arm-x-coff}
+@heading arm-*-coff
 ARM-family processors.  Note that there are two different varieties
 of PE format subtarget supported: @code{arm-wince-pe} and
 @code{arm-pe} as well as a standard COFF target @code{arm-*-coff}.
@@ -2858,14 +2863,16 @@
 @html
 <hr />
 @end html
-@heading @anchor{arm-x-aout}arm-*-aout
+@anchor{arm-x-aout}
+@heading arm-*-aout
 ARM-family processors.  These targets support the AOUT file format:
 @code{arm-*-aout}, @code{arm-*-netbsd}.
 
 @html
 <hr />
 @end html
-@heading @anchor{avr}avr
+@anchor{avr}
+@heading avr
 
 ATMEL AVR-family micro controllers.  These are used in embedded
 applications.  There are no standard Unix configurations.
@@ -2904,7 +2911,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{bfin}Blackfin
+@anchor{bfin}
+@heading Blackfin
 
 The Blackfin processor, an Analog Devices DSP.
 @ifnothtml
@@ -2921,7 +2929,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{cris}CRIS
+@anchor{cris}
+@heading CRIS
 
 CRIS is the CPU architecture in Axis Communications ETRAX system-on-a-chip
 series.  These are used in embedded applications.
@@ -2956,7 +2965,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{crx}CRX
+@anchor{crx}
+@heading CRX
 
 The CRX CompactRISC architecture is a low-power 32-bit architecture with
 fast context switching and architectural extensibility features.
@@ -2982,7 +2992,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{dos}DOS
+@anchor{dos}
+@heading DOS
 
 Please have a look at the @uref{binaries.html,,binaries page}.
 
@@ -2994,7 +3005,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{x-x-freebsd}*-*-freebsd*
+@anchor{x-x-freebsd}
+@heading *-*-freebsd*
 
 The version of binutils installed in @file{/usr/bin} probably works with
 this release of GCC@.  However, on FreeBSD 4, bootstrapping against the
@@ -3042,7 +3054,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{h8300-hms}h8300-hms
+@anchor{h8300-hms}
+@heading h8300-hms
 Renesas H8/300 series of processors.
 
 Please have a look at the @uref{binaries.html,,binaries page}.
@@ -3055,7 +3068,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{hppa-hp-hpux}hppa*-hp-hpux*
+@anchor{hppa-hp-hpux}
+@heading hppa*-hp-hpux*
 Support for HP-UX version 9 and older was discontinued in GCC 3.4.
 
 We require using gas/binutils on all hppa platforms.  Version 2.19 or
@@ -3107,7 +3121,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{hppa-hp-hpux10}hppa*-hp-hpux10
+@anchor{hppa-hp-hpux10}
+@heading hppa*-hp-hpux10
 
 For hpux10.20, we @emph{highly} recommend you pick up the latest sed patch
 @code{PHCO_19798} from HP@.  HP has two sites which provide patches free of
@@ -3135,7 +3150,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{hppa-hp-hpux11}hppa*-hp-hpux11
+@anchor{hppa-hp-hpux11}
+@heading hppa*-hp-hpux11
 
 GCC 3.0 and up support HP-UX 11.  GCC 2.95.x is not supported and cannot
 be used to compile GCC 3.0 and up.
@@ -3246,7 +3262,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{x-x-linux-gnu}*-*-linux-gnu
+@anchor{x-x-linux-gnu}
+@heading *-*-linux-gnu
 
 Versions of libstdc++-v3 starting with 3.2.1 require bug fixes present
 in glibc 2.2.5 and later.  More information is available in the
@@ -3255,7 +3272,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{ix86-x-linux}i?86-*-linux*
+@anchor{ix86-x-linux}
+@heading i?86-*-linux*
 
 As of GCC 3.3, binutils 2.13.1 or later is required for this platform.
 See @uref{http://gcc.gnu.org/PR10877,,bug 10877} for more information.
@@ -3267,7 +3285,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{ix86-x-solaris210}i?86-*-solaris2.10
+@anchor{ix86-x-solaris210}
+@heading i?86-*-solaris2.10
 Use this for Solaris 10 or later on x86 and x86-64 systems.  This
 configuration is supported by GCC 4.0 and later versions only.
 
@@ -3279,7 +3298,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{ia64-x-linux}ia64-*-linux
+@anchor{ia64-x-linux}
+@heading ia64-*-linux
 IA-64 processor (also known as IPF, or Itanium Processor Family)
 running GNU/Linux.
 
@@ -3299,7 +3319,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{ia64-x-hpux}ia64-*-hpux*
+@anchor{ia64-x-hpux}
+@heading ia64-*-hpux*
 Building GCC on this target requires the GNU Assembler.  The bundled HP
 assembler will not work.  To prevent GCC from using the wrong assembler,
 the option @option{--with-gnu-as} may be necessary.
@@ -3314,7 +3335,8 @@
 <hr />
 <!-- rs6000-ibm-aix*, powerpc-ibm-aix* -->
 @end html
-@heading @anchor{x-ibm-aix}*-ibm-aix*
+@anchor{x-ibm-aix}
+@heading *-ibm-aix*
 Support for AIX version 3 and older was discontinued in GCC 3.4.
 
 ``out of memory'' bootstrap failures may indicate a problem with
@@ -3445,42 +3467,48 @@
 @html
 <hr />
 @end html
-@heading @anchor{iq2000-x-elf}iq2000-*-elf
+@anchor{iq2000-x-elf}
+@heading iq2000-*-elf
 Vitesse IQ2000 processors.  These are used in embedded
 applications.  There are no standard Unix configurations.
 
 @html
 <hr />
 @end html
-@heading @anchor{m32c-x-elf}m32c-*-elf
+@anchor{m32c-x-elf}
+@heading m32c-*-elf
 Renesas M32C processor.
 This configuration is intended for embedded systems.
 
 @html
 <hr />
 @end html
-@heading @anchor{m32r-x-elf}m32r-*-elf
+@anchor{m32r-x-elf}
+@heading m32r-*-elf
 Renesas M32R processor.
 This configuration is intended for embedded systems.
 
 @html
 <hr />
 @end html
-@heading @anchor{m6811-elf}m6811-elf
+@anchor{m6811-elf}
+@heading m6811-elf
 Motorola 68HC11 family micro controllers.  These are used in embedded
 applications.  There are no standard Unix configurations.
 
 @html
 <hr />
 @end html
-@heading @anchor{m6812-elf}m6812-elf
+@anchor{m6812-elf}
+@heading m6812-elf
 Motorola 68HC12 family micro controllers.  These are used in embedded
 applications.  There are no standard Unix configurations.
 
 @html
 <hr />
 @end html
-@heading @anchor{m68k-x-x}m68k-*-*
+@anchor{m68k-x-x}
+@heading m68k-*-*
 By default, @samp{m68k-*-aout}, @samp{m68k-*-coff*},
 @samp{m68k-*-elf*}, @samp{m68k-*-rtems},  @samp{m68k-*-uclinux} and
 @samp{m68k-*-linux}
@@ -3506,7 +3534,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{m68k-x-uclinux}m68k-*-uclinux
+@anchor{m68k-x-uclinux}
+@heading m68k-*-uclinux
 GCC 4.3 changed the uClinux configuration so that it uses the
 @samp{m68k-linux-gnu} ABI rather than the @samp{m68k-elf} ABI.
 It also added improved support for C++ and flat shared libraries,
@@ -3517,7 +3546,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{mips-x-x}mips-*-*
+@anchor{mips-x-x}
+@heading mips-*-*
 If on a MIPS system you get an error message saying ``does not have gp
 sections for all it's [sic] sectons [sic]'', don't worry about it.  This
 happens whenever you use GAS with the MIPS linker, but there is not
@@ -3575,7 +3605,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{mips-sgi-irix5}mips-sgi-irix5
+@anchor{mips-sgi-irix5}
+@heading mips-sgi-irix5
 
 In order to compile GCC on an SGI running IRIX 5, the @samp{compiler_dev.hdr}
 subsystem must be installed from the IDO CD-ROM supplied by SGI@.
@@ -3605,7 +3636,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{mips-sgi-irix6}mips-sgi-irix6
+@anchor{mips-sgi-irix6}
+@heading mips-sgi-irix6
 
 If you are using SGI's MIPSpro @command{cc} as your bootstrap compiler, you must
 ensure that the N32 ABI is in use.  To test this, compile a simple C
@@ -3689,7 +3721,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{powerpc-x-x}powerpc-*-*
+@anchor{powerpc-x-x}
+@heading powerpc-*-*
 
 You can specify a default version for the @option{-mcpu=@var{cpu_type}}
 switch by using the configure option @option{--with-cpu-@var{cpu_type}}.
@@ -3701,7 +3734,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{powerpc-x-darwin}powerpc-*-darwin*
+@anchor{powerpc-x-darwin}
+@heading powerpc-*-darwin*
 PowerPC running Darwin (Mac OS X kernel).
 
 Pre-installed versions of Mac OS X may not include any developer tools,
@@ -3718,70 +3752,81 @@
 @html
 <hr />
 @end html
-@heading @anchor{powerpc-x-elf}powerpc-*-elf
+@anchor{powerpc-x-elf}
+@heading powerpc-*-elf
 PowerPC system in big endian mode, running System V.4.
 
 @html
 <hr />
 @end html
-@heading @anchor{powerpc-x-linux-gnu}powerpc*-*-linux-gnu*
+@anchor{powerpc-x-linux-gnu}
+@heading powerpc*-*-linux-gnu*
 
 PowerPC system in big endian mode running Linux.
 
 @html
 <hr />
 @end html
-@heading @anchor{powerpc-x-netbsd}powerpc-*-netbsd*
+@anchor{powerpc-x-netbsd}
+@heading powerpc-*-netbsd*
 PowerPC system in big endian mode running NetBSD@.
 
 @html
 <hr />
 @end html
-@heading @anchor{powerpc-x-eabisim}powerpc-*-eabisim
+@anchor{powerpc-x-eabisim}
+@heading powerpc-*-eabisim
 Embedded PowerPC system in big endian mode for use in running under the
 PSIM simulator.
 
 @html
 <hr />
 @end html
-@heading @anchor{powerpc-x-eabi}powerpc-*-eabi
+@anchor{powerpc-x-eabi}
+@heading powerpc-*-eabi
 Embedded PowerPC system in big endian mode.
 
 @html
 <hr />
 @end html
-@heading @anchor{powerpcle-x-elf}powerpcle-*-elf
+@anchor{powerpcle-x-elf}
+@heading powerpcle-*-elf
 PowerPC system in little endian mode, running System V.4.
 
 @html
 <hr />
 @end html
-@heading @anchor{powerpcle-x-eabisim}powerpcle-*-eabisim
+@anchor{powerpcle-x-eabisim}
+@heading powerpcle-*-eabisim
 Embedded PowerPC system in little endian mode for use in running under
 the PSIM simulator.
 
 @html
 <hr />
 @end html
-@heading @anchor{powerpcle-x-eabi}powerpcle-*-eabi
+@anchor{powerpcle-x-eabi}
+@heading powerpcle-*-eabi
 Embedded PowerPC system in little endian mode.
 
 @html
 <hr />
 @end html
-@heading @anchor{s390-x-linux}s390-*-linux*
+@anchor{s390-x-linux}
+@heading s390-*-linux*
 S/390 system running GNU/Linux for S/390@.
 
 @html
 <hr />
 @end html
-@heading @anchor{s390x-x-linux}s390x-*-linux*
+@anchor{s390x-x-linux}
+@heading s390x-*-linux*
 zSeries system (64-bit) running GNU/Linux for zSeries@.
 
 @html
 <hr />
 @end html
-@heading @anchor{s390x-ibm-tpf}s390x-ibm-tpf*
+@anchor{s390x-ibm-tpf}
+@heading s390x-ibm-tpf*
 zSeries system (64-bit) running TPF@.  This platform is
 supported as cross-compilation target only.
 
@@ -3792,7 +3837,8 @@
 @c with 2.0 until 2.6, 7, 8, etc.  Solaris 1 was a marketing name for
 @c SunOS 4 releases which we don't use to avoid confusion.  Solaris
 @c alone is too unspecific and must be avoided.
-@heading @anchor{x-x-solaris2}*-*-solaris2*
+@anchor{x-x-solaris2}
+@heading *-*-solaris2*
 
 Sun does not ship a C compiler with Solaris 2.  To bootstrap and install
 GCC you first have to install a pre-built compiler, see the
@@ -3882,7 +3928,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{sparc-sun-solaris2}sparc-sun-solaris2*
+@anchor{sparc-sun-solaris2}
+@heading sparc-sun-solaris2*
 
 When GCC is configured to use binutils 2.14 or later the binaries
 produced are smaller than the ones produced using Sun's native tools;
@@ -3944,7 +3991,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{sparc-sun-solaris27}sparc-sun-solaris2.7
+@anchor{sparc-sun-solaris27}
+@heading sparc-sun-solaris2.7
 
 Sun patch 107058-01 (1999-01-13) for Solaris 7/SPARC triggers a bug in
 the dynamic linker.  This problem (Sun bug 4210064) affects GCC 2.8
@@ -4006,7 +4054,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{sparc-x-linux}sparc-*-linux*
+@anchor{sparc-x-linux}
+@heading sparc-*-linux*
 
 GCC versions 3.0 and higher require binutils 2.11.2 and glibc 2.2.4
 or newer on this platform.  All earlier binutils and glibc
@@ -4016,7 +4065,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{sparc64-x-solaris2}sparc64-*-solaris2*
+@anchor{sparc64-x-solaris2}
+@heading sparc64-*-solaris2*
 
 When configuring the GNU Multiple Precision Library (GMP) or the
 MPFR library, the canonical target triplet must be specified as
@@ -4040,14 +4090,16 @@
 @html
 <hr />
 @end html
-@heading @anchor{sparcv9-x-solaris2}sparcv9-*-solaris2*
+@anchor{sparcv9-x-solaris2}
+@heading sparcv9-*-solaris2*
 
 This is a synonym for sparc64-*-solaris2*.
 
 @html
 <hr />
 @end html
-@heading @anchor{x-x-vxworks}*-*-vxworks*
+@anchor{x-x-vxworks}
+@heading *-*-vxworks*
 Support for VxWorks is in flux.  At present GCC supports @emph{only} the
 very recent VxWorks 5.5 (aka Tornado 2.2) release, and only on PowerPC@.
 We welcome patches for other architectures supported by VxWorks 5.5.
@@ -4082,7 +4134,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{x86-64-x-x}x86_64-*-*, amd64-*-*
+@anchor{x86-64-x-x}
+@heading x86_64-*-*, amd64-*-*
 
 GCC supports the x86-64 architecture implemented by the AMD64 processor
 (amd64-*-* is an alias for x86_64-*-*) on GNU/Linux, FreeBSD and NetBSD@.
@@ -4092,7 +4145,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{xtensa-x-elf}xtensa*-*-elf
+@anchor{xtensa-x-elf}
+@heading xtensa*-*-elf
 
 This target is intended for embedded Xtensa systems using the
 @samp{newlib} C library.  It uses ELF but does not support shared
@@ -4110,7 +4164,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{xtensa-x-linux}xtensa*-*-linux*
+@anchor{xtensa-x-linux}
+@heading xtensa*-*-linux*
 
 This target is for Xtensa systems running GNU/Linux.  It supports ELF
 shared objects and the GNU C library (glibc).  It also generates
@@ -4122,7 +4177,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{windows}Microsoft Windows
+@anchor{windows}
+@heading Microsoft Windows
 
 @subheading Intel 16-bit versions
 The 16-bit versions of Microsoft Windows, such as Windows 3.1, are not 
@@ -4179,7 +4235,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{x-x-cygwin}*-*-cygwin
+@anchor{x-x-cygwin}
+@heading *-*-cygwin
 
 Ports of GCC are included with the
 @uref{http://www.cygwin.com/,,Cygwin environment}.
@@ -4192,7 +4249,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{x-x-interix}*-*-interix
+@anchor{x-x-interix}
+@heading *-*-interix
 
 The Interix target is used by OpenNT, Interix, Services For UNIX (SFU), 
 and Subsystem for UNIX-based Applications (SUA).  Applications compiled 
@@ -4204,7 +4262,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{x-x-mingw32}*-*-mingw32
+@anchor{x-x-mingw32}
+@heading *-*-mingw32
 
 GCC will build with and support only MinGW runtime 3.12 and later.
 Earlier versions of headers are incompatible with the new default semantics
@@ -4213,7 +4272,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{os2}OS/2
+@anchor{os2}
+@heading OS/2
 
 GCC does not currently support OS/2.  However, Andrew Zabolotny has been
 working on a generic OS/2 port with pgcc.  The current code can be found
@@ -4222,7 +4282,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{older}Older systems
+@anchor{older}
+@heading Older systems
 
 GCC contains support files for many older (1980s and early
 1990s) Unix variants.  For the most part, support for these systems
@@ -4268,7 +4329,8 @@
 @html
 <hr />
 @end html
-@heading @anchor{elf}all ELF targets (SVR4, Solaris 2, etc.)
+@anchor{elf}
+@heading all ELF targets (SVR4, Solaris 2, etc.)
 
 C++ support is significantly better on ELF targets if you use the
 @uref{./configure.html#with-gnu-ld,,GNU linker}; duplicate copies of
diff -ru gcc-4.4.0-orig/gcc/doc/invoke.texi gcc-4.4.0/gcc/doc/invoke.texi
--- gcc-4.4.0-orig/gcc/doc/invoke.texi	2024-10-06 08:31:26.914724458 +0100
+++ gcc-4.4.0/gcc/doc/invoke.texi	2024-10-06 08:31:27.098723250 +0100
@@ -4624,11 +4624,11 @@
 @option{-fdump-rtl-ce3} enable dumping after the three
 if conversion passes. 
 
-@itemx -fdump-rtl-cprop_hardreg
+@item -fdump-rtl-cprop_hardreg
 @opindex fdump-rtl-cprop_hardreg
 Dump after hard register copy propagation.
 
-@itemx -fdump-rtl-csa
+@item -fdump-rtl-csa
 @opindex fdump-rtl-csa
 Dump after combining stack adjustments.
 
@@ -4639,11 +4639,11 @@
 @option{-fdump-rtl-cse1} and @option{-fdump-rtl-cse2} enable dumping after
 the two common sub-expression elimination passes.
 
-@itemx -fdump-rtl-dce
+@item -fdump-rtl-dce
 @opindex fdump-rtl-dce
 Dump after the standalone dead code elimination passes.
 
-@itemx -fdump-rtl-dbr
+@item -fdump-rtl-dbr
 @opindex fdump-rtl-dbr
 Dump after delayed branch scheduling.
 
@@ -4688,7 +4688,7 @@
 @opindex fdump-rtl-initvals
 Dump after the computation of the initial value sets.
 
-@itemx -fdump-rtl-into_cfglayout
+@item -fdump-rtl-into_cfglayout
 @opindex fdump-rtl-into_cfglayout
 Dump after converting to cfglayout mode.
 
@@ -4718,7 +4718,7 @@
 @opindex fdump-rtl-rnreg
 Dump after register renumbering.
 
-@itemx -fdump-rtl-outof_cfglayout
+@item -fdump-rtl-outof_cfglayout
 @opindex fdump-rtl-outof_cfglayout
 Dump after converting from cfglayout mode.
 
@@ -4730,7 +4730,7 @@
 @opindex fdump-rtl-postreload
 Dump after post-reload optimizations.
 
-@itemx -fdump-rtl-pro_and_epilogue
+@item -fdump-rtl-pro_and_epilogue
 @opindex fdump-rtl-pro_and_epilogue
 Dump after generating the function pro and epilogues.
 
diff -ru gcc-4.4.0-orig/gcc/emit-rtl.c gcc-4.4.0/gcc/emit-rtl.c
--- gcc-4.4.0-orig/gcc/emit-rtl.c	2009-03-04 01:57:29.000000000 +0000
+++ gcc-4.4.0/gcc/emit-rtl.c	2024-01-31 11:34:30.604609098 +0000
@@ -438,18 +438,29 @@
   void **slot;
 
   if (arg >= - MAX_SAVED_CONST_INT && arg <= MAX_SAVED_CONST_INT)
+  {
+   // printf ("gen saved const int %d\n", (int) arg);
     return const_int_rtx[arg + MAX_SAVED_CONST_INT];
+}
 
 #if STORE_FLAG_VALUE != 1 && STORE_FLAG_VALUE != -1
   if (const_true_rtx && arg == STORE_FLAG_VALUE)
+  {
+   // printf ("gen const true\n");
     return const_true_rtx;
+}
 #endif
 
   /* Look up the CONST_INT in the hash table.  */
   slot = htab_find_slot_with_hash (const_int_htab, &arg,
 				   (hashval_t) arg, INSERT);
   if (*slot == 0)
+  {
+   // printf ("gen VOID const int\n");
     *slot = gen_rtx_raw_CONST_INT (VOIDmode, arg);
+    }
+  // else
+  // printf ("gen const %d from slot\n", (int) arg);
 
   return (rtx) *slot;
 }
@@ -693,6 +704,7 @@
   unsigned int isize = GET_MODE_SIZE (imode);
   unsigned int osize = GET_MODE_SIZE (omode);
 
+// printf ("MGB is=%d os=%d off=%d\n", isize, osize, offset);
   /* All subregs must be aligned.  */
   if (offset % osize != 0)
     return false;
diff -ru gcc-4.4.0-orig/gcc/explow.c gcc-4.4.0/gcc/explow.c
--- gcc-4.4.0-orig/gcc/explow.c	2009-02-20 15:20:38.000000000 +0000
+++ gcc-4.4.0/gcc/explow.c	2024-08-17 15:31:11.770996457 +0100
@@ -65,6 +65,7 @@
     {
       HOST_WIDE_INT sign = 1;
       sign <<= width - 1;
+      // printf("MGB sign=%x\n", sign);
       c &= (sign << 1) - 1;
       c ^= sign;
       c -= sign;
@@ -323,6 +324,12 @@
 			rtx x)
 {
 #ifndef POINTERS_EXTEND_UNSIGNED
+  #if 0
+  printf(" %s MGB mode x=%d (%s), to_mode=%d (%s)\n", __func__,
+          GET_MODE(x),
+          GET_MODE_NAME(GET_MODE(x)), to_mode, GET_MODE_NAME(to_mode));
+        print_rtl_single(stdout, x);
+  #endif
   gcc_assert (GET_MODE (x) == to_mode || GET_MODE (x) == VOIDmode);
   return x;
 #else /* defined(POINTERS_EXTEND_UNSIGNED) */
diff -ru gcc-4.4.0-orig/gcc/expr.c gcc-4.4.0/gcc/expr.c
--- gcc-4.4.0-orig/gcc/expr.c	2009-03-03 13:05:53.000000000 +0000
+++ gcc-4.4.0/gcc/expr.c	2024-07-28 15:14:49.919118562 +0100
@@ -3401,6 +3401,14 @@
   rtx y_cst = NULL_RTX;
   rtx last_insn, set;
 
+  #if 0
+  printf("%s mode x=%d (%s), mode y=%d (%s)\n", __func__,
+          mode, GET_MODE_NAME(mode),
+          GET_MODE(y), GET_MODE_NAME(GET_MODE(y)));
+        print_rtl_single(stdout, x);
+        print_rtl_single(stdout, y);
+  #endif
+
   gcc_assert (mode != BLKmode
 	      && (GET_MODE (y) == mode || GET_MODE (y) == VOIDmode));
 
diff -ru gcc-4.4.0-orig/gcc/ira.c gcc-4.4.0/gcc/ira.c
--- gcc-4.4.0-orig/gcc/ira.c	2009-03-18 17:04:26.000000000 +0000
+++ gcc-4.4.0/gcc/ira.c	2024-01-25 09:56:26.080348049 +0000
@@ -1192,6 +1192,7 @@
 	      && ira_may_move_out_cost[mode] == NULL);
   if (move_cost[mode] == NULL)
     init_move_cost (mode);
+// printf("MGB init code for mode %d to %p\n", mode, move_cost[mode]);
   ira_register_move_cost[mode] = move_cost[mode];
   /* Don't use ira_allocate because the tables exist out of scope of a
      IRA call.  */
@@ -1227,6 +1228,7 @@
 
   for (mode = 0; mode < MAX_MACHINE_MODE; mode++)
     {
+// printf("MGB clear cost mode %d\n", mode);
       ira_register_move_cost[mode] = NULL;
       ira_may_move_in_cost[mode] = NULL;
       ira_may_move_out_cost[mode] = NULL;
@@ -1247,6 +1249,7 @@
 	free (ira_may_move_in_cost[mode]);
       if (ira_may_move_out_cost[mode] != NULL)
 	free (ira_may_move_out_cost[mode]);
+// printf("MGB clear cost mode %d\n", mode);
       ira_register_move_cost[mode] = NULL;
       ira_may_move_in_cost[mode] = NULL;
       ira_may_move_out_cost[mode] = NULL;
diff -ru gcc-4.4.0-orig/gcc/ira-costs.c gcc-4.4.0/gcc/ira-costs.c
--- gcc-4.4.0-orig/gcc/ira-costs.c	2008-12-18 13:49:47.000000000 +0000
+++ gcc-4.4.0/gcc/ira-costs.c	2024-01-25 09:55:21.796991830 +0000
@@ -138,6 +138,7 @@
   sri.extra_cost = 0;
   secondary_class = targetm.secondary_reload (to_p, x, rclass, mode, &sri);
 
+// printf("MGB check init mode %d\n", mode);
   if (ira_register_move_cost[mode] == NULL)
     ira_init_register_move_cost (mode);
 
@@ -294,6 +295,7 @@
 		     needs to do a copy, which is one insn.  */
 		  struct costs *pp = this_op_costs[i];
 
+//   printf("MGB %s check init mode %d\n", __func__, mode);
 		  if (ira_register_move_cost[mode] == NULL)
 		    ira_init_register_move_cost (mode);
 
@@ -540,8 +542,14 @@
 		{
 		  struct costs *pp = this_op_costs[i];
 
-		  if (ira_register_move_cost[mode] == NULL)
+// printf("MGB %s check init mode %d\n", __func__, mode);
+              if (ira_register_move_cost[mode] == NULL)
+// {
+// printf("MGB alloc for insn : ");
+// print_inline_rtx (stdout, insn, 0);
+// printf("\n");
 		    ira_init_register_move_cost (mode);
+// }
 
 		  for (k = 0; k < cost_classes_num; k++)
 		    {
@@ -901,8 +909,14 @@
 			       ALLOCNO_NUM (ira_curr_regno_allocno_map
 					    [REGNO (x)]));
 	pp->mem_cost += (ira_memory_move_cost[Pmode][rclass][1] * scale) / 2;
+// printf("MGB %s check init mode %d\n", __func__, Pmode);
 	if (ira_register_move_cost[Pmode] == NULL)
+// {
+// printf("MGB rtx : ");
+// print_inline_rtx (stdout, x, 0);
+// printf("\n");
 	  ira_init_register_move_cost (Pmode);
+// }
 	for (k = 0; k < cost_classes_num; k++)
 	  {
 	    i = cost_classes[k];
@@ -1425,8 +1439,16 @@
 	continue;
       mode = ALLOCNO_MODE (a);
       hard_reg_class = REGNO_REG_CLASS (hard_regno);
+// MGB
+// printf("MGB %s insn : ", __func__);
+// print_inline_rtx (stdout, insn, 0);
+// printf("\n");
+// printf("MGB hard_regno_class=%d mode=%d[%s] rclass=%d freq=%d\n",
+// REGNO_REG_CLASS(hard_regno),mode,GET_MODE_NAME(mode),rclass,freq);
+// printf ("MGB mode=%p\n", ira_register_move_cost[mode]);
       cost = (to_p ? ira_register_move_cost[mode][hard_reg_class][rclass]
 	      : ira_register_move_cost[mode][rclass][hard_reg_class]) * freq;
+// printf("MGB cost=%d\n", cost);
       ira_allocate_and_set_costs (&ALLOCNO_HARD_REG_COSTS (a), rclass,
 				  ALLOCNO_COVER_CLASS_COST (a));
       ira_allocate_and_set_costs (&ALLOCNO_CONFLICT_HARD_REG_COSTS (a),
@@ -1597,9 +1619,16 @@
   /* Because we could process operands only as subregs, check mode of
      the registers themselves too.  */
   FOR_EACH_ALLOCNO (a, ai)
+{
+// printf("MGB mode %d=%p have_regs=%d\n",
+// ALLOCNO_MODE(a),
+// ira_register_move_cost[ALLOCNO_MODE (a)],
+// have_regs_of_mode[ALLOCNO_MODE (a)]);
+
     if (ira_register_move_cost[ALLOCNO_MODE (a)] == NULL
 	&& have_regs_of_mode[ALLOCNO_MODE (a)])
       ira_init_register_move_cost (ALLOCNO_MODE (a));
+}
   ira_free (common_classes);
   ira_free (allocno_pref_buffer);
   ira_free (total_costs);
diff -ru gcc-4.4.0-orig/gcc/libgcc2.c gcc-4.4.0/gcc/libgcc2.c
--- gcc-4.4.0-orig/gcc/libgcc2.c	2024-10-05 07:13:03.870412901 +0100
+++ gcc-4.4.0/gcc/libgcc2.c	2024-10-06 08:31:27.114723145 +0100
@@ -4,6 +4,7 @@
    2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009
    Free Software Foundation, Inc.
 
+
 This file is part of GCC.
 
 GCC is free software; you can redistribute it and/or modify it under
@@ -1049,6 +1050,9 @@
 	      udiv_qrnnd (q0, n1, n2, n1, d1);
 	      umul_ppmm (m1, m0, q0, d0);
 
+// TODO something in this disabled code block causes a compiler segfault
+// gdb bt says invalid hash in ../../libiberty/hashtab.c:678
+#if 0
 	      if (m1 > n1 || (m1 == n1 && m0 > n0))
 		{
 		  q0--;
@@ -1065,6 +1069,8 @@
 		  rr.s.high = n1 >> bm;
 		  *rp = rr.ll;
 		}
+#endif
+              q1 = 0;
 	    }
 	}
     }
diff -ru gcc-4.4.0-orig/gcc/passes.c gcc-4.4.0/gcc/passes.c
--- gcc-4.4.0-orig/gcc/passes.c	2009-02-20 15:20:38.000000000 +0000
+++ gcc-4.4.0/gcc/passes.c	2024-10-06 08:31:27.122723093 +0100
@@ -102,6 +102,11 @@
 				   declarations for e.g. AIX 4.x.  */
 #endif
 
+#ifdef TMS9900xx
+extern struct rtl_opt_pass pass_tms9900_subreg;
+extern struct rtl_opt_pass pass_tms9900_postinc;
+#endif
+
 /* This is used for debugging.  It allows the current pass to printed
    from anywhere in compilation.  */
 struct opt_pass *current_pass;
@@ -767,6 +772,10 @@
       NEXT_PASS (pass_match_asm_constraints);
       NEXT_PASS (pass_sms);
       NEXT_PASS (pass_sched);
+#ifdef TMS9900xx
+      NEXT_PASS (pass_tms9900_subreg);
+      NEXT_PASS (pass_tms9900_postinc);
+#endif
       NEXT_PASS (pass_subregs_of_mode_init);
       NEXT_PASS (pass_ira);
       NEXT_PASS (pass_subregs_of_mode_finish);
diff -ru gcc-4.4.0-orig/gcc/real.h gcc-4.4.0/gcc/real.h
--- gcc-4.4.0-orig/gcc/real.h	2008-10-29 17:05:42.000000000 +0000
+++ gcc-4.4.0/gcc/real.h	2023-12-04 18:24:51.165689358 +0000
@@ -164,7 +164,7 @@
 /* The target format used for each floating point mode.
    Float modes are followed by decimal float modes, with entries for
    float modes indexed by (MODE - first float mode), and entries for
-   decimal float modes indexed by (MODE - first decimal float mode) +
+   decimal float modes indexed by (MODE - first decimal float mode)
    the number of float modes.  */
 extern const struct real_format *
   real_format_for_mode[MAX_MODE_FLOAT - MIN_MODE_FLOAT + 1
diff -ru gcc-4.4.0-orig/gcc/recog.c gcc-4.4.0/gcc/recog.c
--- gcc-4.4.0-orig/gcc/recog.c	2009-03-09 13:30:19.000000000 +0000
+++ gcc-4.4.0/gcc/recog.c	2023-11-19 18:18:37.230279613 +0000
@@ -2045,7 +2045,9 @@
 
       icode = recog_memoized (insn);
       if (icode < 0)
+      {
 	fatal_insn_not_found (insn);
+        }
 
       recog_data.n_operands = noperands = insn_data[icode].n_operands;
       recog_data.n_alternatives = insn_data[icode].n_alternatives;
diff -ru gcc-4.4.0-orig/gcc/reload.c gcc-4.4.0/gcc/reload.c
--- gcc-4.4.0-orig/gcc/reload.c	2009-02-20 15:20:38.000000000 +0000
+++ gcc-4.4.0/gcc/reload.c	2023-12-23 10:48:53.529244319 +0000
@@ -5475,7 +5475,7 @@
 	    code0 = GET_CODE (op0);
 	    if (code0 == REG && REGNO (op0) < FIRST_PSEUDO_REGISTER)
 	      op0 = gen_rtx_REG (word_mode,
-				 (REGNO (op0) +
+				 (REGNO (op0)+
 				  subreg_regno_offset (REGNO (SUBREG_REG (orig_op0)),
 						       GET_MODE (SUBREG_REG (orig_op0)),
 						       SUBREG_BYTE (orig_op0),
@@ -5490,7 +5490,7 @@
 	      /* ??? Why is this given op1's mode and above for
 		 ??? op0 SUBREGs we use word_mode?  */
 	      op1 = gen_rtx_REG (GET_MODE (op1),
-				 (REGNO (op1) +
+				 (REGNO (op1)+
 				  subreg_regno_offset (REGNO (SUBREG_REG (orig_op1)),
 						       GET_MODE (SUBREG_REG (orig_op1)),
 						       SUBREG_BYTE (orig_op1),
@@ -6362,7 +6362,7 @@
 
 	  if (REG_P (reloadreg))
 	    return gen_rtx_REG (GET_MODE (*loc),
-				(REGNO (reloadreg) +
+				(REGNO (reloadreg)+
 				 subreg_regno_offset (REGNO (SUBREG_REG (*loc)),
 						      GET_MODE (SUBREG_REG (*loc)),
 						      SUBREG_BYTE (*loc),
diff -ru gcc-4.4.0-orig/gcc/REVISION gcc-4.4.0/gcc/REVISION
--- gcc-4.4.0-orig/gcc/REVISION	2024-10-05 07:13:03.762413661 +0100
+++ gcc-4.4.0/gcc/REVISION	2024-10-06 10:07:47.498985100 +0100
@@ -0,0 +1 @@
+1.32
diff -ru gcc-4.4.0-orig/gcc/targhooks.c gcc-4.4.0/gcc/targhooks.c
--- gcc-4.4.0-orig/gcc/targhooks.c	2009-02-20 15:20:38.000000000 +0000
+++ gcc-4.4.0/gcc/targhooks.c	2023-12-09 14:39:48.786253639 +0000
@@ -311,6 +311,9 @@
       return false;
 
     case MODE_FLOAT:
+      // printf("%s mode is float\n", __func__);
+      // printf ("%s check prec %d of mode %s\n", __func__, precision,
+      //            GET_MODE_NAME (mode));
       if (precision == FLOAT_TYPE_SIZE)
 	return true;
       if (precision == DOUBLE_TYPE_SIZE)
diff -ru gcc-4.4.0-orig/gcc/toplev.c gcc-4.4.0/gcc/toplev.c
--- gcc-4.4.0-orig/gcc/toplev.c	2008-12-09 21:25:11.000000000 +0000
+++ gcc-4.4.0/gcc/toplev.c	2024-01-31 11:35:07.368407639 +0000
@@ -1000,7 +1000,9 @@
     emutls_finish ();
 
   output_shared_constant_pool ();
+// printf ("MGB %s output obj blocks\n", __func__);
   output_object_blocks ();
+// printf ("MGB %s output obj blocks done\n", __func__);
 
   /* Write out any pending weak symbol declarations.  */
   weak_finish ();
diff -ru gcc-4.4.0-orig/gcc/toplev.h gcc-4.4.0/gcc/toplev.h
--- gcc-4.4.0-orig/gcc/toplev.h	2009-02-20 15:20:38.000000000 +0000
+++ gcc-4.4.0/gcc/toplev.h	2023-12-23 10:48:53.529244319 +0000
@@ -186,6 +186,7 @@
 #  define CTZ_HWI __builtin_ctz
 # endif
 
+#ifdef __cplusplus
 extern inline int
 floor_log2 (unsigned HOST_WIDE_INT x)
 {
@@ -197,6 +198,7 @@
 {
   return x == (x & -x) && x ? (int) CTZ_HWI (x) : -1;
 }
+#endif /* __cplusplus */
 #endif /* GCC_VERSION >= 3004 */
 
 /* Functions used to get and set GCC's notion of in what directory
diff -ru gcc-4.4.0-orig/gcc/tree-ssa-pre.c gcc-4.4.0/gcc/tree-ssa-pre.c
--- gcc-4.4.0-orig/gcc/tree-ssa-pre.c	2009-02-20 15:20:38.000000000 +0000
+++ gcc-4.4.0/gcc/tree-ssa-pre.c	2024-05-27 12:43:00.101322794 +0100
@@ -3150,8 +3150,8 @@
   FOR_EACH_EDGE (pred, ei, block->preds)
     {
       pre_expr ae = avail[pred->src->index];
-      gcc_assert (get_expr_type (ae) == type
-		  || useless_type_conversion_p (type, get_expr_type (ae)));
+      // gcc_assert (get_expr_type (ae) == type
+// 		  || useless_type_conversion_p (type, get_expr_type (ae)));
       if (ae->kind == CONSTANT)
 	add_phi_arg (phi, PRE_EXPR_CONSTANT (ae), pred);
       else
diff -ru gcc-4.4.0-orig/gcc/varasm.c gcc-4.4.0/gcc/varasm.c
--- gcc-4.4.0-orig/gcc/varasm.c	2009-03-17 20:18:21.000000000 +0000
+++ gcc-4.4.0/gcc/varasm.c	2024-01-30 13:16:59.403917570 +0000
@@ -596,7 +596,7 @@
 {
   struct object_block *block;
   void **slot;
-
+// printf("MGB %s sect=%p\n",__func__,sect);
   if (sect == NULL)
     return NULL;
 
@@ -1204,6 +1204,7 @@
 {
   section *sect;
 
+// printf("MGB %s for %p\n",__func__,decl);
   if (TREE_CODE (decl) == VAR_DECL)
     {
       /* The object must be defined in this translation unit.  */
@@ -1300,6 +1301,7 @@
   gcc_assert (TREE_CODE (decl) != TYPE_DECL
 	      && TREE_CODE (decl) != LABEL_DECL);
 
+// printf("MGB %s\n",__func__);
   /* For a duplicate declaration, we can be called twice on the
      same DECL node.  Don't discard the RTL already made.  */
   if (DECL_RTL_SET_P (decl))
@@ -1320,6 +1322,7 @@
       /* Let the target reassign the RTL if it wants.
 	 This is necessary, for example, when one machine specific
 	 decl attribute overrides another.  */
+// printf("MGB enc sec\n");
       targetm.encode_section_info (decl, DECL_RTL (decl), false);
 
       /* If the symbol has a SYMBOL_REF_BLOCK field, update it based
@@ -1658,6 +1661,7 @@
 
   app_disable ();
 
+// printf ("MGB ** %s\n", __func__);
   if (CONSTANT_POOL_BEFORE_FUNCTION)
     output_constant_pool (fnname, decl);
 
@@ -1760,6 +1764,7 @@
   /* Standard thing is just output label for the function.  */
   ASM_OUTPUT_LABEL (asm_out_file, fnname);
 #endif /* ASM_DECLARE_FUNCTION_NAME */
+// printf ("MGB ** %s done\n", __func__);
 }
 
 /* Output assembler code associated with defining the size of the
@@ -1774,6 +1779,7 @@
     switch_to_section (function_section (decl));
   ASM_DECLARE_FUNCTION_SIZE (asm_out_file, fnname, decl);
 #endif
+// printf ("MGB ** %s\n", __func__);
   if (! CONSTANT_POOL_BEFORE_FUNCTION)
     {
       output_constant_pool (fnname, decl);
@@ -1795,6 +1801,7 @@
       ASM_OUTPUT_LABEL (asm_out_file, crtl->subsections.hot_section_end_label);
       switch_to_section (save_text_section);
     }
+// printf ("MGB ** %s done\n", __func__);
 }
 
 /* Assemble code to leave SIZE bytes of zeros.  */
@@ -3525,6 +3532,7 @@
 init_varasm_status (void)
 {
   crtl->varasm.pool = create_constant_pool ();
+//   printf("MGB B%s init new pool %p\n", __func__, crtl->varasm.pool);
   crtl->varasm.deferred_constants = 0;
 }
 
@@ -3560,6 +3568,7 @@
   crtl->uses_const_pool = 1;
 
   /* Decide which pool to use.  */
+// printf("MGB use (shared) blocks=%d\n", targetm.use_blocks_for_constant_p (mode, x));
   pool = (targetm.use_blocks_for_constant_p (mode, x)
 	  ? shared_constant_pool
 	  : crtl->varasm.pool);
@@ -3607,21 +3616,28 @@
   else
     pool->first = pool->last = desc;
   pool->last = desc;
-
+// printf("MGB %s pool=%p last=%p\n", __func__, pool, desc);
   /* Create a string containing the label name, in LABEL.  */
   ASM_GENERATE_INTERNAL_LABEL (label, "LC", const_labelno);
+// printf("MGB %s added label LC%d\n", __func__, const_labelno);
   ++const_labelno;
 
   /* Construct the SYMBOL_REF.  Make sure to mark it as belonging to
      the constants pool.  */
+// printf("MGB %s use_obj...=%d\n", __func__, use_object_blocks_p());
+// printf("MGB %s use_bl...=%d\n", __func__, targetm.use_blocks_for_constant_p(mode,x));
   if (use_object_blocks_p () && targetm.use_blocks_for_constant_p (mode, x))
     {
+// printf("MGB %s create block symbol\n", __func__);
       section *sect = targetm.asm_out.select_rtx_section (mode, x, align);
       symbol = create_block_symbol (ggc_strdup (label),
 				    get_block_for_section (sect), -1);
     }
   else
+{
+// printf("MGB %s create symbol ref\n", __func__);
     symbol = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (label));
+}
   desc->sym = symbol;
   SYMBOL_REF_FLAGS (symbol) |= SYMBOL_FLAG_LOCAL;
   CONSTANT_POOL_ADDRESS_P (symbol) = 1;
@@ -3753,6 +3769,7 @@
      functioning even with INSN_DELETED_P and friends.  */
 
   tmp = x;
+// printf ("MGB %s code=%d\n", __func__, GET_CODE(tmp));
   switch (GET_CODE (tmp))
     {
     case CONST:
@@ -3811,11 +3828,16 @@
   if (x == NULL_RTX || GET_CODE (x) != SYMBOL_REF)
     return 0;
 
+// printf("MGB %s marking ",__func__);
+// output_addr_const(stdout,x);
+// printf("\n");
+
   if (CONSTANT_POOL_ADDRESS_P (x))
     {
       struct constant_descriptor_rtx *desc = SYMBOL_REF_CONSTANT (x);
       if (desc->mark == 0)
 	{
+// printf ("MGB %s recurse\n", __func__);
 	  desc->mark = 1;
 	  for_each_rtx (&desc->constant, mark_constant, NULL);
 	}
@@ -3844,6 +3866,7 @@
   if (!INSN_P (insn))
     return;
 
+// printf ("MGB %s\n", __func__);
   /* Insns may appear inside a SEQUENCE.  Only check the patterns of
      insns, not any notes that may be attached.  We don't want to mark
      a constant just because it happens to appear in a REG_EQUIV note.  */
@@ -3871,6 +3894,7 @@
 {
   rtx insn, link;
 
+// printf("MGB %s uses=%d deferred=%d\n",__func__,crtl->uses_const_pool,n_deferred_constants);
   if (!crtl->uses_const_pool && n_deferred_constants == 0)
     return;
 
@@ -3890,7 +3914,10 @@
 {
   struct constant_descriptor_rtx *desc;
 
+// printf("MGB %s pool=%p first=%p\n", __func__, pool, pool->first);
   for (desc = pool->first; desc ; desc = desc->next)
+{
+// printf("MGB %s desc=%p mark=%d\n",__func__,desc,desc->mark);
     if (desc->mark)
       {
 	/* If the constant is part of an object_block, make sure that
@@ -3908,6 +3935,7 @@
 	  }
       }
 }
+}
 
 /* Mark all constants that are used in the current function, then write
    out the function's private constant pool.  */
@@ -3917,6 +3945,7 @@
 		      tree fndecl ATTRIBUTE_UNUSED)
 {
   struct rtx_constant_pool *pool = crtl->varasm.pool;
+// printf ("MGB %s private pool=%p\n", __func__, pool);
 
   /* It is possible for gcc to call force_const_mem and then to later
      discard the instructions which refer to the constant.  In such a
@@ -3939,7 +3968,9 @@
 void
 output_shared_constant_pool (void)
 {
+// printf ("MGB out shared pool=%p\n", shared_constant_pool);
   output_constant_pool_contents (shared_constant_pool);
+// printf ("MGB %s ret\n", __func__);
 }
 
 /* Determine what kind of relocations EXP may need.  */
@@ -6611,6 +6642,7 @@
   tree decl;
   rtx symbol;
 
+// printf ("MGB %s o=%p\n", __func__, block->objects);
   if (block->objects == NULL)
     return;
 
@@ -6634,12 +6666,14 @@
       if (CONSTANT_POOL_ADDRESS_P (symbol))
 	{
 	  desc = SYMBOL_REF_CONSTANT (symbol);
+// printf ("MGB %s REF_CONST desc=%p\n", __func__, desc);
 	  output_constant_pool_1 (desc, 1);
 	  offset += GET_MODE_SIZE (desc->mode);
 	}
       else if (TREE_CONSTANT_POOL_ADDRESS_P (symbol))
 	{
 	  decl = SYMBOL_REF_DECL (symbol);
+// printf ("MGB %s REF_DECL decl=%p\n", __func__, decl);
 	  assemble_constant_contents (decl, XSTR (symbol, 0),
 				      get_constant_alignment (decl));
 	  offset += get_constant_size (decl);
@@ -6647,6 +6681,7 @@
       else
 	{
 	  decl = SYMBOL_REF_DECL (symbol);
+// printf ("MGB %s var REF_DECL decl=%p\n", __func__, decl);
 	  assemble_variable_contents (decl, XSTR (symbol, 0), false);
 	  offset += tree_low_cst (DECL_SIZE_UNIT (decl), 1);
 	}
@@ -6659,6 +6694,7 @@
 static int
 output_object_block_htab (void **slot, void *data ATTRIBUTE_UNUSED)
 {
+// printf ("MGB %s\n", __func__);
   output_object_block ((struct object_block *) (*slot));
   return 1;
 }
@@ -6668,7 +6704,9 @@
 void
 output_object_blocks (void)
 {
+// printf ("MGB %s\n", __func__);
   htab_traverse (object_block_htab, output_object_block_htab, NULL);
+// printf ("MGB %s done\n", __func__);
 }
 
 /* This function provides a possible implementation of the
diff -ru gcc-4.4.0-orig/gcc/version.c gcc-4.4.0/gcc/version.c
--- gcc-4.4.0-orig/gcc/version.c	2024-10-05 07:13:03.878412845 +0100
+++ gcc-4.4.0/gcc/version.c	2024-10-05 07:13:04.286409977 +0100
@@ -15,3 +15,4 @@
 
 const char version_string[] = BASEVER DATESTAMP DEVPHASE REVISION;
 const char pkgversion_string[] = PKGVERSION;
+const char revision_string[] = REVISION;
diff -ru gcc-4.4.0-orig/gcc/version.h gcc-4.4.0/gcc/version.h
--- gcc-4.4.0-orig/gcc/version.h	2024-10-05 07:13:03.882412817 +0100
+++ gcc-4.4.0/gcc/version.h	2024-10-05 07:13:04.294409921 +0100
@@ -2,5 +2,6 @@
 #define GCC_VERSION_H
 extern const char version_string[];
 extern const char pkgversion_string[];
+extern const char revision_string[];
 extern const char bug_report_url[];
 #endif /* ! GCC_VERSION_H */
diff -ru gcc-4.4.0-orig/libgcc/config.host gcc-4.4.0/libgcc/config.host
--- gcc-4.4.0-orig/libgcc/config.host	2009-04-17 12:58:41.000000000 +0100
+++ gcc-4.4.0/libgcc/config.host	2024-10-05 07:13:04.302409865 +0100
@@ -127,6 +127,9 @@
 sh[123456789lbe]*-*-*)
 	cpu_type=sh
 	;;
+tms9900-*-*)
+	cpu_type=tms9900
+	;;
 esac
 
 # Common parts for widely ported systems.
@@ -551,6 +554,8 @@
 	;;
 spu-*-elf*)
 	;;
+tms9900-*-*)
+	;;
 v850e1-*-*)
 	;;
 v850e-*-*)
