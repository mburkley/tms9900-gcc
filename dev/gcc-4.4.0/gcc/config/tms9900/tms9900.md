;;- Machine description for the TMS9900 for GNU C compiler
;; Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2004, 2005
;; 2007, 2008 Free Software Foundation, Inc.

;; Copyright 2009 Eric Welser (EMW)
;; Copyright 2023 Mark Burkley (MGB)

;; This file is part of GCC.

;; GCC is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.

;; GCC is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GCC; see the file COPYING3.  If not see
;; <http://www.gnu.org/licenses/>.

;; SI is 32 bit
;; HI is 16 bit
;; QI is 8 bit 

;; MGB NOTES
;;    - rtx notation is insn(dst,src) but tms asm notation is <op> src,dst so
;;      beware of operand ordering
;;    - all byte (QI) ops need to have expands to cater for the fact that in
;;      TMS9900 a 16-bit operation can't be done on a reg that contains an 8-bit value
;;      unless it has been shifted by 8
;;    - Many byte insns are restricted to registers only as TMS9900 doesn't have
;;      byte version of abs, neg, etc.
;;    - Insns like extend, trunc, abs, etc, are done in place but passed two
;;      distinct params.  This is ok, the compiler is forced to move src and dst to the
;;      same reg by the "0" constraint.
;;    - optimiser doesn't understand opcodes, just insns.  So keep insns as
;;      short as possible.  One opcode preferable, two max.  Any more, use an expand instead
;;    - TODO expands are not available at later optimisioation stages 
;;    - byte immediates can be problematic as immediates are 16-bit only and the
;;      other byte is an unknown.  In these cases, byte immediates are re-written in an
;;      expand to refer to a label in a constant pool using force_const_mem
;;    - I'm avoiding clobbers in expands and declaring temp rtx regs inside code
;;      instead.  Also using r0 as a scratch reg since it cannot be used as a general
;;      reg.
;;    - 32-bit arith insns have been moved to C code.  Emitting lengthy opcode
;;      sequences shouldn't be part of a md file.

;; Description of class IDs
;;   'L' is for 2 or -2
;;   'M' is for -1
;;   'N' is for 1
;;   'O' is for 0
;;   'Q' is for memory references that need an extra word after the opcode.
;;   'R' is for memory references which are encoded within the opcode.

;;- See file "rtl.def" for documentation on define_insn, match_*, et. al.

;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code
;;- updates for most instructions.

;;- Operand classes for the register allocator:

;; Compare instructions.


;; define attributes
;; currently type is only fpu or arith or unknown, maybe branch later ?
;; default is arith
(define_attr "type" "unknown,arith,fp" (const_string "arith"))

;; length default is 1 words each
(define_attr "length" "" (const_int 2))

;; a user's asm statement
(define_asm_attributes
  [(set_attr "type" "unknown")
; all bets are off how long it is - make it 256, forces long jumps 
; whenever jumping around it !!!
   (set_attr "length" "256")])

;;-------------------------------------------------------------------
;;  UNSPEC Definitions
;;-------------------------------------------------------------------
(define_constants
  [(UNSPEC_RETURN  0)])


;;-------------------------------------------------------------------
;;  Predicate Definitions
;;-------------------------------------------------------------------

;;-------------------------------------------------------------------
;;  Function Calls
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Jump to a subroutine which returns a value
(define_insn "call"
  [(call (match_operand:HI 0 "general_operand" "rR,Q")
         (match_operand:HI 1 "general_operand"  "g,g"))
  ]
  ""
  {
    tms9900_debug_operands ("call", insn, operands, 2);
    if(SIBLING_CALL_P(insn))
      output_asm_insn("b    %0", operands);
    else
      output_asm_insn("bl   %0", operands);
    return("");
  }
  [(set_attr "length" "2,4")]
)


;-------------------------------------------------------------------
; Jump to a subroutine which returns a value
(define_insn "call_value"
  [(set (match_operand 0 "" "")
        (call (match_operand:HI 1 "general_operand" "rR,Q")
	      (match_operand:HI 2 "general_operand" "g,g")))
  ]
  ""
  {
    tms9900_debug_operands ("call_value", insn, operands, 3);
    if(SIBLING_CALL_P(insn))
      output_asm_insn("b    %1", operands);
    else
      output_asm_insn("bl   %1", operands);
    return("");
  }
  [(set_attr "length" "2,4")]
)

;; The O2 and O3 optimise options replace BL @xxx with LI Ry,xxx and BL *Ry
;; when the BL is inside a loop, even though the LI is also inside the loop,
;; which makes it less efficient.  This peephole undoes this "optimisation"

; There is an issue with this when the register used to hold the jump address
; gets spilled to the stack.  The resulting attempt to do call @6[sp] fails of
; course.  Popping from stack needs to go through a reg.  But why spill a label
; address to stack?  That makes no sense.

; This peephole is disabled due to the above failure.  It's recomended instead
; to use -fno-function-cse to prevent gcc from replacing labels with regs

; (define_peephole2
;   [(set (match_operand:HI 0 "general_operand" "")
; 	(match_operand:HI 1 "general_operand" ""))
;    (set (match_operand:HI 2 "general_operand" "")
; 	(call (mem:HI (match_dup 0))
;               (match_operand:HI 3 "general_operand" "")))]
;   ""
;   [(set (match_dup 2)
;         (call (mem:HI (match_dup 1))
;               (match_dup 3)))]
;   "")



;;-------------------------------------------------------------------
;; Define function prologue
(define_expand "prologue"
  [(const_int 0)]
  ""
{
  tms9900_debug_operands ("prologue", NULL_RTX, NULL, 0);
  tms9900_expand_prologue();
  DONE;
})


;;-------------------------------------------------------------------
;; Define function epilogue
(define_expand "epilogue"
  [(return)]
  ""
{
  tms9900_debug_operands ("epilogue", NULL_RTX, NULL, 0);
  tms9900_expand_epilogue(false);
  DONE;
})

(define_expand "sibcall_epilogue"
  [(return)]
  ""
{
  tms9900_debug_operands ("sibcall_epilogue", NULL_RTX, NULL, 0);
  tms9900_expand_epilogue(true);
  DONE;
})


;;-------------------------------------------------------------------
;; Define function return
(define_insn "*rt"
  [(unspec [(match_operand:HI 0 "general_operand" "")] UNSPEC_RETURN)]
  ""
  {
    tms9900_debug_operands ("*rt", insn, operands, 1);
    return("b    *r11");
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;;  Comparison Instructions
;;-------------------------------------------------------------------

;; cmp to zero is done explicitly or implicitly so can just do a mov to self to
;; compare.  BUT if self is a ROM target then that could invoke unintended side
;; effects like bank switching, so mov to temp reg r0 instead.  This also saves
;; 2 bytes for mem label compares.

;;-------------------------------------
(define_insn "tsthi"
  [(set (cc0)
	(match_operand:HI 0 "nonimmediate_operand" "rR,Q"))]
  ""
  {
    tms9900_debug_operands ("tsthi", insn, operands, 1);
    return("mov  %0, r0");
  }
  [(set_attr "length" "2,6")])


;;-------------------------------------
(define_insn "tstqi"
  [(set (cc0)
	(match_operand:QI 0 "nonimmediate_operand" "rR,Q"))]
  ""
  {
    tms9900_debug_operands ("tstqi", insn, operands, 1);
    return("movb %0, r0");
  }
  [(set_attr "length" "2,6")])
 
;;-------------------------------------
;; Compare 2 16-bit values.
;;
;; If we are comparing a memory value to an immediate, it is cheaper to
;; compare to a literal than load an immediate to a scratch reg and compare to that
;; reg, so define insn as a split with the condition that op0 is not a reg and
;; op1 is a constant int.  If so, rewrite as a compare to a forced mem const.

(define_insn_and_split "cmphi"
  [(set (cc0)
	(compare (match_operand:HI 0 "nonimmediate_operand" "rR,rR,Q,Q,r")
		 (match_operand:HI 1 "general_operand"      "rR,Q,rR,Q,i")))]
  ""
  {
    tms9900_debug_operands ("split_cmphi", insn, operands, 2);

    if (which_alternative < 4)
      return "c    %0, %1";
    else
      return "ci   %0, %1";
  }
  "CONST_INT_P (operands[1]) && !REG_P (operands[0])"
  [(set (cc0)
	(compare (match_dup 0)
		 (match_dup 1)))]
  {
    tms9900_debug_operands ("split_cmphi", NULL_RTX, operands, 2);

    int val = INTVAL (operands[1]) & 0xffff;
    operands[1] = force_const_mem (HImode, GEN_INT (val));
  }
  [(set_attr "length" "2,4,4,6,4")]
)

;;-------------------------------------
;
; TODO expand to nonimmediate, not just memory
;
; Replace:
;   mov @x, r1
;   cmp @y, r1
;
; With:
;   cmp @y, @x

(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
	(match_operand:HI 1 "memory_operand" ""))
   (set (cc0)
        (compare (match_operand:HI 2 "memory_operand" "")
                 (match_dup 0)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0) 
        (compare (match_dup 2)
                 (match_dup 1)))]
  {
    tms9900_debug_operands ("peep-movhi-cmphi", NULL_RTX, operands, 3);
  }
)

;;-------------------------------------
;
; Replace:
;   movb @x,r1 
;   cmpb @y,r1
;
; With:
;   cmpb @y,@x

(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
	(match_operand:QI 1 "memory_operand" ""))
   (set (cc0)
        (compare (match_operand:QI 2 "memory_operand" "")
                 (match_dup 0)))]
  ""
  [(set (cc0) 
        (compare (match_dup 2)
                 (match_dup 1)))]
  {
    tms9900_debug_operands ("peep-movqi-cmpqi", NULL_RTX, operands, 3);
  }
)

;;-------------------------------------
;; Compare 2 8-bit values.
;;
;; Byte compares using immediates are problematic since the lower 8 bits are
;; unpredictable, so immediates are not allowed.  Compares to immediates are
;; handled by a split which replaces the immediate with a memory ref to a literal.
;;
;; The exception for compare to zero has been removed as adding a clr
;; instruction is longer than storing a zero byte in the constant pool 
;; 
;; Emitting a constant doesn't work if done as an insn.  Forcing a constant in an
;; expand doesn't work either in all cases.  Defining a split caused a compliation
;; abort when the cmpqi insn didn't have a match for a comparison to an immediate.
;; Using define_insn_and_split seems to solve the problem for all cases so far.
;;
;; This is a good candidate for define_insn_and_rewrite but this doesn't exist yet
;; in gcc4.4.0
;;
;; For some unknown reason, adding specific constraints here causes a reload error.
;; Making a general constraint with a worst-case length of 6 bytes avoid the issue.

(define_insn_and_split "cmpqi"
  [(set (cc0)
	(compare (match_operand:QI 0 "nonimmediate_operand" "=g")
		 (match_operand:QI 1 "general_operand"      "g")))]
  ""
  "cb   %0, %1"
  "CONST_INT_P (operands[1])"
  [(set (cc0)
 	(compare (match_dup 0)
 		 (match_dup 1)))]
  {
    tms9900_debug_operands ("split_cmpqi", NULL_RTX, operands, 2);
    int val = INTVAL (operands[1]) & 0xff;
    operands[1] = force_const_mem (QImode, GEN_INT (val));
  }
  [(set_attr "length" "6")]
)

;;-------------------------------------
;; Target specific insns to clr (set to 0) and seto (set to -1) for byte and
;; word.  NOTE CLR and SETO operate on 16-bit values so QI variants are constrained
;; to registers only

(define_insn "tms9900_clrqi"
  [(set (match_operand:QI 0 "register_operand" "=r")
        (const_int 0))]
  ""
  "clr  %0"
  [(set_attr "length" "2")])

(define_insn "tms9900_setoqi"
  [(set (match_operand:QI 0 "register_operand" "=r")
        (const_int 255))]
  ""
  "seto %0"
  [(set_attr "length" "2")])

(define_insn "tms9900_clrhi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
        (const_int 0))]
  ""
  "clr  %0"
  [(set_attr "length" "2,4")])

(define_insn "tms9900_setohi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
        (const_int 65535))]
  ""
  "seto %0"
  [(set_attr "length" "2,4")])

;;-------------------------------------------------------------------
;;  Move Operations
;;-------------------------------------------------------------------
  ; "movb %1, %0"
  ;
  ;  We need a constraint of i or we get the error "insn does not satisfy its
  ; constraints".  Confusing since the split should remove the immediate.  If we
  ; change general to nonimmed then we get "unrecognizable insn" so it seems we
  ; need to add alternate 4 even though it never actually can be used.
  ;
  ; nvm setoqi had register_operand as constraint

(define_expand "movqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "")
        (match_operand:QI 1 "general_operand"      ""))]
  ""
  {
    tms9900_debug_operands ("movqi", NULL_RTX, operands, 2);

    if (CONST_INT_P (operands[1]))
    {
      int val = INTVAL (operands[1]) & 0xff;
      if (val == 0 && REG_P (operands[0]))
      {
        emit_insn (gen_tms9900_clrqi (operands[0]));
        DONE;
      }

      if (val == 0xff && REG_P (operands[0]))
      {
        emit_insn (gen_tms9900_setoqi (operands[0]));
        DONE;
      }

      tms9900_inline_debug ("; movqi replace const with label\n");
      operands[1] = force_const_mem (QImode, operands[1]);
    }

    emit_insn (gen_tms9900_movqi (operands[0], operands[1]));
    DONE;
  }
)

;;-------------------------------------------------------------------
;; Native move byte value
;;
;; NOTE - this native method does not allow immediates

(define_insn "tms9900_movqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=r,rR>,Q,  rR>,Q")
        (match_operand:QI 1 "general_operand"      "r, rR>,rR>,Q,  Q"))]
  ""
  {
    tms9900_debug_operands ("tms9900_movqi", insn, operands, 2);

    /* Register to Register - If src has an offset, then it has been downgraded from a
     * HI, so move the entire 16-bit word and do a byte swap */

    if (which_alternative == 0 &&
        REG_P (operands[1]) && REG_OFFSET (operands[1]) == 1 &&
        ORIGINAL_REGNO (operands[1]) == REGNO (operands[1]))
    {
      output_asm_insn ("mov  %1, %0", operands);
      output_asm_insn ("swpb %0 ; movqi subreg truncate", operands);
    }
    else
      output_asm_insn ("movb %1, %0", operands);

    return "";
  }
  [(set_attr "length" "4,2,4,4,6")]
)

; Attempting to do post inc through peephole or insn
;
; (define_peephole2
;   [(set (mem:HI (match_operand:HI 0 "register_operand" ""))
;         (match_operand:QI 1 "nonimmediate_operand" ""))
;    (set (match_dup 0)
;         (plus (match_dup 0) (const_int 1)))]
;   ""
;   TODO
;
; set (mem:SI (plus:SI (reg:SI 3) (const_int -16))P


;  mem:QI (reg/f:HI 2 r2 [orig:21 x.0 ] [21]) [0 S1 A8])
;         (reg:QI 1 r1 [ c ])) 11 {tms9900_movqi} (expr_list:REG_DEAD (reg:QI 1 r1 [ c ])
;         (nil)))

;        movb r1, *r2

; addhi3-9 : (insn 9 8 19 <stdin>:4 (set (reg/f:HI 2 r2 [orig:21 x.0 ] [21])
;         (plus:HI (reg/f:HI 2 r2 [orig:21 x.0 ] [21])
;             (const_int 1 [0x1]))) 63 {addhi3} (nil))

;;-------------------------------------------------------------------
;; Move two-byte value
;;
;; Constraints O and M are listed as separate alternatives to allow SETO or CLR
;; to be used which would have a different length to LI.  SETO and CLR can also
;; work with R and Q.

(define_expand "movhi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "")
        (match_operand:HI 1 "general_operand"      ""))]
  ""
  {
    tms9900_debug_operands ("movhi", NULL_RTX, operands, 2);

    if (CONST_INT_P (operands[1]))
    {
      int val = INTVAL(operands[1]) & 0xffff;

      if (val == 0)
      {
        emit_insn (gen_tms9900_clrhi (operands[0]));
        DONE;
      }

      if (val == 0xffff)
      {
        emit_insn (gen_tms9900_setohi (operands[0]));
        DONE;
      }

      if (!REG_P (operands[0]))
      {
        tms9900_inline_debug ("; movhi replace const with label\n");
        operands[1] = force_const_mem (HImode, operands[1]);
      }
    }

    emit_insn (gen_tms9900_movhi (operands[0], operands[1]));
    DONE;
  }
)

(define_insn "tms9900_movhi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,  Q,r")
        (match_operand:HI 1 "general_operand"      "rR>, Q,  rR>,Q,i"))]
  ""
  {
    tms9900_debug_operands ("movhi", insn, operands, 2);
    tms9900_inline_debug ("; movhi alt=%d\n", which_alternative);

    if (which_alternative == 4)
    {
      return("li   %0, %1");
    }
    else
    {
      return("mov  %1, %0");
    }
  }
  [(set_attr "length" "2,4,4,6,4")])

;;-------------------------------------------------------------------
;; Move four-byte value as two 2-byte regs.  If immediate, emit two movhi insns
;; with high and low part of constants.  Constraints O and M are allowed so we
;; can issue seto or clr for -1 and 0 respectively
;;
;; Changed this from an expand back to an insn - why?
;;-------------------------------------------------------------------
(define_expand "movsi"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR>,rR>,Q,  Q,r, r")
	(match_operand:SI 1 "general_operand"      "rR>, Q,  rR>,Q,OM,n"))]
  ""
  {
    tms9900_debug_operands ("movsi", NULL_RTX, operands, 2);

    rtx args[2];
    if (CONST_INT_P (operands[1]))
    {
      args[0] = gen_rtx_CONST_INT (HImode, ((UINTVAL(operands[1])&0xffff0000)>>16));
      args[1] = gen_rtx_CONST_INT (HImode, (UINTVAL(operands[1])&0xffff));
    }
    else
    {
      args[0] = gen_highpart(HImode, operands[1]);
      args[1] = gen_lowpart(HImode, operands[1]);
    }
    emit_move_insn (gen_highpart (HImode, operands[0]), args[0]);
    emit_move_insn (gen_lowpart (HImode, operands[0]), args[1]);
    DONE;
  })
;  [(set_attr "length" "4,8,8,12,4,8")])

;;-------------------------------------------------------------------
;; Type Conversions
;;-------------------------------------------------------------------

(define_insn "*zero_extendqihi2_subreg"
  [(set (match_operand:HI 0 "register_operand" "=r,r,r")
	(zero_extend:HI (subreg:HI (match_operand:QI 1 "nonimmediate_operand" "0,R,Q") 0)))]
  ""
  {
    tms9900_debug_operands ("zero_extendqihi2_subreg", insn, operands, 2);

    if (which_alternative > 0)
    {
      output_asm_insn ("movb %1, %0", operands);
    }
    output_asm_insn ("srl  %0, 8", operands);
    return("");
  }
  [(set_attr "length" "2,4,6")])

;;-------------------------------------------------------------------
;; Zero Extend
;; If op1 is not a register, we need to mov the value to op0 first.  As a
;; result, R and Q constraints are different length to r.
;;-------------------------------------

(define_insn "zero_extendqihi2"
  [(set (match_operand:HI 0 "register_operand" "=r,r,r")
	(zero_extend:HI (match_operand:QI 1 "nonimmediate_operand" "0,R,Q")))]
  ""
  {
    tms9900_debug_operands ("zero_extendqihi2", insn, operands, 2);

    if (which_alternative > 0)
    {
      output_asm_insn ("movb %1, %0", operands);
    }
    output_asm_insn ("srl  %0, 8", operands);
    return("");
  }
  [(set_attr "length" "2,4,6")])

;;-------------------------------------
; TODO Could do a gen_lowpart into op0 to prevent the tmp
(define_expand "zero_extendqisi2"
  [(set (match_operand:SI 0 "register_operand" "")
	(zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "")))]
  ""
  {
    tms9900_debug_operands ("zero_extendqisi2", NULL_RTX, operands, 2);
    rtx tmp = gen_reg_rtx (HImode);
    emit_insn (gen_zero_extendqihi2 (tmp, operands[1]));
    emit_insn (gen_zero_extendhisi2 (operands[0], tmp));
    DONE;
  }
)

(define_insn "zero_extendhisi2"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR,Q")
	(zero_extend:SI (match_operand:HI 1 "general_operand" "g,g")))]
  ""
  {
    tms9900_debug_operands ("zero_extendhisi2", insn, operands, 2);
    rtx args[3];
    args[0] = gen_highpart (HImode, operands[0]);
    args[1] = gen_lowpart (HImode, operands[0]);
    args[2] = operands[1];

    output_asm_insn("mov  %2, %1", args);
    output_asm_insn("clr  %0", args);
    return("");
  }
  [(set_attr "length" "4,8")])


;;-------------------------------------------------------------------
;; Sign Extend
;;-------------------------------------------------------------------

(define_insn "extendqihi2"
  [(set (match_operand:HI 0 "register_operand" "=r,r,r")
	(sign_extend:HI (match_operand:QI 1 "nonimmediate_operand" "0,R,Q")))]
  ""
  {
    tms9900_debug_operands ("extendqihi2", insn, operands, 2);
    if (which_alternative > 0)
    {
      output_asm_insn ("movb %1, %0", operands);
    }
    output_asm_insn("sra  %0, 8", operands);
    return("");
  }
  [(set_attr "length" "2,4,6")])
			 

(define_expand "extendqisi2"
  [(set (match_operand:SI 0 "register_operand" "")
	(sign_extend:SI (match_operand:QI 1 "nonimmediate_operand" "")))]
  ""
  {
    tms9900_debug_operands ("extendqisi2", NULL_RTX, operands, 2);
    rtx tmp = gen_reg_rtx (HImode);
    emit_insn (gen_extendqihi2 (tmp, operands[1]));
    emit_insn (gen_extendhisi2 (operands[0], tmp));
    DONE;
  }
)

;;-------------------------------------
(define_insn "extendhisi2"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR,Q")
	(sign_extend:SI (match_operand:HI 1 "general_operand" "g,g")))]
  ""
  {
    tms9900_debug_operands ("extendhisi2", insn, operands, 2);
    rtx args[3];
    rtx offset[1];
    args[0] = gen_highpart (HImode, operands[0]);
    args[1] = gen_lowpart (HImode, operands[0]);
    args[2] = operands[1];

    if(which_alternative == 1)
      offset[0] = GEN_INT(6);
    else
      offset[0] = GEN_INT(4);

    output_asm_insn("mov  %2, %1", args);
    /* sign extend.  If highpart is negative, seto, else clr.  This is slightly
     * cheaper (either 20 or 30 cycles) than doing sra 16 (44 cycles) */
    output_asm_insn("seto %0", args);
    output_asm_insn("jlt  $+%0", offset);
    output_asm_insn("clr  %0", args);
    return("");
  }
  [(set_attr "length" "8,12")])

;;-------------------------------------------------------------------
;; Truncate
;
;  swpb will suffice for non-strict in place truncation.  There is no strict variant of
;  truncate so I am assuming we doesn't care about unused bits.
;;-------------------------------------

(define_insn "trunchiqi2"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,Q")
	(truncate:QI (match_operand:HI 1 "nonimmediate_operand" "0,0")))]
  ""
  {
    tms9900_debug_operands ("trunchiqi2", insn, operands, 2);
    return ("swpb %0");
  }
  [(set_attr "length" "2,4")])

(define_insn "truncsihi2"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
	(truncate:HI (match_operand:SI 1 "nonimmediate_operand" "rR>,Q,rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("truncsihi2", insn, operands, 2);
    operands[1] = gen_lowpart (HImode, operands[1]);
    return "mov  %1, %0";
  }
  [(set_attr "length" "2,4,4,6")])

(define_expand "truncsiqi2"
  [(set (match_operand:QI 0 "nonimmediate_operand" "")
	(truncate:QI (match_operand:SI 1 "nonimmediate_operand" "")))]
  ""
  {
    tms9900_debug_operands ("truncsiqi2", NULL_RTX, operands, 2);
    emit_insn (gen_truncsihi2 (operands[0], operands[0]));
    emit_insn (gen_trunchiqi2 (operands[0], operands[0]));
    DONE;
  }
)

;;-------------------------------------------------------------------
;;  Branch Instructions
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Jump if equal
(define_insn "beq"
  [(set (pc)
	(if_then_else (eq (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  {
    tms9900_debug_operands ("beq", insn, operands, 1);
    return(output_branch("jeq", "jne", get_attr_length(insn)));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if equal, reversed comparison operands
(define_insn "*beq_reversed"
  [(set (pc)
	(if_then_else (eq (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  {
    tms9900_debug_operands ("*beq_reversed", insn, operands, 1);
    return(output_branch("jne", "jeq", get_attr_length(insn)));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if not equal
(define_insn "bne"
  [(set (pc)
	(if_then_else (ne (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  {
    tms9900_debug_operands ("bne", insn, operands, 1);
    return output_branch(\"jne\", \"jeq\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if not equal, reversed comparison operands
(define_insn "*bne_reversed"
  [(set (pc)
	(if_then_else (ne (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  {
    tms9900_debug_operands ("*bne_reversed", insn, operands, 1);
    return output_branch(\"jeq\", \"jne\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if unsigned less than
(define_insn "bltu"
  [(set (pc)
	(if_then_else (ltu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  {
    tms9900_debug_operands ("bltu", insn, operands, 1);
    return output_branch(\"jl\", \"jhe\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if unsigned less than, reversed comparison operands
(define_insn "*bltu_reversed"
  [(set (pc)
	(if_then_else (ltu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  {
    tms9900_debug_operands ("*bltu_reversed", insn, operands, 1);
    return output_branch(\"jhe\", \"jl\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if unsigned less than or equal
(define_insn "bleu"
  [(set (pc)
	(if_then_else (leu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  {
    tms9900_debug_operands ("bleu", insn, operands, 1);
    return output_branch(\"jle\", \"jh\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if unsigned less than or equal, reversed comparison operands
(define_insn "*bleu_reversed"
  [(set (pc)
	(if_then_else (leu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  {
    tms9900_debug_operands ("*bleu_reversed", insn, operands, 1);
    return output_branch(\"jh\", \"jle\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if unsigned greater than
(define_insn "bgtu"
  [(set (pc)
	(if_then_else (gtu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  {
    tms9900_debug_operands ("bgtu", insn, operands, 1);
    return output_branch(\"jh\", \"jle\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if unsigned greater than, reversed comparison operands
(define_insn "*bgtu_reversed"
  [(set (pc)
	(if_then_else (gtu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  {
    tms9900_debug_operands ("*bgtu_reversed", insn, operands, 1);
    return output_branch(\"jle\", \"jh\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if unsigned greater than or equal
(define_insn "bgeu"
  [(set (pc)
	(if_then_else (geu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  {
    tms9900_debug_operands ("bgeu", insn, operands, 1);
    return output_branch(\"jhe\", \"jl\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if unsigned greater than or equal, reversed comparison operands
(define_insn "*bgeu_reversed"
  [(set (pc)
	(if_then_else (geu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  {
    tms9900_debug_operands ("*bgeu_reversed", insn, operands, 1);
    return output_branch(\"jl\", \"jhe\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if less than
(define_insn "blt"
  [(set (pc)
	(if_then_else (lt (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  {
    tms9900_debug_operands ("blt", insn, operands, 1);
    return output_branch(\"jlt\", \"GE\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 18)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if less than, reversed comparison operands
; Was commented out
(define_insn "*blt_reversed"
  [(set (pc)
	(if_then_else (lt (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  {
    tms9900_debug_operands ("*blt_reversed", insn, operands, 1);
    return output_branch(\"GE\", \"jlt\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 14)))])


;;-------------------------------------------------------------------
;; Jump if less than or equal
(define_insn "ble"
  [(set (pc)
	(if_then_else (le (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  {
    tms9900_debug_operands ("ble", insn, operands, 1);
    return output_branch(\"LE\", \"jgt\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 14)))])


;;-------------------------------------
;; Jump if less than or equal, reversed comparison operands
(define_insn "*ble_reversed"
  [(set (pc)
	(if_then_else (le (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  {
    tms9900_debug_operands ("*ble_reversed", insn, operands, 1);
    return output_branch(\"jgt\", \"LE\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 18)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if greater than
(define_insn "bgt"
  [(set (pc)
	(if_then_else (gt (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  {
    tms9900_debug_operands ("bgt", insn, operands, 1);
    return output_branch(\"jgt\", \"LE\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 18)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if greater than, reversed comparison operands
; Was commented out
(define_insn "*bgt_reversed"
  [(set (pc)
	(if_then_else (gt (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  {
    tms9900_debug_operands ("*bgt_reversed", insn, operands, 1);
    return output_branch(\"LE\", \"jgt\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 14)))])


;;-------------------------------------------------------------------
;; Jump if greater than or equal
; Was commented out
(define_insn "bge"
  [(set (pc)
	(if_then_else (ge (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  {
    tms9900_debug_operands ("bge", insn, operands, 1);
    return output_branch(\"GE\", \"jlt\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 14)))])


;;-------------------------------------
;; Jump if greater than or equal, reversed comparison operands
(define_insn "*bge_reversed"
  [(set (pc)
	(if_then_else (ge (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  {
    tms9900_debug_operands ("*bge_reversed", insn, operands, 1);
    return output_branch(\"jlt\", \"GE\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 18)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;;  Jump Operations
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Unconditional jump to label
(define_insn "jump"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  ""
  {
    tms9900_debug_operands ("jump", insn, operands, 1);
    return output_jump(get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 14)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Unconditional jump using pointer
(define_insn "indirect_jump"
  [(set (pc) (match_operand:HI 0 "nonimmediate_operand" "r,Q"))]
  ""
  {
    tms9900_debug_operands ("indirect_jump", insn, operands, 1);
    return "b    %0";
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------------------------------------
;; Unconditional jump using jump table
(define_insn "tablejump"
  [(set (pc) (match_operand:HI 0 "nonimmediate_operand" "rR,Q"))
   (use (label_ref (match_operand 1 "" "")))]
  ""
  {
    tms9900_debug_operands ("tablejump", insn, operands, 1);
    output_asm_insn("mov  %0, r0", operands);
    output_asm_insn("b    *r0",    operands);
    return(""); 
  }
  [(set_attr "length" "4,6")])


;;-------------------------------------------------------------------
;;  Bit Shift Operations
;;-------------------------------------------------------------------

;; NOTE : On the TMS9900 a shift count of 0 is interpreted as
;; shift by 16, so test for 0 and jump over the shift if true.  Do the same in
;; all other shift by register insns as well.

;; Accept any shift count but if it is not a constant, load it into r0 first.

;; If we are asked to shift by a constant 0 then the
;; compiler is being stupid so detect this (constraint 'O') and emit nothing

;;-------------------------------------------------------------------
;; Arithmetic shift left.
;;
;;-------------------------------------------------------------------
(define_insn "ashlhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r,r,r")
	(ashift:HI (match_operand:HI 1 "register_operand" "0,0,0,0")
		   (match_operand:HI 2 "general_operand" "rR,Q,O,i")))]
  ""
  {
    tms9900_debug_operands ("ashlhi3", insn, operands, 3);

    if(!CONST_INT_P (operands[2]))
    {
      output_asm_insn("mov  %2, r0",   operands);
      output_asm_insn("jeq  $+4",    operands);
      output_asm_insn("sla  %0, 0",  operands);
    }
    else
    {
      int count = INTVAL (operands[2]);

      /* If operand 1 is a subreg with an offset, then byte is in wrong place so
       * subtract 8 from shift count.  If this results in a shift count of zero
       * then do nothing. */
      if (tms9900_operand_subreg_offset (operands[1], HImode))
        count -= 8;

      if ((count & 15) != 0)
      {
        operands[2] = GEN_INT (count);
        output_asm_insn("sla  %0, %2", operands);
      }
    }
    return(""); 
  }
  [(set_attr "length" "6,8,0,2")])


;;-------------------------------------
(define_insn "ashlqi3"
  [(set (match_operand:QI 0 "register_operand" "=r,r,r,r")
        (ashift:QI (match_operand:QI 1 "register_operand" "0,0,0,0")
                   (match_operand:HI 2 "general_operand" "rR,Q,O,i")))]
  ""
  {
    tms9900_debug_operands ("ashlqi3", insn, operands, 3);
    if(which_alternative < 2)
    {
      output_asm_insn("mov  %2, r0",   operands);
      output_asm_insn("jeq  $+8",       operands);  /* If shift count is zero, do nothing */
      output_asm_insn("andi %0, >FF00", operands);
      output_asm_insn("sla  %0, 0",     operands);
    }
    else if (which_alternative > 2)
    {
      output_asm_insn("andi %0, >FF00", operands);
      output_asm_insn("sla  %0, %2",    operands);
    }
    return(""); 
  }
  [(set_attr "length" "10,12,0,6")])


;;-------------------------------------------------------------------
;; Arithmetic shift left (for QI mode)

(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(sign_extend:HI(match_operand:QI 1 "register_operand" "r,r")))
   (set (match_operand:HI 2 "register_operand" "=r,r")
	(ashift:HI (match_dup 0)
                   (plus:HI (match_operand:HI 3 "const_int_operand" "i,i")
                            (match_operand:HI 4 "const_int_operand" "i,i"))))]
  ""
  [(set (match_dup 2)
        (match_dup 1))
   (set (match_dup 2)
        (ashift:QI (match_dup 2)
                   (match_dup 3)))]
  {
    tms9900_debug_operands ("peep-alsqi", NULL_RTX, operands, 5);
  }
 )


;;-------------------------------------
(define_insn "ashrhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r,r,r")
	(ashiftrt:HI (match_operand:HI 1 "register_operand" "0,0,0,0")
		     (match_operand:HI 2 "general_operand" "rR,Q,O,i")))]
  ""
  {
    tms9900_debug_operands ("ashrhi3", insn, operands, 3);
    if(which_alternative < 2)
    {
      output_asm_insn("mov  %2, r0",   operands);
      output_asm_insn("jeq  $+4",    operands);
      output_asm_insn("sra  %0, 0",  operands);
    }
    else if (which_alternative > 2)
    {
      output_asm_insn("sra  %0, %2", operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,8,0,2")])


;;-------------------------------------
(define_insn "ashrqi3"
  [(set (match_operand:QI 0 "register_operand" "=r,r,r,r")
	(ashiftrt:QI (match_operand:QI 1 "register_operand" "0,0,0,0")
		     (match_operand:HI 2 "general_operand" "rR,Q,O,i")))]
  ""
  {
    tms9900_debug_operands ("ashrqi3", insn, operands, 3);
    if(which_alternative < 2)
    {
      output_asm_insn("mov  %2, r0",  operands);
      output_asm_insn("jeq  $+4",    operands);
      output_asm_insn("sra  %0, 0",  operands);
    }
    else if (which_alternative > 2)
    {
      output_asm_insn("sra  %0, %2",    operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,8,0,2")])


;;-------------------------------------
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "r,r")
	(sign_extend:HI(match_operand:QI 1 "register_operand" "r,r")))
   (set (match_operand:HI 3 "register_operand" "r,r")
	(ashiftrt:HI (match_operand:HI 4 "register_operand" "0,0")
		     (match_operand:HI 5 "general_operand" "rRQ,i")))
   (set (match_operand:QI 6 "register_operand" "r,r")
        (subreg:QI (match_operand:HI 7 "register_operand" "3,3") 1))]
  ""
  [(set (match_dup 6)
        (match_dup 1))
   (set (match_dup 6)
        (ashiftrt:QI (match_dup 6)
                     (match_dup 5)))]
  {
    tms9900_debug_operands ("peep-asrhi", NULL_RTX, operands, 8);
  }
)


;;-------------------------------------------------------------------
;; Logical shift right



;;-------------------------------------
(define_insn "lshrhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r,r,r")
	(lshiftrt:HI (match_operand:HI 1 "register_operand" "0,0,0,0")
		     (match_operand:HI 2 "general_operand" "rR,Q,O,i")))]
  ""
  {
    tms9900_debug_operands ("lshrhi3", insn, operands, 3);
    if(which_alternative < 2)
    {
      output_asm_insn("mov  %2, r0",  operands);
      output_asm_insn("jeq  $+4",    operands);
      output_asm_insn("srl  %0, 0",  operands);
    }
    else if (which_alternative > 2)
    {
      output_asm_insn("srl  %0, %2", operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,8,0,2")])


;;-------------------------------------
; shift right 8 (extend) followed by truncate (swpb) negate each other so remove
; by emitting a nop (const_int 0)

(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
	(lshiftrt:HI (match_dup 0)
		     (const_int 8)))
   (set (match_operand:QI 1 "register_operand" "")
	(truncate:QI(match_dup 0)))]
  ""
  [(const_int 0)]
  {
    tms9900_debug_operands ("peep-lsrhi", NULL_RTX, operands, 2);
  }
)

;;-------------------------------------
; same for arith shift 8

(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
	(ashiftrt:HI (match_dup 0)
		     (const_int 8)))
   (set (match_operand:QI 1 "register_operand" "")
	(truncate:QI(match_dup 0)))]
  ""
  [(const_int 0)]
  {
    tms9900_debug_operands ("peep-asrhi", NULL_RTX, operands, 2);
  }
)

;;-------------------------------------
(define_insn "lshrqi3"
  [(set (match_operand:QI 0 "register_operand" "=r,r,r,r")
	(lshiftrt:QI (match_operand:QI 1 "register_operand" "0,0,0,0")
		     (match_operand:HI 2 "general_operand" "rR,Q,O,i")))]
  ""
  {
    tms9900_debug_operands ("lshrqi3", insn, operands, 3);
    if(which_alternative < 2)
    {
      output_asm_insn("mov  %2, r0",  operands);
      output_asm_insn("jeq  $+4",    operands);
      output_asm_insn("srl  %0, 0",  operands);
    }
    else if (which_alternative > 2)
    {
      output_asm_insn("srl  %0, %2",    operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,8,0,2")])


(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "r,r")
	(sign_extend:HI(match_operand:QI 1 "register_operand" "r,r")))
   (set (match_operand:HI 3 "register_operand" "r,r")
	(lshiftrt:HI (match_operand:HI 4 "register_operand" "0,0")
		     (match_operand:HI 5 "general_operand" "rRQ,i")))
   (set (match_operand:QI 6 "register_operand" "r,r")
        (subreg:QI (match_operand:HI 7 "register_operand" "3,3") 1))]
  ""
  [(set (match_dup 6)
        (match_dup 1))
   (set (match_dup 6)
        (lshiftrt:QI (match_dup 6)
                     (match_dup 5)))]
  {
    tms9900_debug_operands ("peep-lsrhi", NULL_RTX, operands, 8);
  }
)
      


;;-------------------------------------------------------------------
;; Rotate 


;;-------------------------------------
(define_expand "rotlhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (rotatert:HI (match_operand:HI 1 "register_operand" "0,0")
                     (match_operand:HI 2 "general_operand" "rRQ,i")))]
  ""
  {
    tms9900_debug_operands ("rotlhi3", NULL_RTX, operands, 3);
    tms9900_inline_debug ("; rotlhi3 alt=%d\n", which_alternative);
    if (GET_CODE (operands[2]) == CONST_INT)
      operands[2] = GEN_INT ((16 - INTVAL (operands[2])) % 16);
    else
      {
        rtx reg = gen_reg_rtx (HImode);
        emit_insn (gen_subhi3 (reg, GEN_INT (16), operands[2]));
        operands[2] = reg;
      }
    DONE;
  })


;;-------------------------------------
(define_insn "rotrhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (rotatert:HI (match_operand:HI 1 "register_operand" "0,0")
                     (match_operand:HI 2 "general_operand" "rRQ,i")))]
  ""
  "@
  src  %0, 0
  src  %0, %2" 
 [(set_attr "length" "2,2")])


;;-------------------------------------------------------------------
;;  Bitwise Operations
;;-------------------------------------------------------------------

;;-------------------------------------------------------------------
;; And
;;
;; Uses r0 as a clobber
;;-------------------------------------
(define_insn "andhi3"
  [(set (match_operand:HI 0 "nonimmediate_operand"         "=rR>,rR>,Q,  Q,r,r,r,R>,Q")
	(and:HI (match_operand:HI 1 "nonimmediate_operand" "0,   0,  0,  0,0,0,0,0, 0")
		(match_operand:HI 2 "general_operand"      "rR>, Q,  rR>,Q,O,M,i,i, i")))]
  ""
  {
    tms9900_debug_operands ("andhi3", insn, operands, 3);

    /*  If the optimiser sees that we are doing an and operation with a constant
     *  that is 0xFF or less then it assumes there is no need to extend any byte
     *  parameters.  This is not true for tms9900 as we need to shift the MSB
     *  into the LSB.  Check for offsets in the operands and emit shifts to get
     *  the bytes into the right place. */

    if (tms9900_operand_subreg_offset (operands[1], HImode))
    {
      tms9900_inline_debug ("; andhi3, op[1] off %d\n", REG_OFFSET (operands[1]));

      /*  If the mask is a constant int of one byte then cheaper to do a swpb
       *  than sra. */
      if (CONST_INT_P (operands[2]) &&
          (INTVAL (operands[2]) & 0xff) == INTVAL (operands[2]))
        output_asm_insn ("swpb %1 ; andhi extend op1", operands);
      else
        output_asm_insn ("sra  %1,8 ; andhi extend op1", operands);
    }

    if(which_alternative == 4)
    {
      /* Some paranoia here - confirm O constraint really has given us a const int of
       * zero */
      if (!CONST_INT_P (operands[2]) || (INTVAL(operands[2]) & 0xFFFF) != 0)
        gcc_unreachable();

      /* Result will be zero */
      return("clr  %0");
    }
    else if(which_alternative == 5)
    {
      if (!CONST_INT_P (operands[2]) || (INTVAL(operands[2]) & 0xFFFF) != 0xFFFF)
        gcc_unreachable();

      /* No operation required */
      return("");
    }
    else if(which_alternative == 6)
    {
      /* AND const value and register */
      output_asm_insn("andi %0, %2", operands);
    }
    else if(which_alternative >= 7)
    {
      /* AND const value and memory */
      if (!CONST_INT_P (operands[2]))
        gcc_unreachable();

      int val = ~INTVAL(operands[2]);
      operands[2] = GEN_INT(val & 0xFFFF);
      output_asm_insn("li   r0, %2", operands);
      output_asm_insn("szc  r0, %0", operands);
    }
    else
    {
      /* AND against non-const value.  Copy to R0 as clobber, invert and SZC */
      output_asm_insn("mov  %2, r0", operands);
      output_asm_insn("inv  r0",     operands);
      output_asm_insn("szc  r0, %0", operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,8,8,10,2,0,4,6,8")])


(define_insn "*andnothi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
	(and:HI (match_operand:HI 1 "nonimmediate_operand" "0,0,0,0")
		(not:HI (match_operand:HI 2 "nonimmediate_operand" "rR>,Q,rR>,Q"))))]
  ""
  {
    tms9900_debug_operands ("*andnothi", insn, operands, 3);
    return "szc  %2, %0";
  }
  [(set_attr "length" "2,4,4,6")])


; This handles reverse-order not-and combinations
(define_insn "*not_andhi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
	(and:HI (not:HI (match_operand:HI 1 "nonimmediate_operand" "rR>,Q,rR>,Q"))
                (match_operand:HI 2 "nonimmediate_operand" "0,0,0,0")))]
  ""
  {
    tms9900_debug_operands ("*not_andhi", insn, operands, 3);
    return "szc  %1, %0";
  }
  [(set_attr "length" "2,4,4,6")])


;;-------------------------------------
;;
;; NOTE - we assume that constraint 'i' will only pass a CONST_INT as labels
;; etc don't make sense in the context of a byte operation.  Assert if assumption
;; not true.  If the constant evaluates to 0x00 or 0xFF then apply a short circuit.
;; This will mean length is shorter than declared but that should not matter.
;;
(define_insn "andqi3"
  [(set (match_operand:QI 0 "nonimmediate_operand"         "=rR>,rR>,Q,  Q,r,R>,Q")
	(and:QI (match_operand:QI 1 "nonimmediate_operand" "0,   0,  0,  0,0,0, 0")
		(match_operand:QI 2 "general_operand"      "rR>, Q,  rR>,Q,i,i, i")))]
  ""
  {
    tms9900_debug_operands ("andqi3", insn, operands, 3);
    if(which_alternative >= 4)
    {
      if (!CONST_INT_P (operands[2]))
        gcc_unreachable();

      int val = (INTVAL(operands[2]) << 8) & 0xFF00;

      /* AND const value and register */
      if(val == 0xff00)
        return("");

      if (which_alternative == 4)
      {
        /* AND const value and register */
        operands[2] = GEN_INT(val);
        output_asm_insn ("andi %0, %2", operands);
      }
      else
      {
        /* AND const value and memory */
        operands[2] = GEN_INT(~val);
        output_asm_insn("li   r0, %2", operands);
        output_asm_insn("szcb r0, %0", operands);
      }
    }
    else
    {
      output_asm_insn("movb %2, r0", operands);
      output_asm_insn("inv  r0", operands);
      output_asm_insn("szcb r0, %0", operands);
    }
    return("");
  }
  [(set_attr "length" "6,8,8,10,4,6,8")])


(define_insn "*andnotqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
	(and:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0")
		(not:QI (match_operand:QI 2 "nonimmediate_operand" "rR>,Q,rR>,Q"))))]
  ""
  {
    tms9900_debug_operands ("*not_andhi", insn, operands, 3);
    return "szcb %2, %0";
  }
  [(set_attr "length" "2,4,4,6")])


; This handles reverse-order not-and combinations
(define_insn "*not_andqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
	(and:QI (not:QI (match_operand:QI 1 "nonimmediate_operand" "rR>,Q,rR>,Q"))
                (match_operand:QI 2 "nonimmediate_operand" "0,0,0,0")))]
  ""
  {
    tms9900_debug_operands ("*not_andhi", insn, operands, 3);
    return "szcb %1, %0";
  }
  [(set_attr "length" "2,4,4,6")])


;;-------------------------------------------------------------------
;; Or


;;-------------------------------------
(define_insn "iorhi3"
  [(set (match_operand:HI 0 "nonimmediate_operand"         "=rR>,rR>,Q,  Q,r,r,r")
	(ior:HI (match_operand:HI 1 "nonimmediate_operand" "%0,  0,  0,  0,0,0,0")
		(match_operand:HI 2 "general_operand"      "rR>, Q,  rR>,Q,O,M,n")))]
  ""
  {
    tms9900_debug_operands ("iorhi3", insn, operands, 3);

    if (which_alternative < 4)
      return("soc  %2, %0");
    else
    {
      if (!CONST_INT_P (operands[2]))
        gcc_unreachable();

      int val = INTVAL(operands[2]) & 0xFFFF;
      if(val == 0xFFFF)
        return "seto %0";
      else if(val == 0)
        return "";

      return "ori  %0, %2";
    }
  }
  [(set_attr "length" "2,4,4,6,0,2,4")])


;;-------------------------------------
(define_insn "iorqi3"
   [(set (match_operand:QI 0 "nonimmediate_operand"        "=rR>,Q,  rR>,Q,r")
	(ior:QI (match_operand:QI 1 "nonimmediate_operand" "0,   0,  0,  0,0")
		(match_operand:QI 2 "general_operand"      "rR>, rR>,Q,  Q,n")))]
  ""
  {
    tms9900_debug_operands ("iorqi3", insn, operands, 3);

    if (which_alternative < 4)
      return ("socb %2, %0");
    else
    {
      if (!CONST_INT_P (operands[2]))
        gcc_unreachable();

      int val = (INTVAL(operands[2]) << 8) & 0xFF00;
      tms9900_inline_debug ("; iorqi3 val=%X\n", val);
      rtx args[2];
      args[0] = operands[0];
      args[1] = GEN_INT(val);
      /* AND const value and register */
      if(val == 0)
        return("");
      else if(val == 0xff00)
        output_asm_insn("seto %0", args);
      else
        output_asm_insn("ori  %0, %1", args);
    }
    return("");
  }
  [(set_attr "length" "2,4,4,6,4")])


;;-------------------------------------------------------------------
;; Xor


;;-------------------------------------
(define_insn "xorhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(xor:HI (match_operand:HI 1 "register_operand" "%0,0")
		(match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("xorhi3", insn, operands, 3);
    return "xor  %2, %0";
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------
;; This works for regs only as xor is 16-bit only and should not be used on
;; memory locations as it will affect the neighbouring byte
(define_insn "xorqi3"
  [(set (match_operand:QI 0 "register_operand" "=r")
	(xor:QI (match_operand:QI 1 "register_operand" "%0")
		(match_operand:QI 2 "nonimmediate_operand" "r")))]
  ""
  {
    tms9900_debug_operands ("xorqi3", insn, operands, 3);
    return "xor  %2, %0";
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Not
;;-------------------------------------
(define_insn "one_cmplhi2"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
        (not:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))]
  ""
  {
    tms9900_debug_operands ("one_cmplhi2", insn, operands, 2);
    return "inv  %0";
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------
;; This works for regs only as inv is 16-bit only and should not be used on
;; memory locations as it will affect the neighbouring byte
(define_insn "one_cmplqi2"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=r")
        (not:QI (match_operand:QI 1 "nonimmediate_operand" "0")))]
  ""
  {
    tms9900_debug_operands ("one_cmplqi2", insn, operands, 2);
    return "inv  %0";
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;;  Arithmetic Operations
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Add
;;
;; Define addhi3 as an insn and split.  If operand[2] is a constant and
;; operand[0] is not a register, then it is cheaper to add a memory constant than
;; to load into an intermediate register and do add immediate.
;;
;; The constraints LMN are broken out separately as these can be done using
;; inc[t] or dec[t] directly on a reg or memory location.
;;
;; The first two constraints with a dest of register only try to catch a missing
;; extend where a subreg with an offset is passed in either operands[1] or
;; operands[2].  This needs to be corrected using SRA.  A subreg with an offset
;; will only appear in a register.  It is also assumed this will only happen
;; when the destination is a register.
;;-------------------------------------
(define_insn_and_split "addhi3"
  [(set (match_operand:HI 0 "nonimmediate_operand"          "=r, r,rR>,Q,  r,R>, R>,Q,  Q")
	(plus:HI (match_operand:HI 1 "nonimmediate_operand" "%0, 0,0,  0,  0,0,  0, 0,  0")
		 (match_operand:HI 2 "general_operand"      "rR>,Q,LMN,LMN,i,rR>,Q, rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("addhi3", insn, operands, 3);
    tms9900_inline_debug ("; addhi3, alt=%d\n", which_alternative);

    /* Either op[1] or op[2] may be a subreg with an offset. Correct them
     * first.  Worst case length for these alternatives are 8 and 10 bytes */

    if (tms9900_operand_subreg_offset (operands[2], HImode))
    {
      tms9900_inline_debug ("; addhi3, op[2] off %d\n", REG_OFFSET (operands[2]));
      if (!find_regno_note (insn, REG_DEAD, REGNO (operands[2])))
      {
        /* operands[2] has an offset but is not dead so we cannot change it.
         * Move to an intermediate and swap there.  Replace op[2] with
         * scratch reg R0 */
        output_asm_insn ("mov  %2,r0 ; addhi op2 to scratch", operands);
        output_asm_insn ("sra  r0,8 ; addhi extend op2", operands);
        operands[2] = gen_rtx_REG (HImode, HARD_R0_REGNUM);
      }
      else
      {
        /* operands[2] dies here so extend in place */
        output_asm_insn ("sra  %2,8 ; addhi extend op2", operands);
      }
    }

    /* check for subreg in operand[1].  If the source register is the same as
     * the original register, or the original is a not mem expression, then
     * the offset refers to the register, so correction is needed */
    if (tms9900_operand_subreg_offset (operands[1], HImode))
    {
      tms9900_inline_debug ("; addhi3, op[1] off %d\n", REG_OFFSET (operands[1]));
      output_asm_insn ("sra  %1,8 ; addhi extend op1", operands);
    }

    if (which_alternative == 2 || which_alternative == 3)
    {
      switch(INTVAL(operands[2]))
      {
      case 1:  return("inc  %0");
      case -1: return("dec  %0");
      case 2:  return("inct %0");
      case -2: return("dect %0");
      default: gcc_unreachable();
      }
    }
    else if (which_alternative == 4)
      return("ai   %0, %2");
    else
      return ("a    %2, %0");
  }
  "CONST_INT_P (operands[2]) && !REG_P (operands[0])"
  [(set (match_dup 0)
	(plus:HI (match_dup 1)
		 (match_dup 2)))]
  {
    tms9900_debug_operands ("split_addhi3", NULL_RTX, operands, 2);

    /*  Only force a constant if it is not a value we could use inc[t] or dec[t]
     *  instead. */
    if (INTVAL (operands[2]) < -2 && INTVAL (operands[2]) > 2)
        operands[2] = force_const_mem (HImode, operands[2]);
  }
  [(set_attr "length" "8,10,4,2,2,2,4,4,6")])


;;-------------------------------------
;; Add byte non immediate
;;
;; Immediates are not allowed here.  The expand will have replaced them with mem
;; consts
;;-------------------------------------
(define_insn "tms9900_addqi3"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
	(plus:QI (match_operand:QI 1 "nonimmediate_operand" "%0,0,0,0")
		 (match_operand:QI 2 "general_operand" "rR>,Q,rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("tms9900_addqi3", insn, operands, 3);
    return("ab   %2, %0");
  }
  [(set_attr "length" "2,4,4,6")])

;;-------------------------------------
;; Add byte
;;
;; Expand that ensures op0 == op1 and replaces an immediate op2 with a mem const
;;-------------------------------------
(define_expand "addqi3"
  [(set (match_operand:QI 0 "nonimmediate_operand" "")
	(plus:QI (match_operand:QI 1 "nonimmediate_operand" "")
		 (match_operand:QI 2 "general_operand" "")))]
  ""
  {
    tms9900_debug_operands ("addqi3", NULL_RTX, operands, 3);
    if (!rtx_equal_p (operands[0], operands[1]))
    {
      if (!rtx_equal_p (operands[0], operands[2]))
      {
        // We have 3 distinct operands.  Copy op1 to op0 and then proceed
        emit_move_insn (operands[0], operands[1]);
      }
      else
      {
        // op0 and op2 are the same but we need op0 and op1 to be the same so
        // swap 1 and 2
        rtx tmp = operands[1];
        operands[1] = operands[2];
        operands[2] = tmp;
      }
    }

    if (CONST_INT_P (operands[2]))
    {
      tms9900_inline_debug ("; addqi3 replace const with label\n");
      operands[2] = force_const_mem (QImode, operands[2]);
    }

    emit_insn (gen_tms9900_addqi3 (operands[0], operands[1], operands[2]));
    DONE;
  }
)

;;-------------------------------------------------------------------
;; Subtract
;;
;; See comment on addhi3
;;
;; Immediates are not allowed; they will be handled by negating the constant and
;; adding with addhi3
;;
;; As with addhi3, the first two constraints break out op0 as a register to
;; allow a more conservative length when subreg offset corrections are applied.
;;
;; NOTE: no @ on constraints for op1 as subtract is not commutative
;;-------------------------------------
(define_insn "subhi3"
  [(set (match_operand:HI 0 "nonimmediate_operand"           "=r, r,R>, R>,Q,  Q")
        (minus:HI (match_operand:HI 1 "nonimmediate_operand" "0,  0,0,  0, 0,  0")
                  (match_operand:HI 2 "nonimmediate_operand" "rR>,Q,rR>,Q, rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("subhi3", insn, operands, 3);
    tms9900_inline_debug ("; addhi3, alt=%d\n", which_alternative);

    /* Either op[1] or op[2] may be a subreg with an offset. Correct them
     * first.  Worst case length for these alternatives are 8 and 10 bytes */

    if (tms9900_operand_subreg_offset (operands[2], HImode))
    {
      tms9900_inline_debug ("; subhi3, op[2] off %d\n", REG_OFFSET (operands[2]));
      if (!find_regno_note (insn, REG_DEAD, REGNO (operands[2])))
      {
        /* operands[2] has an offset but is not dead so we cannot change it.
         * Move to an intermediate and swap there.  Replace op[2] with
         * scratch reg R0 */
        output_asm_insn ("mov  %2,r0 ; subhi op2 to scratch", operands);
        output_asm_insn ("sra  r0,8 ; subhi extend op2", operands);
        operands[2] = gen_rtx_REG (HImode, HARD_R0_REGNUM);
      }
      else
      {
        /* operands[2] dies here so extend in place */
        output_asm_insn ("sra  %2,8 ; subhi extend op2", operands);
      }
    }

    /* check for subreg in operand[1]. */
    if (tms9900_operand_subreg_offset (operands[1], HImode))
    {
      tms9900_inline_debug ("; subhi3, op[1] off %d\n", REG_OFFSET (operands[1]));
      output_asm_insn ("sra  %1,8 ; addhi extend op1", operands);
    }

    return "s    %2, %0";
  }
  [(set_attr "length" "8,10,2,4,4,6")])

;;-------------------------------------
;; Reverse subtract
;;
;; This case covers subtracting a register from an immediate by adding the
;; immediate and then negating the result.
;;
;; Reduces +/-1 and +/-2 to inc(t) or dec(t)
;;-------------------------------------

(define_insn "tms9900_rsubihi"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(minus:HI (match_operand:HI 1 "immediate_operand" "i")
		  (match_operand:HI 2 "register_operand" "0")))]
  ""
  {
    tms9900_debug_operands ("*rsubihi", insn, operands, 3);
    if (INTVAL(operands[1]) == -1)
      output_asm_insn("inc  %0",operands);
    else if (INTVAL(operands[1]) == 1)
      output_asm_insn("dec  %0",operands);
    else if (INTVAL(operands[1]) == -2)
      output_asm_insn("inct %0",operands);
    else if (INTVAL(operands[1]) == 2)
      output_asm_insn("dect %0",operands);
    else
    {
      operands[1] = GEN_INT(-INTVAL(operands[1]));
      output_asm_insn("ai   %0, %1",operands);
    }
    output_asm_insn("neg  %0",operands);
    return "";
  }
  [(set_attr "length" "6")])

;;-------------------------------------
;; op0 = op1 - op2(i)      movb op1,op0 
;;                         sb op2,op0
;; 
;; op0 = op1(i) - op2      movb op2,op0
;;                         neg op0
;;                         ab op1,op0
;; 
;; op0 = op0 - op2         sb op2,op0
;; 
;; op0 = op1 - op0         neg op0 
;;                         ab op1,op0
;; 
;;-------------------------------------
(define_insn "tms9900_subqi3"
  [(set (match_operand:QI 0 "nonimmediate_operand"           "=rR>,rR>,Q,  Q")
	(minus:QI (match_operand:QI 1 "nonimmediate_operand" "0,   0,  0,  0")
		  (match_operand:QI 2 "nonimmediate_operand" "rR>, Q,  rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("subqi3", NULL_RTX, operands, 3);
    #if 0
    if (!rtx_equal_p (operands[0], operands[1]))
    {
      if (!rtx_equal_p (operands[0], operands[2]))
      {
        // We have 3 distinct operands.  If one is a constant, copy the other to
        // op0
        // TODO this should be done in exapnd, but then how to output the neg?
        if (CONST_INT_P (operands[1]))
            output_asm_insn ("mov  %2, %0", operands);
        else
            output_asm_insn ("mov  %1, %0", operands);
      }
      else
      {
        // op0 and op2 are the same but we need op0 and op1 to be the same so
        // swap 1 and 2 and emit a neg
        rtx tmp = operands[1];
        operands[1] = operands[2];
        operands[2] = tmp;
        output_asm_insn ("neg  %0", operands);
      }
    }
    #endif

    output_asm_insn ("sb   %2, %0", operands);
    return "";
  }
  [(set_attr "length" "2")])

(define_expand "subqi3"
  [(set (match_operand:QI 0 "nonimmediate_operand"      "")
	(minus:QI (match_operand:QI 1 "general_operand" "")
		  (match_operand:QI 2 "general_operand" "")))]
  ""
  {
    tms9900_debug_operands ("subqi3", NULL_RTX, operands, 3);

    if (CONST_INT_P (operands[1]))
    {
      tms9900_inline_debug ("; subqi3 replace const with label\n");
      operands[1] = force_const_mem (QImode, operands[1]);
    }

    if (CONST_INT_P (operands[2]))
    {
      tms9900_inline_debug ("; subqi3 replace const with label\n");
      operands[2] = force_const_mem (QImode, operands[2]);
    }

    emit_insn (gen_tms9900_subqi (operands[0], operands[1], operands[2]));
    DONE;
  }
)

;;-------------------------------------------------------------------
;; Multiply
;;
;;-------------------------------------
; Expand for signed HI = QI x QI
; TODO check sign of highpart of HI
(define_expand "mulqihi3"
   [(set (match_operand:HI 0 "register_operand" "=r")
        (mult:HI (match_operand:QI 1 "register_operand" "r")
                 (match_operand:QI 2 "register_operand" "rRQ>")))]
  ""
  {
    tms9900_debug_operands ("mulqihi3", NULL_RTX, operands, 3);

    rtx result = gen_reg_rtx (SImode);
    rtx op1 = gen_reg_rtx (HImode);
    rtx op2 = gen_reg_rtx (HImode);
    emit_insn (gen_extendqihi2 (op1, operands[1]));
    emit_insn (gen_extendqihi2 (op2, operands[2]));
    emit_move_insn(gen_highpart (HImode, result), op1);
    emit_insn(gen_mulnative(result, result, op2));
    emit_move_insn (operands[0], gen_lowpart (HImode, result));
    DONE;
  }
)

;;-------------------------------------
; Expand for unsigned HI = QI x QI
;
(define_expand "umulqihi3"
   [(set (match_operand:HI 0 "register_operand" "=r")
        (mult:HI (match_operand:QI 1 "register_operand" "r")
                 (match_operand:QI 2 "register_operand" "rRQ>")))]
  ""
  {
    tms9900_debug_operands ("umulqihi3", NULL_RTX, operands, 3);

    rtx result = gen_reg_rtx (SImode);
    rtx op1 = gen_reg_rtx (HImode);
    rtx op2 = gen_reg_rtx (HImode);

    /* Extend expects both regs to be the same but passing two operands is legit
     * as it forces the compiler to copy them to one reg first */
    emit_insn (gen_zero_extendqihi2 (op1, operands[1]));
    emit_insn (gen_zero_extendqihi2 (op2, operands[2]));
    emit_move_insn(gen_highpart (HImode, result), op1);
    emit_insn(gen_mulnative(result, result, op2));
    emit_move_insn (operands[0], gen_lowpart (HImode, result));
    DONE;
  }
)

;;-------------------------------------
; Expand for signed SI = HI x HI
;
(define_expand "mulhisi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(mult:SI (zero_extend (match_operand:HI 1 "register_operand" "=r,r"))
		 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("mulqihi3", NULL_RTX, operands, 3);
    tms9900_inline_debug ("; mulhisi3 alt=%d\n", which_alternative);

    rtx result = gen_reg_rtx (SImode);
    emit_move_insn(gen_highpart (HImode, result), operands[1]);
    emit_insn(gen_mulnative(result, result, operands[2]));
    emit_move_insn (operands[0], result);
    DONE;
  }
)

;;-------------------------------------
; Expand for unsigned SI = HI x HI
;
(define_expand "umulhisi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(mult:SI (zero_extend (match_operand:HI 1 "register_operand" "=r,r"))
		 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("umulhisi3", NULL_RTX, operands, 3);
    tms9900_inline_debug ("; umulhisi3 alt=%d\n", which_alternative);

    rtx result = gen_reg_rtx (SImode);
    emit_move_insn(gen_highpart (HImode, result), operands[1]);
    emit_insn(gen_mulnative(result, result, operands[2]));
    emit_move_insn (operands[0], result);
    DONE;
  }
)

;;-------------------------------------
; expand HI=HIxHI to native SI=SIxHI

(define_expand "mulhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (mult:HI (match_operand:HI 1 "register_operand" "+0,0")
                 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("mulhi3", NULL_RTX, operands, 3);
    tms9900_inline_debug ("; mulhi3 alt=%d\n", which_alternative);

    rtx result = gen_reg_rtx (SImode);
    emit_move_insn(gen_highpart (HImode, result), operands[1]);
    emit_insn(gen_mulnative(result, result, operands[2]));
    emit_move_insn (operands[0], gen_lowpart (HImode, result));
    DONE;
   }
)

;;-------------------------------------
; This is the native multiplication on the tms9900.  SI=HIxHI
;  Note it is expected that op1 == op0 so we specify that op1 is SI.
;  All other variants, QIxQI, etc, should expand to this insn.
;  Also, mpy is unsigned so signed variants need to expand differently.
;  Signed vs unsigned makes no difference if operands and results are the same
;  size but will yield wrong results if result is wider than operands.

;  NOTE it does not appear subreg offsets are ever passed to this insn

(define_insn "mulnative"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(mult:SI (match_operand:SI 1 "register_operand" "0,0")
		 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("mulnative", insn, operands, 3);
    return ("mpy  %2, %0");
  }
  [(set_attr "length" "2,4")])

;;-------------------------------------
;; byte mul can only work in registers as we need to expand to HI mode

(define_expand "udivmodqi4"
  [(parallel [
     (set (match_operand:QI 0 "register_operand" "=r")
          (div:QI (match_operand:QI 1 "register_operand" "0")
                  (match_operand:QI 2 "register_operand" "r")))
     (set (match_operand:QI 3 "register_operand" "=r")
          (mod:QI (match_dup 1) 
                  (match_dup 2)))])]
  ""
  {
    tms9900_debug_operands ("udivmodqi4", NULL_RTX, operands, 4);

    /* Move and extend QI dividend to SI */
    rtx dividend = gen_reg_rtx (SImode);
    rtx scratch = gen_reg_rtx (HImode);
    emit_insn(gen_zero_extendqihi2 (scratch, operands[1]));
    emit_insn(gen_zero_extendhisi2 (dividend, scratch));

    /* Extend the divisor */
    rtx divisor = gen_reg_rtx (HImode);
    emit_insn(gen_zero_extendqihi2 (divisor, operands[2]));

    /* Do the division */
    emit_insn(gen_udivmodsihi3(dividend, dividend, divisor));

    /* Convert and store quotient from HI to QI */
    rtx quotient = gen_reg_rtx (HImode);
    emit_move_insn (quotient, gen_highpart (HImode, dividend));
    emit_insn(gen_trunchiqi2 (operands[0], quotient));

    /* Convert and store quotient from HI to QI */
    rtx remainder = gen_reg_rtx (HImode);
    emit_move_insn (remainder, gen_lowpart (HImode, dividend));
    emit_insn(gen_trunchiqi2 (operands[3], remainder));
    DONE;
  })

(define_expand "udivmodhi4"
  [(parallel [
     (set (match_operand:HI 0 "register_operand" "=r,r")
          (div:HI (match_operand:HI 1 "register_operand" "+0,0")
                  (match_operand:HI 2 "nonimmediate_operand" "+rR>,Q")))
     (set (match_operand:HI 3 "register_operand" "=r,r")
          (mod:HI (match_dup 1) 
                  (match_dup 2)))])]
  ""
  {
    tms9900_debug_operands ("udivmodhi4", NULL_RTX, operands, 4);
    tms9900_inline_debug ("; udivmodhi4 alt=%d\n", which_alternative);
    rtx dividend = gen_reg_rtx (SImode);
    rtx tmp = gen_reg_rtx (HImode);
    emit_move_insn(tmp, operands[1]);
    emit_insn(gen_zero_extendhisi2 (dividend, tmp));
    emit_insn(gen_udivmodsihi3(dividend, dividend, operands[2]));
    emit_move_insn (operands[0], gen_highpart (HImode, dividend));
    emit_move_insn (operands[3], gen_lowpart (HImode, dividend));
    DONE;
  })


;;-------------------------------------
;; Signed div/mod.  Native method is unsigned so record the sign of the result
;; by xor'ing operands together to examine highest bit.  Then take abs of operands.
;; Correct the sign of the quotient after the operation
(define_expand "divmodqi4"
  [(parallel [
     (set (match_operand:QI 0 "register_operand" "=r,r")
          (div:QI (match_operand:QI 1 "register_operand" "0,0")
                  (match_operand:QI 2 "nonimmediate_operand" "rR>,Q")))
     (set (match_operand:QI 3 "register_operand" "=r,r")
          (mod:QI (match_dup 1) 
                  (match_dup 2)))])]
  ""
  {
    tms9900_debug_operands ("divmodqi4", NULL_RTX, operands, 4);
    tms9900_inline_debug ("; divmodqi4 alt=%d\n", which_alternative);

    /* Find quotient sign */
    rtx sign = gen_reg_rtx (HImode); // sign of quotient
    emit_insn(gen_extendqihi2 (operands[1], sign));
    // emit_move_insn(sign, operands[1]);
    emit_insn(gen_extendqihi2 (operands[2], operands[2]));
    emit_insn(gen_xorhi3(sign, sign, operands[2]));

    /* Use temp for operand2 and get abs value */
    rtx divisor = gen_reg_rtx (HImode);
    emit_move_insn(divisor, operands[2]);
    emit_insn(gen_abshi2(divisor, divisor));

    /* Use temp for operand1, get absolute value and extend to SI.  We don't
     * have abssi2 so do abs on a tmp before extend  */
    rtx dividend = gen_reg_rtx (SImode);
    rtx tmp = gen_reg_rtx (HImode);
    emit_move_insn(tmp, operands[1]);
    emit_insn(gen_abshi2(tmp, tmp));
    emit_insn(gen_extendhisi2 (dividend, tmp));

    /* Perform division and modulus */
    emit_insn(gen_udivmodsihi3(dividend, dividend, divisor));

    /* Convert and store quotient from HI to QI */
    rtx quotient = gen_reg_rtx (HImode);
    emit_move_insn (quotient, gen_highpart (HImode, dividend));

    /* Correct sign of quotient */
    emit_insn(gen_divfixuphi2(quotient, sign));

    /* Convert and store quotient from HI to QI */
    emit_insn(gen_trunchiqi2 (operands[0], quotient));

    /* Convert and store remainder from HI to QI */
    rtx remainder = gen_reg_rtx (HImode);
    emit_move_insn (remainder, gen_lowpart (HImode, dividend));
    emit_insn(gen_trunchiqi2 (operands[3], remainder));

    DONE;
  }
)


(define_expand "divmodhi4"
  [(parallel [
     (set (match_operand:HI 0 "register_operand" "=r,r")
          (div:HI (match_operand:HI 1 "register_operand" "0,0")
                  (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))
     (set (match_operand:HI 3 "register_operand" "=r,r")
          (mod:HI (match_dup 1) 
                  (match_dup 2)))])]
  ""
  {
    tms9900_debug_operands ("divmodhi4", NULL_RTX, operands, 4);
    tms9900_inline_debug ("; divmodhi4 alt=%d\n", which_alternative);
    // rtx insn, div_equal, mod_equal, equal;

    /* Find quotient sign */
    rtx sign = gen_reg_rtx (HImode); // sign of quotient
    emit_move_insn(sign, operands[1]);
    emit_insn(gen_xorhi3(sign, sign, operands[2]));

    /* Use temp for operand2 and get abs value */
    rtx divisor = gen_reg_rtx (HImode);
    emit_move_insn(divisor, operands[2]);
    emit_insn(gen_abshi2(divisor, divisor));

    /* Use temp for operand1, get absolute value and extend to SI.  We don't
     * have abssi2 so do abs on a tmp before extend  */
    rtx dividend = gen_reg_rtx (SImode);
    rtx tmp = gen_reg_rtx (HImode);
    emit_move_insn(tmp, operands[1]);
    emit_insn(gen_abshi2(tmp, tmp));
    emit_insn(gen_extendhisi2 (dividend, tmp));

    /* Perform division and modulus */
    emit_insn(gen_udivmodsihi3(dividend, dividend, divisor));
    emit_move_insn (operands[0], gen_highpart (HImode, dividend));
    emit_move_insn (operands[3], gen_lowpart (HImode, dividend));

    /* Correct sign of quotient */
    emit_insn(gen_divfixuphi2(operands[0], sign));

    DONE;
  }
)


;;-------------------------------------------------------------------
;; Divide and Modulus
;; native method HI = SI / HI , HI = SI % HI
;;-------------------------------------
(define_insn "udivmodsihi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
        (ior:SI
          (ashift:SI
            (zero_extend:SI
              (div:HI (match_operand:SI 1 "register_operand" "0,0")
                      (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))
            (const_int 16))
          (zero_extend:SI 
            (mod:HI (match_dup 1)
                    (match_dup 2)))))]
  ""
  {
    tms9900_debug_operands ("udivmodsihi3", insn, operands, 3);
    output_asm_insn ("div  %2, %0", operands);
    return("");
  }
  [(set_attr "length" "2,4")])



(define_insn "divfixuphi2"
  [(set (match_operand:HI 1 "register_operand" "=r")
        (not:HI (match_dup 1)))
   (set (match_operand:HI 0 "register_operand" "=r")
        (if_then_else:HI (lt:HI (match_dup 1) (const_int 0))
           (neg:HI (match_dup 0)) (match_dup 0)))]
  ""
  {
    tms9900_debug_operands ("divfixuphi2", insn, operands, 2);
    output_asm_insn("inv  %1", operands);
    output_asm_insn("jlt  $+4", operands);
    output_asm_insn("neg  %0", operands);
    return("");
  }
  [(set_attr "length" "6")])


;;-------------------------------------------------------------------
;; Absolute Value
;;-------------------------------------
(define_insn "abshi2"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
	(abs:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))]
  ""
  {
    tms9900_debug_operands ("abshi2", insn, operands, 2);
    output_asm_insn ("abs  %0", operands);
    return("");
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------
;; register only as abs is 16-bit
(define_insn "absqi2"
  [(set (match_operand:QI 0 "register_operand" "=r")
	(abs:QI (match_operand:QI 1 "register_operand" "0")))]
  ""
  {
    tms9900_debug_operands ("absqi2", insn, operands, 2);
    output_asm_insn ("abs  %0", operands);
    return("");
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Negate
;;-------------------------------------
(define_insn "neghi2"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
	(neg:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))]
  ""
  {
    tms9900_debug_operands ("neghi2", insn, operands, 2);
    output_asm_insn("neg  %0", operands);
    return("");
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------
;; TODO andi only reqiured for strict
(define_insn "negqi2"
  [(set (match_operand:QI 0 "register_operand" "=r")
	(neg:QI (match_operand:QI 1 "register_operand" "0")))]
  ""
  {
    tms9900_debug_operands ("negqi2", insn, operands, 2);
    output_asm_insn("andi %0, 0xFF00", operands);
    output_asm_insn("neg  %0", operands);
    return("");
  }
  [(set_attr "length" "6")])


;;-------------------------------------------------------------------
;; Other Instructions
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; No-op
(define_insn "nop"
  [(const_int 0)]
  ""
  "nop"
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;;  Optimizations For Byte Compares
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X > N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (gtu (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 255)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (gtu (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  {
    tms9900_debug_operands ("peep-A", NULL_RTX, operands, 4);
  }
)

;; TODO assume this can be deleted
(define_insn "*cmpqi_as_hi"
  [(set (cc0)
      (compare (match_operand:QI 0 "register_operand" "r")
         (plus:HI (match_operand:HI 1 "const_int_operand" "i")
            (mult:HI (match_operand:HI 2 "const_int_operand" "i")
               (match_operand:HI 3 "const_int_operand" "i")))))]
  "INTVAL(operands[3]) == 256 && (INTVAL(operands[1]) == 0 || INTVAL(operands[1]) == 255)"
  {
    tms9900_debug_operands ("*cmpqi_as_hi", insn, operands, 3);
    operands[1] = GEN_INT(INTVAL(operands[2]) * 256 + INTVAL(operands[1]));
    return("ci   %0, %1");
  }
  [(set_attr "length" "4")])


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X < N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (ltu (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 0)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (ltu (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  {
    tms9900_debug_operands ("peep-cmpqi_lt_hi", NULL_RTX, operands, 4);
  }
)


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X >= N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (geu (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 0)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (geu (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  {
    tms9900_debug_operands ("peep-cmpqi_ge_hi", NULL_RTX, operands, 3);
  }
)


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X <= N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (leu (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 255)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (leu (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  {
    tms9900_debug_operands ("peep-cmpqi_le_hi", NULL_RTX, operands, 3);
  }
)


;;-------------------------------------------------------------------
;; Optimization for (char)X > N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (gt (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 255)
                          (mult:HI (match_dup 1)
                                  (const_int 256)))))
   (set (pc) (if_then_else (gt (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  {
    tms9900_debug_operands ("peep-cmpqi_gt_hi", NULL_RTX, operands, 3);
  }
)


;;-------------------------------------------------------------------
;; Optimization for (char)X < N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (lt (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 0)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (lt (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  {
    tms9900_debug_operands ("peep-cmpsqi_lt_hi", NULL_RTX, operands, 3);
  }
)


;;-------------------------------------------------------------------
;; Optimization for (char)X >= N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (ge (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 0)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (ge (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  {
    tms9900_debug_operands ("peep-cmpsqi_ge_hi", NULL_RTX, operands, 3);
  }
)


;;-------------------------------------------------------------------
;; Optimization for (char)X <= N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (le (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 255)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (le (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  {
    tms9900_debug_operands ("peep-cmpsqi_le_hi", NULL_RTX, operands, 3);
  }
)


;;-------------------------------------------------------------------
;;  Optimizations For Bit Shift And Cast
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Optimization for (char)X = (int X) >> N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashiftrt:HI (match_dup 0)
            (match_operand:HI 1 "const_int_operand" "i")))
   (set (match_operand:QI 2 "register_operand" "=r")
        (subreg:QI (match_dup 0) 1))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 0)
        (ashiftrt:HI (match_dup 0)
            (minus:HI (match_dup 1) 
                      (const_int 8))))]
  {
    tms9900_debug_operands ("peep-movqi_hi_sh", NULL_RTX, operands, 3);
  }
)

(define_insn "*ashiftrt_hi_to_qi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashiftrt:HI (match_dup 0)
            (minus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    tms9900_debug_operands ("*ashiftrt_hi_to_qi", insn, operands, 3);
    int shift = INTVAL (operands[1]);
    if(shift < 8)
    {
      operands[1] = GEN_INT(8 - shift);
      output_asm_insn("sla  %0, %1", operands);
    }
    else if(shift > 8)
    {
      operands[1] = GEN_INT(shift - 8);
      output_asm_insn("sra  %0, %1", operands);
    }
    return "";
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X = (unsigned int X) >> N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (lshiftrt:HI (match_dup 0)
            (match_operand:HI 1 "const_int_operand" "i")))
   (set (match_operand:QI 2 "register_operand" "=r")
        (subreg:QI (match_dup 0) 1))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 0)
        (lshiftrt:HI (match_dup 0)
            (minus:HI (match_dup 1) 
                      (const_int 8))))]
  {
    tms9900_debug_operands ("peep-movqi_uhi_sh", NULL_RTX, operands, 3);
  }
)


(define_insn "*lshiftrt_hi_to_qi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (lshiftrt:HI (match_dup 0)
            (minus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    tms9900_debug_operands ("*lshiftrt_hi_to_qi", insn, operands, 3);
    int shift = INTVAL (operands[1]);
    if(shift < 8)
    {
      operands[1] = GEN_INT(8 - shift);
      output_asm_insn("sla  %0, %1", operands);
    }
    else if(shift > 8)
    {
      operands[1] = GEN_INT(shift - 8);
      output_asm_insn("srl  %0, %1", operands);
    }
    return "";
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (char)X = (int X) << N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashift:HI (match_dup 0)
            (match_operand:HI 1 "const_int_operand" "i")))
   (set (match_operand:QI 2 "register_operand" "=r")
        (subreg:QI (match_dup 0) 1))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 0)
        (ashift:HI (match_dup 0)
            (plus:HI (match_dup 1) 
                      (const_int 8))))]
  {
    tms9900_debug_operands ("peep-movqi_hi_lsh", NULL_RTX, operands, 3);
  }
)


(define_insn "*ashift_hi_to_qi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashift:HI (match_dup 0)
            (plus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    tms9900_debug_operands ("*ashift_hi_to_qi", insn, operands, 3);
    operands[1] = GEN_INT(8 + INTVAL (operands[1]));
    output_asm_insn("sla  %0, %1", operands);
    return("");
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (int)X = (char X) >> N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (ashiftrt:QI (match_dup 0)
            (match_operand:HI 1 "const_int_operand" "i")))
   (set (match_operand:HI 2 "register_operand" "=r")
        (sign_extend:HI (match_dup 0)))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 2)
        (ashiftrt:HI (match_dup 2)
            (plus:HI (match_dup 1) 
                      (const_int 8))))]
  {
    tms9900_debug_operands ("peep-movhi_qi_rsh", NULL_RTX, operands, 3);
  }
)


(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
	(sign_extend:HI (match_operand:QI 1 "register_operand" "0")))
   (set (match_operand:HI 2 "register_operand" "=r")
        (ashiftrt:HI (match_dup 2)
            (match_operand:HI 3 "const_int_operand" "i")))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 2)
        (ashiftrt:HI (match_dup 2)
            (plus:HI (match_dup 3) 
                      (const_int 8))))]
  {
    tms9900_debug_operands ("peep-sign-ext", NULL_RTX, operands, 4);
  }
)


(define_insn "*ashiftrt_qi_to_hi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashiftrt:HI (match_dup 0)
            (plus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    tms9900_debug_operands ("*ashiftrt_qi_to_hi", insn, operands, 3);
    int shift = INTVAL (operands[1]) + 8;
    if(shift > 15) shift = 15;
    operands[1] = GEN_INT(shift);
    output_asm_insn("sra  %0, %1", operands);
    return("");
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (int)X = (unsigned char X) >> N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (lshiftrt:HI (match_operand:HI 1 "register_operand" "0")
            (match_operand:HI 2 "const_int_operand" "i")))
   (set (match_operand:HI 3 "register_operand" "=r")
        (and:HI (match_operand:HI 4 "const_int_operand" "2")
                (match_operand:HI 5 "const_int_operand" "i")))]
  "(REGNO(operands[0]) == REGNO(operands[3])) && (INTVAL(operands[5]) == (1<<(8-INTVAL(operands[2])))-1)"
  [(set (match_dup 0)
        (lshiftrt:HI (match_dup 0)
            (plus:HI (match_dup 2) 
                      (const_int 8))))]
  {
    tms9900_debug_operands ("peep-lsh-and", NULL_RTX, operands, 6);
  }
)


(define_insn "*lshiftrt_qi_to_hi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (lshiftrt:HI (match_dup 0)
            (plus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    tms9900_debug_operands ("*lshiftrt_qi_to_hi", insn, operands, 3);
    int shift = INTVAL (operands[1]) + 8;
    if(shift > 15) shift = 15;
    operands[1] = GEN_INT(shift);
    output_asm_insn("srl  %0, %1", operands);
    return("");
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (int)X = ((int)(char X)) << N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (sign_extend:HI (match_operand:QI 1 "register_operand" "0")))
   (set (match_operand:HI 3 "register_operand" "=r")
        (ashift:HI (match_operand:HI 4 "register_operand" "3")
                   (match_operand:HI 5 "const_int_operand" "i")))]
  "(REGNO(operands[0]) == REGNO(operands[3]))"
  [(set (match_dup 0)
        (ashiftrt:HI (const_int 8)
            (ashift:HI (match_dup 0) 
                       (match_dup 5))))]
  {
    tms9900_debug_operands ("peep-sign-ext-ash", NULL_RTX, operands, 6);
  }
)

(define_insn "*qi_hi_shift"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashiftrt:HI (match_operand:HI 1 "const_int_operand" "i")
            (ashift:HI (match_operand:HI 2 "register_operand" "0") 
                       (match_operand:HI 3 "const_int_operand" "i"))))]
  ""
  {
    tms9900_debug_operands ("*qi_hi_shift", insn, operands, 3);
    int shift = INTVAL(operands[3]);
    if(shift == 0) {
      output_asm_insn("swpb %0", operands);
      }
    else if(shift >= 1 && shift <= 7) { 
      operands[3] = GEN_INT(8-shift);
      output_asm_insn("sra  %0, %3", operands);
      }
    else if(shift >= 9 && shift <= 15) {
      operands[3] = GEN_INT(shift-8);
      output_asm_insn("sla  %0, %3", operands);
      }

    operands[3] = GEN_INT(0x00FF << shift);
    output_asm_insn("andi %0, %3", operands);
   
    return("");
  }
  [(set_attr "length" "6")])


;;-------------------------------------------------------------------
;; Optimization for (unsigned int)X = ((unsigned int)(unsigned char X)) << N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (zero_extend:HI (match_operand:QI 1 "register_operand" "0")))
   (set (match_operand:HI 3 "register_operand" "=r")
        (ashift:HI (match_operand:HI 4 "register_operand" "3")
                   (match_operand:HI 5 "const_int_operand" "i")))]
  "(REGNO(operands[0]) == REGNO(operands[3]))"
  [(set (match_dup 0)
        (lshiftrt:HI (const_int 8)
            (ashift:HI (match_dup 0) 
                       (match_dup 5))))]
  {
    tms9900_debug_operands ("peep-zero-ext-ash", NULL_RTX, operands, 6);
  }
)


(define_insn "*unsigned_qi_hi_shift"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (lshiftrt:HI (match_operand:HI 1 "const_int_operand" "i")
            (ashift:HI (match_operand:HI 2 "register_operand" "0") 
                       (match_operand:HI 3 "const_int_operand" "i"))))]
  ""
  {
    tms9900_debug_operands ("*unsigned_qi_hi_shift", insn, operands, 3);
    int shift = INTVAL(operands[3]);
    if(shift >= 0 && shift <= 7) { 
      operands[3] = GEN_INT(8-shift);
      output_asm_insn("srl  %0, %3", operands);
      }
    else if(shift >= 9 && shift <= 15) {
      operands[3] = GEN_INT(shift-8);
      output_asm_insn("sla  %0, %3", operands);
      }

    operands[3] = GEN_INT(0xFFFF << shift);
    output_asm_insn("andi %0, %3", operands);
   
    return("");
  }
  [(set_attr "length" "6")])


;;-------------------------------------------------------------------
;; Optimization for (unsigned long)X = (unsigned long Y) >> 16
;;   Original code:
;;     mov  r3, r6
;;     mov  r4, r7
;;     mov  r6, r7
;;     clr  r6
;;
;;   Optimized:
;;     mov r3, r7
;;     clr r6
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (match_operand:HI 1 "register_operand" "r"))
   (set (match_operand:HI 2 "register_operand" "=r")
        (match_operand:HI 3 "register_operand" "r"))
   (parallel[
    (clobber (match_operand:HI 4 "register_operand" "r"))
    (set (match_operand:SI 5 "register_operand" "=r")
         (lshiftrt:SI (match_operand:SI 6 "register_operand" "5")
                      (match_operand:HI 7 "const_int_operand" "i")))
   ])]
  "((REGNO(operands[0]) == REGNO(operands[5])) &&
    (REGNO(operands[2]) == (REGNO(operands[0])+1)) &&
    (INTVAL(operands[7]) == 16)
   )"
  [(set (match_dup 2) (match_dup 1))
   (set (match_dup 0) (const_int 0))]
  {
    tms9900_debug_operands ("peep-mov-squash", NULL_RTX, operands, 8);
  }
)


(define_insn "*set_consthi2"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (match_operand:HI 1 "const_int_operand" "i"))]
  ""
  {
    tms9900_debug_operands ("*set_consthi2", insn, operands, 3);
    if(INTVAL(operands[1]) == 0) {
      output_asm_insn("clr  %0", operands);
    } else if((INTVAL(operands[1]) & 0xFFFF) == 0xFFFF) {
      output_asm_insn("seto  %0", operands);
    } else {
      output_asm_insn("li   %0, %1", operands);
    }
    return("");
  }
  [(set_attr "length" "4")])


;;-------------------------------------------------------------------
;; Optimization for X = Y << 16
;;   Original code:
;;     mov  r4, r6
;;     mov  r5, r7
;;     mov  r7, r6
;;     clr  r7
;;
;;   Optimized:
;;     mov r5, r6
;;     clr r7
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (match_operand:HI 1 "register_operand" "r"))
   (set (match_operand:HI 2 "register_operand" "=r")
        (match_operand:HI 3 "register_operand" "r"))
   (parallel[
    (clobber (match_operand:HI 4 "register_operand" "r"))
    (set (match_operand:SI 5 "register_operand" "=r")
         (ashift:SI (match_operand:SI 6 "register_operand" "5")
                      (match_operand:HI 7 "const_int_operand" "i")))
   ])]
  "((REGNO(operands[0]) == REGNO(operands[5])) &&
    (REGNO(operands[2]) == (REGNO(operands[0])+1)) &&
    (INTVAL(operands[7]) == 16)
   )"
  [(set (match_dup 0) (match_dup 3))
   (set (match_dup 2) (const_int 0))]
  {
    tms9900_debug_operands ("peep-movsi-squash", NULL_RTX, operands, 8);
  }
)


;-------------------------------------------------------------------
;; Optimization for byte array initializations
; This handles sequences like:
;   li   r1, >1200
;   movb r1, *r2
;   li   r1, >3400
;   movb r1, @1(r2)
;
; and converts to:
;   li   r1, >1234
;   movb r1, *r2
;   swpb r1
;   movb r1, @1(r2)
;
; This saves two bytes and is slightly faster
(define_peephole2
  [(match_scratch:HI 6 "r,r")
   (set (match_operand:QI 0 "register_operand" "=r,r")
        (match_operand:QI 1 "const_int_operand" "i,i"))
   (set (match_operand:QI 2 "nonimmediate_operand" "=R>,Q")
        (match_dup 0))
   (set (match_operand:QI 3 "register_operand" "=r,r")
        (match_operand:QI 4 "const_int_operand" "i,i"))
   (set (match_operand:QI 5 "nonimmediate_operand" "=R>,Q")
        (match_dup 3))]
  "peep2_reg_dead_p(4, operands[0]) && peep2_reg_dead_p(4, operands[3])"
  [(set (match_dup 6)
        (ior:HI (ashift:HI (match_dup 1) 
                     (const_int 8))
             (match_dup 4)))
   (set (match_dup 2)
        (subreg:QI (ashiftrt:HI (match_dup 6) (const_int 8)) 1))
   (set (match_dup 5)
        (subreg:QI (ashiftrt:HI (match_dup 6) (const_int 0)) 1))]
  {
    tms9900_debug_operands ("peep-hi-swpb-mov", NULL_RTX, operands, 6);
  }
)


(define_insn "*movhi_combine_consts"
  [(set (match_operand:HI 0 "register_operand" "")
        (ior:HI (ashift:HI (match_operand:QI 1 "const_int_operand" "")
                           (match_operand:QI 2 "const_int_operand" ""))
                (match_operand:QI 3 "const_int_operand" "")))]
  ""
  {
    tms9900_debug_operands ("*movhi_combine_consts", insn, operands, 3);
    operands[1] = GEN_INT(((INTVAL(operands[1]) & 0xFF) << 8) |
                           (INTVAL(operands[3]) & 0xFF));
    return "li   %0, %1";
  }
  [(set_attr "length" "4")])


;; TODO will this help the case where char c = (int) x >> 8; ??

(define_insn "*movqi_for_initializer"
  [(set (match_operand:QI 0 "memory_operand" "=rR>,Q")
        (subreg:QI (ashiftrt:HI (match_operand:HI 1 "register_operand" "r,r")
                              (match_operand:HI 2 "const_int_operand" "i,i")) 1))]
  ""
  {
    tms9900_debug_operands ("*movqi_for_initializer", insn, operands, 3);
    if(INTVAL(operands[2]) == 8)
    {
      output_asm_insn("movb %1, %0", operands);
    }
    else if(INTVAL(operands[2]) == 0)
    {
      output_asm_insn("swpb %1", operands);
      output_asm_insn("movb %1, %0", operands);
    }
   return("");
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------------------------------------
;; Optimization for memory-to-memory copies
;; Combine a mem-reg-mem copy into a mem-mem copy
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
        (match_operand:HI 1 "memory_operand" ""))
   (set (match_operand:HI 2 "memory_operand" "")
        (match_dup 0))]
  "peep2_reg_dead_p(2, operands[0])"
  [(set (match_operand:HI 2 "memory_operand" "")
        (match_operand:HI 1 "memory_operand" ""))]
  {
    tms9900_debug_operands ("peep-mov-mem-mem", NULL_RTX, operands, 3);
  }
)

   
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "memory_operand" ""))
   (set (match_operand:QI 2 "memory_operand" "")
        (match_dup 0))]
  "peep2_reg_dead_p(2, operands[0])"
  [(set (match_operand:QI 2 "memory_operand" "")
        (match_operand:QI 1 "memory_operand" ""))]
  {
    tms9900_debug_operands ("peep-movqi-mem-mem", NULL_RTX, operands, 3);
  }
)


(define_insn "*andi_const"
  [(set (match_operand:HI 0 "register_operand" "")
        (and:HI (match_dup 0)
                (match_operand:HI 1 "const_int_operand" "")))]
  ""
  {
    tms9900_debug_operands ("*andi_const", insn, operands, 3);
    int val = INTVAL(operands[1]) & 0xFFFF;
    if(val == 0)
      return "clr  %0";
    else if(val == 0xFFFF)
      return "";
    else
      return "andi %0, %1";
  }
  [(set_attr "length" "4")])

