;;- Machine description for the TMS9900 for GNU C compiler
;; Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2004, 2005
;; 2007, 2008 Free Software Foundation, Inc.

;; Copyright 2009 Eric Welser (EMW)
;; Copyright 2023 Mark Burkley (MGB)

;; This file is part of GCC.

;; GCC is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.

;; GCC is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GCC; see the file COPYING3.  If not see
;; <http://www.gnu.org/licenses/>.

;; SI is 32 bit
;; HI is 16 bit
;; QI is 8 bit 

;; MGB NOTES
;;    - rtx notation is insn(dst,src) but tms asm notation is <op> src,dst so
;;      beware of operand ordering
;;    - all byte (QI) ops need to have expands to cater for the fact that in
;;      TMS9900 a 16-bit operation can't be done on a reg that contains an 8-bit value
;;      unless it has been shifted by 8
;;    - Many byte insns are restricted to registers only as TMS9900 doesn't have
;;      byte version of abs, neg, etc.
;;    - Insns like exend, trunc, abs, etc, are done in place but passed two
;;      distinct params.  This is ok, the compiler is forced to move src and dst to the
;;      same reg by the "0" constraint.
;;    - optimiser doesn't understand opcodes, just insns.  So keep insns as
;;      short as possible.  One opcode preferable, two max.  Any more, use an expand instead
;;    - I'm avoiding clobbers in expands and declaring temp rtx regs inside code
;;      instead.  Also using r0 as a scratch reg since it cannot be used as a general
;;      reg.
;;    - 32-bit arith insns have been moved to C code.  Emitting lengthy opcode
;;      sequences shouldn't be part of a md file.

;; Description of class IDs
;;   'L' is for 2 or -2
;;   'M' is for -1
;;   'N' is for 1
;;   'O' is for 0
;;   'Q' is for memory references that need an extra word after the opcode.
;;   'R' is for memory references which are encoded within the opcode.

;;- See file "rtl.def" for documentation on define_insn, match_*, et. al.

;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code
;;- updates for most instructions.

;;- Operand classes for the register allocator:

;; Compare instructions.


;; define attributes
;; currently type is only fpu or arith or unknown, maybe branch later ?
;; default is arith
(define_attr "type" "unknown,arith,fp" (const_string "arith"))

;; length default is 1 words each
(define_attr "length" "" (const_int 2))

;; a user's asm statement
(define_asm_attributes
  [(set_attr "type" "unknown")
; all bets are off how long it is - make it 256, forces long jumps 
; whenever jumping around it !!!
   (set_attr "length" "256")])

;;-------------------------------------------------------------------
;;  UNSPEC Definitions
;;-------------------------------------------------------------------
(define_constants
  [(UNSPEC_RETURN  0)])


;;-------------------------------------------------------------------
;;  Predicate Definitions
;;-------------------------------------------------------------------

;;-------------------------------------------------------------------
;;  Function Calls
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Jump to a subroutine which returns a value
(define_insn "call"
  [(call (match_operand:HI 0 "general_operand" "rR,Q")
         (match_operand:HI 1 "general_operand"  "g,g"))
  ]
  ""
  {
    tms9900_debug_operands ("call", insn, operands, 2);
    if(SIBLING_CALL_P(insn))
      output_asm_insn("b    %0 ; tail call", operands);
    else
      output_asm_insn("bl   %0", operands);
    return("");
  }
  [(set_attr "length" "2,4")]
)


;-------------------------------------------------------------------
; Jump to a subroutine which returns a value
(define_insn "call_value"
  [(set (match_operand 0 "" "")
        (call (match_operand:HI 1 "general_operand" "rR,Q")
	      (match_operand:HI 2 "general_operand" "g,g")))
  ]
  ""
  {
    tms9900_debug_operands ("call_value", insn, operands, 3);
    if(SIBLING_CALL_P(insn))
      output_asm_insn("b    %1 ; tail call", operands);
    else
      output_asm_insn("bl   %1", operands);
    return("");
  }
  [(set_attr "length" "2,4")]
)

;; The O2 and O3 optimise options replace BL @xxx with LI Ry,xxx and BL *Ry
;; when the BL is inside a loop, even though the LI is also inside the loop,
;; which makes it less efficient.  This peephole undoes this "optimisation"

; There is an issue with this when the register used to hold the jump address
; gets spilled to the stack.  The resulting attempt to do call @6[sp] fails of
; course.  Popping from stack needs to go through a reg.  But why spill a label
; address to stack?  That makes no sense.

; (define_peephole2
;   [(set (match_operand:HI 0 "general_operand" "")
; 	(match_operand:HI 1 "general_operand" ""))
;    (set (match_operand:HI 2 "general_operand" "")
; 	(call (mem:HI (match_dup 0))
;               (match_operand:HI 3 "general_operand" "")))]
;   ""
;   [(set (match_dup 2)
;         (call (mem:HI (match_dup 1))
;               (match_dup 3)))]
;   "")



;;-------------------------------------------------------------------
;; Define function prologue
(define_expand "prologue"
  [(const_int 0)]
  ""
{
  tms9900_debug_operands ("prologue", NULL_RTX, NULL, 0);
  tms9900_expand_prologue();
  DONE;
})


;;-------------------------------------------------------------------
;; Define function epilogue
(define_expand "epilogue"
  [(return)]
  ""
{
  tms9900_debug_operands ("epilogue", NULL_RTX, NULL, 0);
  tms9900_expand_epilogue(false);
  DONE;
})

(define_expand "sibcall_epilogue"
  [(return)]
  ""
{
  tms9900_debug_operands ("sibcall_epilogue", NULL_RTX, NULL, 0);
  tms9900_expand_epilogue(true);
  DONE;
})


;;-------------------------------------------------------------------
;; Define function return
(define_insn "*rt"
  [(unspec [(match_operand:HI 0 "general_operand" "")] UNSPEC_RETURN)]
  ""
  {
    tms9900_debug_operands ("*rt", insn, operands, 1);
    return("b    *r11");
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;;  Comparison Instructions
;;-------------------------------------------------------------------

;; cmp to zero is done explicitly or implicitly so can just do a mov to self to
;; compare.  BUT if self is a ROM target then that could invoke unintended side
;; effects like bank switching, so mov to temp reg r0 instead.  This also saves
;; 2 bytes for mem label compares.

;;-------------------------------------
(define_insn "tsthi"
  [(set (cc0)
	(match_operand:HI 0 "nonimmediate_operand" "rR,Q"))]
  ""
  {
    tms9900_debug_operands ("tsthi", insn, operands, 1);
    return("mov  %0, r0");
  }
  [(set_attr "length" "2,6")])


;;-------------------------------------
(define_insn "tstqi"
  [(set (cc0)
	(match_operand:QI 0 "nonimmediate_operand" "rR,Q"))]
  ""
  {
    tms9900_debug_operands ("tstqi", insn, operands, 1);
    return("movb %0, r0");
  }
  [(set_attr "length" "2,6")])
 
;;-------------------------------------
(define_insn "cmphi"
  [(set (cc0)
	(compare (match_operand:HI 0 "nonimmediate_operand" "rR,rR,Q,Q,r")
		 (match_operand:HI 1 "general_operand"      "rR,Q,rR,Q,i")))]
  ""
  {
    tms9900_debug_operands ("cmphi", insn, operands, 2);
    if (which_alternative == 4)
    {
       return("ci   %0, %1");
    }
    else
    {
      return("c    %0, %1");
    }
  }
  [(set_attr "length" "2,4,4,6,4")])


;;-------------------------------------
;
; Replace:
;   mov r1,@x 
;   cmp r2, r1
;
; With:
;   cmp r2,@x

(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
	(match_operand:HI 1 "memory_operand" ""))
   (set (cc0)
        (compare (match_operand:HI 2 "register_operand" "")
                 (match_dup 0)))]
  ""
  [(set (cc0) 
        (compare (match_dup 2)
                 (match_dup 1)))]
  "")

;;-------------------------------------
;
; Use r0 as a temp to hold an immediate and then do a compare byte
;
; NOTE - for cmpqi and movqi the immediate constraint is 'n' not 'i' as it must
;        be a const-int not a label
;
(define_insn "cmpqi"
  [(set (cc0)
	(compare (match_operand:QI 0 "nonimmediate_operand" "rR>,Q,  rR>,Q,r")
		 (match_operand:QI 1 "general_operand"  "rR>,rR>,Q,  Q,n")))]
  ""
  {
    tms9900_debug_operands ("cmpqi", insn, operands, 2);
    if (which_alternative == 4)
    {
      int val = INTVAL(operands[1]) & 0xFF;
      if (val == 0xFF)
      {
        output_asm_insn("seto r0",  operands);
      }
      else
      {
        operands[1] = GEN_INT(val<<8);
        output_asm_insn("li   r0, %1",  operands);
      }
      output_asm_insn("cb   %0, r0",  operands);
    }
    else
      output_asm_insn("cb   %0, %1",  operands);

    return("");
  }
  [(set_attr "length" "2,4,4,6,8")])

;;-------------------------------------------------------------------
;;  Move Operations
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Move byte value
(define_insn "movqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,  Q,r, r")
        (match_operand:QI 1 "general_operand"      "rR>, Q,  rR>,Q,OM,n"))]
  ""
  {
    tms9900_debug_operands ("movqi", insn, operands, 2);
    tms9900_inline_debug ("; movqi alt=%d\n", which_alternative);
    int val;
    if (which_alternative >= 4)
    {
      val = INTVAL(operands[1]) & 0xff;
      tms9900_inline_debug ("; movqi imm MUL const %d * 256\n", val);

      if (val == 0)
        return("clr  %0");
      else if (val == 0xff)
        return("seto %0");
      else
      {
        operands[1] = GEN_INT(val<<8);
        return ("li   %0, %1");
      }
    }
    else
    {
      bool postByteSwap = tms9900_correct_byte_order (insn, operands);

      output_asm_insn ("movb %1, %0", operands);

      if (postByteSwap)
        output_asm_insn ("swpb %0 ; movqi byte correct", operands);

      return "";
    }
  }
  [(set_attr "length" "2,4,4,6,2,4")])

;;-------------------------------------------------------------------
;; Move two-byte value
;;
;; Constraints O and M are listed as separate alternatives to allow SETO or CLR
;; to be used which would have a different length to LI.  SETO and CLR can also
;; work with R and Q.

(define_insn "movhi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,  Q,rR>,Q, r")
        (match_operand:HI 1 "general_operand"      "rR>, Q,  rR>,Q,OM, OM,i"))]
  ""
  {
    tms9900_debug_operands ("movhi", insn, operands, 2);
    tms9900_inline_debug ("; movhi alt=%d\n", which_alternative);

    if (which_alternative == 4 || which_alternative == 5)
    {
      if (!CONST_INT_P (operands[1]))
        gcc_unreachable();

      int val = INTVAL(operands[1]) & 0xffff;

      if (val == 0)
        return("clr  %0");
      else if (val == 0xffff)
        return("seto %0");

      gcc_unreachable();
    }
    else if (which_alternative == 6)
    {
      return("li   %0, %1");
    }
    else
    {
      return("mov  %1, %0");
    }
  }
  [(set_attr "length" "2,4,4,6,2,4,4")])

;;-------------------------------------------------------------------
;; Move four-byte value as two 2-byte regs.  If immediate, emit two movhi insns
;; with high and low part of constants.  Constraints O and M are allowed so we
;; can issue seto or clr for -1 and 0 respectively
;;
;; Changed this from an expand back to an insn
;;-------------------------------------------------------------------
(define_insn "movsi"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR>,rR>,Q,  Q,r, r")
	(match_operand:SI 1 "general_operand"      "rR>, Q,  rR>,Q,OM,n"))]
  ""
  {
    tms9900_debug_operands ("movsi", insn, operands, 2);
    tms9900_inline_debug ("; movsi alt=%d\n", which_alternative);

    rtx args[4];
    args[0] = gen_highpart (HImode, operands[0]);
    args[1] = gen_lowpart (HImode, operands[0]);

    if (which_alternative >= 4)
    {
      if (!CONST_INT_P (operands[1]))
        gcc_unreachable();

      args[2] = gen_rtx_CONST_INT (HImode, ((UINTVAL(operands[1])&0xffff0000)>>16));
      args[3] = gen_rtx_CONST_INT (HImode, (UINTVAL(operands[1])&0xffff));
      tms9900_inline_debug ("; movsi op1=%08X hi=%04X lo=%04X\n",
                            INTVAL (operands[1]),
                            INTVAL (args[2]),
                            INTVAL (args[3]));

      if (INTVAL(args[2]) == 0xffff)
        output_asm_insn("seto %0", args);
      else if (INTVAL(args[2]) == 0)
        output_asm_insn("clr  %0", args);
      else
        output_asm_insn("li   %0, %2", args);

      if (INTVAL(args[3]) == 0xffff)
        output_asm_insn("seto %1", args);
      else if (INTVAL(args[3]) == 0)
        output_asm_insn("clr  %1", args);
      else
        output_asm_insn("li   %1, %3", args);
    }
    else
    {
      args[2] = gen_highpart (HImode, operands[1]);
      args[3] = gen_lowpart (HImode, operands[1]);
      output_asm_insn("mov  %2, %0", args);
      output_asm_insn("mov  %3, %1", args);
    }
    return("");
  }
  [(set_attr "length" "4,8,8,12,4,8")])

;;-------------------------------------------------------------------
;; Type Conversions
;;-------------------------------------------------------------------

(define_insn "*zero_extendqihi2_subreg"
  [(set (match_operand:HI 0 "register_operand" "=r,r,r")
	(zero_extend:HI (subreg:HI (match_operand:QI 1 "nonimmediate_operand" "0,R,Q") 0)))]
  ""
  {
    tms9900_debug_operands ("zero_extendqihi2_subreg", insn, operands, 2);

    if (which_alternative > 0)
    {
      output_asm_insn ("movb %1, %0", operands);
    }
    output_asm_insn ("srl  %0, 8", operands);
    return("");
  }
  [(set_attr "length" "2,4,6")])

;;-------------------------------------------------------------------
;; Zero Extend
;; If op1 is not a register, we need to mov the value to op0 first.  As a
;; result, R and Q constraints are different length to r.
;;-------------------------------------

(define_insn "zero_extendqihi2"
  [(set (match_operand:HI 0 "register_operand" "=r,r,r")
	(zero_extend:HI (match_operand:QI 1 "nonimmediate_operand" "0,R,Q")))]
  ""
  {
    tms9900_debug_operands ("zero_extendqihi2", insn, operands, 2);

    if (which_alternative > 0)
    {
      output_asm_insn ("movb %1, %0", operands);
    }
    output_asm_insn ("srl  %0, 8", operands);
    return("");
  }
  [(set_attr "length" "2,4,6")])

;;-------------------------------------
; TODO Could do a gen_lowpart into op0 to prevent the tmp
(define_expand "zero_extendqisi2"
  [(set (match_operand:SI 0 "register_operand" "")
	(zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "")))]
  ""
  {
    tms9900_debug_operands ("zero_extendqisi2", NULL_RTX, operands, 2);
    rtx tmp = gen_reg_rtx (HImode);
    emit_insn (gen_zero_extendqihi2 (tmp, operands[1]));
    emit_insn (gen_zero_extendhisi2 (operands[0], tmp));
    DONE;
  }
)

(define_insn "zero_extendhisi2"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR,Q")
	(zero_extend:SI (match_operand:HI 1 "general_operand" "g,g")))]
  ""
  {
    tms9900_debug_operands ("zero_extendhisi2", insn, operands, 2);
    rtx args[3];
    args[0] = gen_highpart (HImode, operands[0]);
    args[1] = gen_lowpart (HImode, operands[0]);
    args[2] = operands[1];

    output_asm_insn("mov  %2, %1", args);
    output_asm_insn("clr  %0", args);
    return("");
  }
  [(set_attr "length" "4,8")])


;;-------------------------------------------------------------------
;; Sign Extend
;;-------------------------------------------------------------------

(define_insn "extendqihi2"
  [(set (match_operand:HI 0 "register_operand" "=r,r,r")
	(sign_extend:HI (match_operand:QI 1 "nonimmediate_operand" "0,R,Q")))]
  ""
  {
    tms9900_debug_operands ("extendqihi2", insn, operands, 2);
    if (which_alternative > 0)
    {
      output_asm_insn ("movb %1, %0", operands);
    }
    output_asm_insn("sra  %0, 8", operands);
    return("");
  }
  [(set_attr "length" "2,4,6")])
			 

(define_expand "extendqisi2"
  [(set (match_operand:SI 0 "register_operand" "")
	(sign_extend:SI (match_operand:QI 1 "nonimmediate_operand" "")))]
  ""
  {
    tms9900_debug_operands ("extendqisi2", NULL_RTX, operands, 2);
    rtx tmp = gen_reg_rtx (HImode);
    emit_insn (gen_extendqihi2 (tmp, operands[1]));
    emit_insn (gen_extendhisi2 (operands[0], tmp));
    DONE;
  }
)

;;-------------------------------------
(define_insn "extendhisi2"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR,Q")
	(sign_extend:SI (match_operand:HI 1 "general_operand" "g,g")))]
  ""
  {
    tms9900_debug_operands ("extendhisi2", insn, operands, 2);
    rtx args[3];
    rtx offset[1];
    args[0] = gen_highpart (HImode, operands[0]);
    args[1] = gen_lowpart (HImode, operands[0]);
    args[2] = operands[1];

    if(which_alternative == 1)
      offset[0] = GEN_INT(6);
    else
      offset[0] = GEN_INT(4);

    output_asm_insn("mov  %2, %1", args);
    /* sign extend.  If highpart is negative, seto, else clr.  This is slightly
     * cheaper (either 20 or 30 cycles) than doing sra 16 (44 cycles) */
    output_asm_insn("seto %0", args);
    output_asm_insn("jlt  $+%0", offset);
    output_asm_insn("clr  %0", args);
    return("");
  }
  [(set_attr "length" "8,12")])

;;-------------------------------------------------------------------
;; Truncate
;
;  swpb will suffice for non-strict in place truncation.  There is no strict variant of
;  truncate so I am assuming we doesn't care about unused bits.
;;-------------------------------------

(define_insn "trunchiqi2"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,Q")
	(truncate:QI (match_operand:HI 1 "nonimmediate_operand" "0,0")))]
  ""
  {
    tms9900_debug_operands ("trunchiqi2", insn, operands, 2);
    return ("swpb %0");
  }
  [(set_attr "length" "2,4")])

(define_insn "truncsihi2"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
	(truncate:HI (match_operand:SI 1 "nonimmediate_operand" "rR>,Q,rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("truncsihi2", insn, operands, 2);
    operands[1] = gen_lowpart (HImode, operands[1]);
    return "mov  %1, %0";
  }
  [(set_attr "length" "2,4,4,6")])

(define_expand "truncsiqi2"
  [(set (match_operand:QI 0 "nonimmediate_operand" "")
	(truncate:QI (match_operand:SI 1 "nonimmediate_operand" "")))]
  ""
  {
    tms9900_debug_operands ("truncsiqi2", NULL_RTX, operands, 2);
    emit_insn (gen_truncsihi2 (operands[0], operands[0]));
    emit_insn (gen_trunchiqi2 (operands[0], operands[0]));
    DONE;
  }
)

;;-------------------------------------------------------------------
;;  Branch Instructions
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Jump if equal
(define_insn "beq"
  [(set (pc)
	(if_then_else (eq (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  {
    tms9900_debug_operands ("beq", insn, operands, 1);
    return(output_branch("jeq", "jne", get_attr_length(insn)));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if equal, reversed comparison operands
(define_insn "*beq_reversed"
  [(set (pc)
	(if_then_else (eq (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  {
    tms9900_debug_operands ("*beq_reversed", insn, operands, 1);
    return(output_branch("jne", "jeq", get_attr_length(insn)));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if not equal
(define_insn "bne"
  [(set (pc)
	(if_then_else (ne (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  {
    tms9900_debug_operands ("bne", insn, operands, 1);
    return output_branch(\"jne\", \"jeq\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if not equal, reversed comparison operands
(define_insn "*bne_reversed"
  [(set (pc)
	(if_then_else (ne (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  {
    tms9900_debug_operands ("*bne_reversed", insn, operands, 1);
    return output_branch(\"jeq\", \"jne\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if unsigned less than
(define_insn "bltu"
  [(set (pc)
	(if_then_else (ltu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  {
    tms9900_debug_operands ("bltu", insn, operands, 1);
    return output_branch(\"jl\", \"jhe\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if unsigned less than, reversed comparison operands
(define_insn "*bltu_reversed"
  [(set (pc)
	(if_then_else (ltu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  {
    tms9900_debug_operands ("*bltu_reversed", insn, operands, 1);
    return output_branch(\"jhe\", \"jl\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if unsigned less than or equal
(define_insn "bleu"
  [(set (pc)
	(if_then_else (leu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  {
    tms9900_debug_operands ("bleu", insn, operands, 1);
    return output_branch(\"jle\", \"jh\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if unsigned less than or equal, reversed comparison operands
(define_insn "*bleu_reversed"
  [(set (pc)
	(if_then_else (leu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  {
    tms9900_debug_operands ("*bleu_reversed", insn, operands, 1);
    return output_branch(\"jh\", \"jle\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if unsigned greater than
(define_insn "bgtu"
  [(set (pc)
	(if_then_else (gtu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  {
    tms9900_debug_operands ("bgtu", insn, operands, 1);
    return output_branch(\"jh\", \"jle\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if unsigned greater than, reversed comparison operands
(define_insn "*bgtu_reversed"
  [(set (pc)
	(if_then_else (gtu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  {
    tms9900_debug_operands ("*bgtu_reversed", insn, operands, 1);
    return output_branch(\"jle\", \"jh\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if unsigned greater than or equal
(define_insn "bgeu"
  [(set (pc)
	(if_then_else (geu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  {
    tms9900_debug_operands ("bgeu", insn, operands, 1);
    return output_branch(\"jhe\", \"jl\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if unsigned greater than or equal, reversed comparison operands
(define_insn "*bgeu_reversed"
  [(set (pc)
	(if_then_else (geu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  {
    tms9900_debug_operands ("*bgeu_reversed", insn, operands, 1);
    return output_branch(\"jl\", \"jhe\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if less than
(define_insn "blt"
  [(set (pc)
	(if_then_else (lt (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  {
    tms9900_debug_operands ("blt", insn, operands, 1);
    return output_branch(\"jlt\", \"GE\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 18)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if less than, reversed comparison operands
; Was commented out
(define_insn "*blt_reversed"
  [(set (pc)
	(if_then_else (lt (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  {
    tms9900_debug_operands ("*blt_reversed", insn, operands, 1);
    return output_branch(\"GE\", \"jlt\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 14)))])


;;-------------------------------------------------------------------
;; Jump if less than or equal
(define_insn "ble"
  [(set (pc)
	(if_then_else (le (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  {
    tms9900_debug_operands ("ble", insn, operands, 1);
    return output_branch(\"LE\", \"jgt\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 14)))])


;;-------------------------------------
;; Jump if less than or equal, reversed comparison operands
(define_insn "*ble_reversed"
  [(set (pc)
	(if_then_else (le (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  {
    tms9900_debug_operands ("*ble_reversed", insn, operands, 1);
    return output_branch(\"jgt\", \"LE\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 18)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if greater than
(define_insn "bgt"
  [(set (pc)
	(if_then_else (gt (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  {
    tms9900_debug_operands ("bgt", insn, operands, 1);
    return output_branch(\"jgt\", \"LE\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 18)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if greater than, reversed comparison operands
; Was commented out
(define_insn "*bgt_reversed"
  [(set (pc)
	(if_then_else (gt (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  {
    tms9900_debug_operands ("*bgt_reversed", insn, operands, 1);
    return output_branch(\"LE\", \"jgt\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 14)))])


;;-------------------------------------------------------------------
;; Jump if greater than or equal
; Was commented out
(define_insn "bge"
  [(set (pc)
	(if_then_else (ge (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  {
    tms9900_debug_operands ("bge", insn, operands, 1);
    return output_branch(\"GE\", \"jlt\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 14)))])


;;-------------------------------------
;; Jump if greater than or equal, reversed comparison operands
(define_insn "*bge_reversed"
  [(set (pc)
	(if_then_else (ge (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  {
    tms9900_debug_operands ("*bge_reversed", insn, operands, 1);
    return output_branch(\"jlt\", \"GE\", get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 18)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;;  Jump Operations
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Unconditional jump to label
(define_insn "jump"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  ""
  {
    tms9900_debug_operands ("jump", insn, operands, 1);
    return output_jump(get_attr_length(insn));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 14)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Unconditional jump using pointer
(define_insn "indirect_jump"
  [(set (pc) (match_operand:HI 0 "nonimmediate_operand" "r,Q"))]
  ""
  {
    tms9900_debug_operands ("indirect_jump", insn, operands, 1);
    return "b    %0 ; indirect jump";
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------------------------------------
;; Unconditional jump using jump table
(define_insn "tablejump"
  [(set (pc) (match_operand:HI 0 "nonimmediate_operand" "rR,Q"))
   (use (label_ref (match_operand 1 "" "")))]
  ""
  {
    tms9900_debug_operands ("tablejump", insn, operands, 1);
    output_asm_insn("mov  %0, r0", operands);
    output_asm_insn("b    *r0",    operands);
    return(""); 
  }
  [(set_attr "length" "4,6")])


;;-------------------------------------------------------------------
;;  Bit Shift Operations
;;-------------------------------------------------------------------

;; NOTE : On the TMS9900 a shift count of 0 is interpreted as
;; shift by 16, so test for 0 and jump over the shift if true.  Do the same in
;; all other shift by register insns as well.

;; Accept any shift count but if it is not a constant, load it into r0 first.

;; If we are asked to shift by a constant 0 then the
;; compiler is being stupid so detect this (constraint 'O') and emit nothing

;;-------------------------------------------------------------------
;; Arithmetic shift left.
;;
;;-------------------------------------------------------------------
(define_insn "ashlhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r,r,r")
	(ashift:HI (match_operand:HI 1 "register_operand" "0,0,0,0")
		   (match_operand:HI 2 "general_operand" "rR,Q,O,i")))]
  ""
  {
    tms9900_debug_operands ("ashlhi3", insn, operands, 3);
    if(which_alternative < 2)
    {
      output_asm_insn("mov  %2, r0",   operands);
      output_asm_insn("jeq  $+4",    operands);
      output_asm_insn("sla  %0, 0",  operands);
    }
    else if (which_alternative > 2)
    {
      output_asm_insn("sla  %0, %2", operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,8,0,2")])


;;-------------------------------------
(define_insn "ashlqi3"
  [(set (match_operand:QI 0 "register_operand" "=r,r,r,r")
        (ashift:QI (match_operand:QI 1 "register_operand" "0,0,0,0")
                   (match_operand:HI 2 "general_operand" "rR,Q,O,i")))]
  ""
  {
    tms9900_debug_operands ("ashlqi3", insn, operands, 3);
    if(which_alternative < 2)
    {
      output_asm_insn("mov  %2, r0",   operands);
      output_asm_insn("jeq  $+8",       operands);  /* If shift count is zero, do nothing */
      output_asm_insn("andi %0, >FF00", operands);
      output_asm_insn("sla  %0, 0",     operands);
    }
    else if (which_alternative > 2)
    {
      output_asm_insn("andi %0, >FF00", operands);
      output_asm_insn("sla  %0, %2",    operands);
    }
    return(""); 
  }
  [(set_attr "length" "10,12,0,6")])


;;-------------------------------------------------------------------
;; Arithmetic shift left (for QI mode)

(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(sign_extend:HI(match_operand:QI 1 "register_operand" "r,r")))
   (set (match_operand:HI 2 "register_operand" "=r,r")
	(ashift:HI (match_dup 0)
                   (plus:HI (match_operand:HI 3 "const_int_operand" "i,i")
                            (match_operand:HI 4 "const_int_operand" "i,i"))))]
  ""
  [(set (match_dup 2)
        (match_dup 1))
   (set (match_dup 2)
        (ashift:QI (match_dup 2)
                   (match_dup 3)))]
  {
    tms9900_debug_operands ("peep-alsqi", NULL_RTX, operands, 5);
  }
 )


;;-------------------------------------
(define_insn "ashrhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r,r,r")
	(ashiftrt:HI (match_operand:HI 1 "register_operand" "0,0,0,0")
		     (match_operand:HI 2 "general_operand" "rR,Q,O,i")))]
  ""
  {
    tms9900_debug_operands ("ashrhi3", insn, operands, 3);
    if(which_alternative < 2)
    {
      output_asm_insn("mov  %2, r0",   operands);
      output_asm_insn("jeq  $+4",    operands);
      output_asm_insn("sra  %0, 0",  operands);
    }
    else if (which_alternative > 2)
    {
      output_asm_insn("sra  %0, %2", operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,8,0,2")])


;;-------------------------------------
(define_insn "ashrqi3"
  [(set (match_operand:QI 0 "register_operand" "=r,r,r,r")
	(ashiftrt:QI (match_operand:QI 1 "register_operand" "0,0,0,0")
		     (match_operand:HI 2 "general_operand" "rR,Q,O,i")))]
  ""
  {
    tms9900_debug_operands ("ashrqi3", insn, operands, 3);
    if(which_alternative < 2)
    {
      output_asm_insn("mov  %2, r0",  operands);
      output_asm_insn("jeq  $+4",    operands);
      output_asm_insn("sra  %0, 0",  operands);
    }
    else if (which_alternative > 2)
    {
      output_asm_insn("sra  %0, %2",    operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,8,0,2")])


;;-------------------------------------
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "r,r")
	(sign_extend:HI(match_operand:QI 1 "register_operand" "r,r")))
   (set (match_operand:HI 3 "register_operand" "r,r")
	(ashiftrt:HI (match_operand:HI 4 "register_operand" "0,0")
		     (match_operand:HI 5 "general_operand" "rRQ,i")))
   (set (match_operand:QI 6 "register_operand" "r,r")
        (subreg:QI (match_operand:HI 7 "register_operand" "3,3") 1))]
  ""
  [(set (match_dup 6)
        (match_dup 1))
   (set (match_dup 6)
        (ashiftrt:QI (match_dup 6)
                     (match_dup 5)))]
  {
    tms9900_debug_operands ("peep-asrhi", NULL_RTX, operands, 8);
  }
  )


;;-------------------------------------------------------------------
;; Logical shift right



;;-------------------------------------
(define_insn "lshrhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r,r,r")
	(lshiftrt:HI (match_operand:HI 1 "register_operand" "0,0,0,0")
		     (match_operand:HI 2 "general_operand" "rR,Q,O,i")))]
  ""
  {
    tms9900_debug_operands ("lshrhi3", insn, operands, 3);
    if(which_alternative < 2)
    {
      output_asm_insn("mov  %2, r0",  operands);
      output_asm_insn("jeq  $+4",    operands);
      output_asm_insn("srl  %0, 0",  operands);
    }
    else if (which_alternative > 2)
    {
      output_asm_insn("srl  %0, %2", operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,8,0,2")])


;;-------------------------------------
; shift right 8 (extend) followed by truncate (swpb) negate each other so remove
; by emitting a nop (const_int 0)

(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
	(lshiftrt:HI (match_dup 0)
		     (const_int 8)))
   (set (match_operand:QI 1 "register_operand" "")
	(truncate:QI(match_dup 0)))]
  ""
  [(const_int 0)]
  "")

;;-------------------------------------
; same for arith shift 8

(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
	(ashiftrt:HI (match_dup 0)
		     (const_int 8)))
   (set (match_operand:QI 1 "register_operand" "")
	(truncate:QI(match_dup 0)))]
  ""
  [(const_int 0)]
  "")

;;-------------------------------------
(define_insn "lshrqi3"
  [(set (match_operand:QI 0 "register_operand" "=r,r,r,r")
	(lshiftrt:QI (match_operand:QI 1 "register_operand" "0,0,0,0")
		     (match_operand:HI 2 "general_operand" "rR,Q,O,i")))]
  ""
  {
    tms9900_debug_operands ("lshrqi3", insn, operands, 3);
    if(which_alternative < 2)
    {
      output_asm_insn("mov  %2, r0",  operands);
      output_asm_insn("jeq  $+4",    operands);
      output_asm_insn("srl  %0, 0",  operands);
    }
    else if (which_alternative > 2)
    {
      output_asm_insn("srl  %0, %2",    operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,8,0,2")])


(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "r,r")
	(sign_extend:HI(match_operand:QI 1 "register_operand" "r,r")))
   (set (match_operand:HI 3 "register_operand" "r,r")
	(lshiftrt:HI (match_operand:HI 4 "register_operand" "0,0")
		     (match_operand:HI 5 "general_operand" "rRQ,i")))
   (set (match_operand:QI 6 "register_operand" "r,r")
        (subreg:QI (match_operand:HI 7 "register_operand" "3,3") 1))]
  ""
  [(set (match_dup 6)
        (match_dup 1))
   (set (match_dup 6)
        (lshiftrt:QI (match_dup 6)
                     (match_dup 5)))]
  {
    tms9900_debug_operands ("peep-lsrhi", NULL_RTX, operands, 8);
  }
  )
      


;;-------------------------------------------------------------------
;; Rotate 


;;-------------------------------------
(define_expand "rotlhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (rotatert:HI (match_operand:HI 1 "register_operand" "0,0")
                     (match_operand:HI 2 "general_operand" "rRQ,i")))]
  ""
  {
    tms9900_debug_operands ("rotlhi3", NULL_RTX, operands, 3);
    tms9900_inline_debug ("; rotlhi3 alt=%d\n", which_alternative);
    if (GET_CODE (operands[2]) == CONST_INT)
      operands[2] = GEN_INT ((16 - INTVAL (operands[2])) % 16);
    else
      {
        rtx reg = gen_reg_rtx (HImode);
        emit_insn (gen_subhi3 (reg, GEN_INT (16), operands[2]));
        operands[2] = reg;
      }
  })


;;-------------------------------------
(define_insn "rotrhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (rotatert:HI (match_operand:HI 1 "register_operand" "0,0")
                     (match_operand:HI 2 "general_operand" "rRQ,i")))]
  ""
  "@
  src  %0, 0
  src  %0, %2" 
 [(set_attr "length" "2,2")])


;;-------------------------------------------------------------------
;;  Bitwise Operations
;;-------------------------------------------------------------------

;;-------------------------------------------------------------------
;; And
;;
;; Uses r0 as a clobber
;;-------------------------------------
(define_insn "andhi3"
  [(set (match_operand:HI 0 "nonimmediate_operand"         "=rR>,rR>,Q,  Q,r,r,r,R>,Q")
	(and:HI (match_operand:HI 1 "nonimmediate_operand" "0,   0,  0,  0,0,0,0,0, 0")
		(match_operand:HI 2 "general_operand"      "rR>, Q,  rR>,Q,O,M,i,i, i")))]
  ""
  {
    tms9900_debug_operands ("andhi3", insn, operands, 3);

    /* TODO There is a case where the combiner fails to generate properly byte
     * aligned inputs to andhi3 due to using a subreg when it couldn't find a
     * match for zero extending a byte in a memory location.  My initial fix for
     * this was to write a variant of andhi3 that accepts subregs and do a byte
     * swap.  This did fix the andhi3 optimiser bug but what about the general
     * case?  Surely there is an easier way than to duplicate every insn and add
     * subreg and non subreg cases?  Its unclear why gcc even promotes byte ops
     * to int16 for binary and but not for binary or.  I added memory
     * constraints to the extend and trunc insns but this didn't help find a
     * match.  So rather than writing a duplicate of every HI insn that can
     * accept a subreg, the function tms9900_correct_byte_order checks the
     * offset of operands[1] below.  If non zero this indicates a subreg and we
     * emit a byte swap.  This may not be the only place this is needed but
     * andhi3 is the only known sighting of this issue so far.
     */
    tms9900_correct_byte_order (insn, operands);

    if(which_alternative == 4)
    {
      /* Some paranoia here - confirm O constraint really has given us a const int of
       * zero */
      if (!CONST_INT_P (operands[2]) || (INTVAL(operands[2]) & 0xFFFF) != 0)
        gcc_unreachable();

      /* Result will be zero */
      return("clr  %0");
    }
    else if(which_alternative == 5)
    {
      if (!CONST_INT_P (operands[2]) || (INTVAL(operands[2]) & 0xFFFF) != 0xFFFF)
        gcc_unreachable();

      /* No operation required */
      return("");
    }
    else if(which_alternative == 6)
    {
      /* AND const value and register */
      output_asm_insn("andi %0, %2", operands);
    }
    else if(which_alternative >= 7)
    {
      /* AND const value and memory */
      if (!CONST_INT_P (operands[2]))
        gcc_unreachable();

      int val = ~INTVAL(operands[2]);
      operands[2] = GEN_INT(val & 0xFFFF);
      output_asm_insn("li   r0, %2", operands);
      output_asm_insn("szc  r0, %0", operands);
    }
    else
    {
      /* AND against non-const value.  Copy to R0 as clobber, invert and SZC */
      output_asm_insn("mov  %2, r0", operands);
      output_asm_insn("inv  r0",     operands);
      output_asm_insn("szc  r0, %0", operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,8,8,10,2,0,4,6,8")])


(define_insn "*andnothi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
	(and:HI (match_operand:HI 1 "nonimmediate_operand" "0,0,0,0")
		(not:HI (match_operand:HI 2 "nonimmediate_operand" "rR>,Q,rR>,Q"))))]
  ""
  {
    tms9900_debug_operands ("*andnothi", insn, operands, 3);
    return "szc  %2, %0";
  }
  [(set_attr "length" "2,4,4,6")])


; This handles reverse-order not-and combinations
(define_insn "*not_andhi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
	(and:HI (not:HI (match_operand:HI 1 "nonimmediate_operand" "rR>,Q,rR>,Q"))
                (match_operand:HI 2 "nonimmediate_operand" "0,0,0,0")))]
  ""
  {
    tms9900_debug_operands ("*not_andhi", insn, operands, 3);
    return "szc  %1, %0";
  }
  [(set_attr "length" "2,4,4,6")])


;;-------------------------------------
;;
;; NOTE - we assume that constraint 'i' will only pass a CONST_INT as labels
;; etc don't make sense in the context of a byte operation.  Assert if assumption
;; not true.  If the constant evaluates to 0x00 or 0xFF then apply a short circuit.
;; This will mean length is shorter than declared but that should not matter.
;;
(define_insn "andqi3"
  [(set (match_operand:QI 0 "nonimmediate_operand"         "=rR>,rR>,Q,  Q,r,R>,Q")
	(and:QI (match_operand:QI 1 "nonimmediate_operand" "0,   0,  0,  0,0,0, 0")
		(match_operand:QI 2 "general_operand"      "rR>, Q,  rR>,Q,i,i, i")))]
  ""
  {
    tms9900_debug_operands ("andqi3", insn, operands, 3);
    if(which_alternative >= 4)
    {
      if (!CONST_INT_P (operands[2]))
        gcc_unreachable();

      int val = (INTVAL(operands[2]) << 8) & 0xFF00;

      /* AND const value and register */
      if(val == 0xff00)
        return("");

      if (which_alternative == 4)
      {
        /* AND const value and register */
        operands[2] = GEN_INT(val);
        output_asm_insn ("andi %0, %2", operands);
      }
      else
      {
        /* AND const value and memory */
        operands[2] = GEN_INT(~val);
        output_asm_insn("li   r0, %2", operands);
        output_asm_insn("szcb r0, %0", operands);
      }
    }
    else
    {
      output_asm_insn("movb %2, r0", operands);
      output_asm_insn("inv  r0", operands);
      output_asm_insn("szcb r0, %0", operands);
    }
    return("");
  }
  [(set_attr "length" "6,8,8,10,4,6,8")])


(define_insn "*andnotqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
	(and:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0")
		(not:QI (match_operand:QI 2 "nonimmediate_operand" "rR>,Q,rR>,Q"))))]
  ""
  {
    tms9900_debug_operands ("*not_andhi", insn, operands, 3);
    return "szcb %2, %0";
  }
  [(set_attr "length" "2,4,4,6")])


; This handles reverse-order not-and combinations
(define_insn "*not_andqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
	(and:QI (not:QI (match_operand:QI 1 "nonimmediate_operand" "rR>,Q,rR>,Q"))
                (match_operand:QI 2 "nonimmediate_operand" "0,0,0,0")))]
  ""
  {
    tms9900_debug_operands ("*not_andhi", insn, operands, 3);
    return "szcb %1, %0";
  }
  [(set_attr "length" "2,4,4,6")])


;;-------------------------------------------------------------------
;; Or


;;-------------------------------------
(define_insn "iorhi3"
  [(set (match_operand:HI 0 "nonimmediate_operand"         "=rR>,rR>,Q,  Q,r,r,r")
	(ior:HI (match_operand:HI 1 "nonimmediate_operand" "%0,  0,  0,  0,0,0,0")
		(match_operand:HI 2 "general_operand"      "rR>, Q,  rR>,Q,O,M,n")))]
  ""
  {
    tms9900_debug_operands ("iorhi3", insn, operands, 3);

    if (which_alternative < 4)
      return("soc  %2, %0");
    else
    {
      if (!CONST_INT_P (operands[2]))
        gcc_unreachable();

      int val = INTVAL(operands[2]) & 0xFFFF;
      if(val == 0xFFFF)
        return "seto %0";
      else if(val == 0)
        return "";

      return "ori  %0, %2";
    }
  }
  [(set_attr "length" "2,4,4,6,0,2,4")])


;;-------------------------------------
(define_insn "iorqi3"
   [(set (match_operand:QI 0 "nonimmediate_operand"        "=rR>,Q,  rR>,Q,r")
	(ior:QI (match_operand:QI 1 "nonimmediate_operand" "0,   0,  0,  0,0")
		(match_operand:QI 2 "general_operand"      "rR>, rR>,Q,  Q,n")))]
  ""
  {
    tms9900_debug_operands ("iorqi3", insn, operands, 3);

    if (which_alternative < 4)
      return ("socb %2, %0");
    else
    {
      if (!CONST_INT_P (operands[2]))
        gcc_unreachable();

      int val = (INTVAL(operands[2]) << 8) & 0xFF00;
      tms9900_inline_debug ("; iorqi3 val=%X\n", val);
      rtx args[2];
      args[0] = operands[0];
      args[1] = GEN_INT(val);
      /* AND const value and register */
      if(val == 0)
        return("");
      else if(val == 0xff00)
        output_asm_insn("seto %0", args);
      else
        output_asm_insn("ori  %0, %1", args);
    }
    return("");
  }
  [(set_attr "length" "2,4,4,6,4")])


;;-------------------------------------------------------------------
;; Xor


;;-------------------------------------
(define_insn "xorhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(xor:HI (match_operand:HI 1 "register_operand" "%0,0")
		(match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("xorhi3", insn, operands, 3);
    return "xor  %2, %0";
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------
;; This works for regs only as xor is 16-bit only and should not be used on
;; memory locations as it will affect the neighbouring byte
(define_insn "xorqi3"
  [(set (match_operand:QI 0 "register_operand" "=r")
	(xor:QI (match_operand:QI 1 "register_operand" "%0")
		(match_operand:QI 2 "nonimmediate_operand" "r")))]
  ""
  {
    tms9900_debug_operands ("xorqi3", insn, operands, 3);
    return "xor  %2, %0";
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Not
;;-------------------------------------
(define_insn "one_cmplhi2"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
        (not:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))]
  ""
  {
    tms9900_debug_operands ("one_cmplhi2", insn, operands, 3);
    return "inv  %0";
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------
;; This works for regs only as inv is 16-bit only and should not be used on
;; memory locations as it will affect the neighbouring byte
(define_insn "one_cmplqi2"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=r")
        (not:QI (match_operand:QI 1 "nonimmediate_operand" "0")))]
  ""
  {
    tms9900_debug_operands ("one_cmplqi2", insn, operands, 3);
    return "inv  %0";
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;;  Arithmetic Operations
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Add
;;-------------------------------------
(define_insn "addhi3"
  [(set (match_operand:HI 0 "nonimmediate_operand"          "=rR>,   Q,      r,rR>,Q")
	(plus:HI (match_operand:HI 1 "nonimmediate_operand" "%0,     0,      0,0,  0")
		 (match_operand:HI 2 "general_operand"      "rR>LMNO,rR>LNMO,i,Q,  Q")))]
  ""
  {
    tms9900_debug_operands ("addhi3", insn, operands, 3);
    switch(GET_CODE(operands[2]))
    {
      case CONST_INT:
      {
        if (INTVAL(operands[2]) == 1)
	  return("inc  %0");
        else if (INTVAL(operands[2]) == -1)
          return("dec  %0");
        else if (INTVAL(operands[2]) == 2)
          return("inct %0");
        else if (INTVAL(operands[2]) == -2)
          return("dect %0");
        else
          return("ai   %0, %2");
      }

      case MEM:
      case REG:
        return ("a    %2, %0");

      default:
          return("ai   %0, %2");
    }
  }
  [(set_attr "length" "2,4,4,4,6")])


;;-------------------------------------
(define_insn "addqi3"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q,r")
	(plus:QI (match_operand:QI 1 "nonimmediate_operand" "%0,0,0,0,0")
		 (match_operand:QI 2 "general_operand" "rR>,Q,rR>,Q,i")))]
  ""
  {
    tms9900_debug_operands ("addqi3", insn, operands, 3);
  if (GET_CODE (operands[2]) == CONST_INT)
    {
      operands[2] = GEN_INT(INTVAL(operands[2]) * 256);
      return("ai   %0, %2");
    }
  return("ab   %2, %0");
  }
  [(set_attr "length" "2,4,4,6,4")])


;;-------------------------------------------------------------------
;; Subtract
;;-------------------------------------
(define_insn "subhi3"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q,rR>,Q,rR>,Q,rR>,Q")
	(minus:HI (match_operand:HI 1 "nonimmediate_operand" "0,0,0,0,rR>,rR>,Q,Q")
		  (match_operand:HI 2 "nonimmediate_operand" "rR>,rR>,Q,Q,0,0,0,0")))]
  ""
  {
    tms9900_debug_operands ("subhi3", insn, operands, 3);
    if(which_alternative < 4)
    {
      output_asm_insn("s    %2, %0",operands);
    }
    else
    {
      output_asm_insn("s    %1, %0",operands);
      output_asm_insn("neg  %0",operands);
    }
    return("");
  }
  [(set_attr "length" "2,4,4,6, 4,6,8,10")])


;;-------------------------------------
(define_insn "*rsubihi"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(minus:HI (match_operand:HI 1 "immediate_operand" "i")
		  (match_operand:HI 2 "register_operand" "0")))]
  ""
  {
    tms9900_debug_operands ("*rsubihi", insn, operands, 3);
    if (INTVAL(operands[1]) == -1)
      output_asm_insn("inc  %0",operands);
    else if (INTVAL(operands[1]) == 1)
      output_asm_insn("dec  %0",operands);
    else if (INTVAL(operands[1]) == -2)
      output_asm_insn("inct %0",operands);
    else if (INTVAL(operands[1]) == 2)
      output_asm_insn("dect %0",operands);
    else
    {
      operands[1] = GEN_INT(-INTVAL(operands[1]));
      output_asm_insn("ai   %0, %1",operands);
    }
    output_asm_insn("neg  %0",operands);
    return "";
  }
  [(set_attr "length" "6")])


;;-------------------------------------
;; MGB TODO why negate?  In case operands are swapped. Why not just constrain
;; the compiler?
(define_insn "subqi3"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,Q,rR>,Q")
	(minus:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0")
		  (match_operand:QI 2 "nonimmediate_operand" "rR>,rR>,Q,Q")))]
  ""
  {
    tms9900_debug_operands ("subqi3", insn, operands, 3);
    if(which_alternative < 4)
    {
      output_asm_insn("sb   %2, %0",operands);
    }
    else
    {
      output_asm_insn("sb   %1, %0",operands);
      output_asm_insn("neg  %0",operands);
    }
    return("");
  }
  [(set_attr "length" "2,4,4,6")])


;;-------------------------------------------------------------------
;; Multiply
;;
;;-------------------------------------
; Expand for signed HI = QI x QI
; TODO check sign of highpart of HI
(define_expand "mulqihi3"
   [(set (match_operand:HI 0 "register_operand" "=r")
        (mult:HI (match_operand:QI 1 "register_operand" "r")
                 (match_operand:QI 2 "register_operand" "rRQ>")))]
  ""
  {
    tms9900_debug_operands ("mulqihi3", NULL_RTX, operands, 3);

    rtx result = gen_reg_rtx (SImode);
    rtx op1 = gen_reg_rtx (HImode);
    rtx op2 = gen_reg_rtx (HImode);
    emit_insn (gen_extendqihi2 (op1, operands[1]));
    emit_insn (gen_extendqihi2 (op2, operands[2]));
    emit_move_insn(gen_highpart (HImode, result), op1);
    emit_insn(gen_mulnative(result, result, op2));
    emit_move_insn (operands[0], gen_lowpart (HImode, result));
    DONE;
  }
)

;;-------------------------------------
; Expand for unsigned HI = QI x QI
;
(define_expand "umulqihi3"
   [(set (match_operand:HI 0 "register_operand" "=r")
        (mult:HI (match_operand:QI 1 "register_operand" "r")
                 (match_operand:QI 2 "register_operand" "rRQ>")))]
  ""
  {
    tms9900_debug_operands ("umulqihi3", NULL_RTX, operands, 3);

    rtx result = gen_reg_rtx (SImode);
    rtx op1 = gen_reg_rtx (HImode);
    rtx op2 = gen_reg_rtx (HImode);

    /* Extend expects both regs to be the same but passing two operands is legit
     * as it forces the compiler to copy them to one reg first */
    emit_insn (gen_zero_extendqihi2 (op1, operands[1]));
    emit_insn (gen_zero_extendqihi2 (op2, operands[2]));
    emit_move_insn(gen_highpart (HImode, result), op1);
    emit_insn(gen_mulnative(result, result, op2));
    emit_move_insn (operands[0], gen_lowpart (HImode, result));
    DONE;
  }
)

;;-------------------------------------
; Expand for signed SI = HI x HI
;
(define_expand "mulhisi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(mult:SI (zero_extend (match_operand:HI 1 "register_operand" "=r,r"))
		 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("mulqihi3", NULL_RTX, operands, 3);
    tms9900_inline_debug ("; mulhisi3 alt=%d\n", which_alternative);

    rtx result = gen_reg_rtx (SImode);
    emit_move_insn(gen_highpart (HImode, result), operands[1]);
    emit_insn(gen_mulnative(result, result, operands[2]));
    emit_move_insn (operands[0], result);
    DONE;
  }
)

;;-------------------------------------
; Expand for unsigned SI = HI x HI
;
(define_expand "umulhisi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(mult:SI (zero_extend (match_operand:HI 1 "register_operand" "=r,r"))
		 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("umulhisi3", NULL_RTX, operands, 3);
    tms9900_inline_debug ("; umulhisi3 alt=%d\n", which_alternative);

    rtx result = gen_reg_rtx (SImode);
    emit_move_insn(gen_highpart (HImode, result), operands[1]);
    emit_insn(gen_mulnative(result, result, operands[2]));
    emit_move_insn (operands[0], result);
    DONE;
  }
)

;;-------------------------------------
; expand HI=HIxHI to native SI=SIxHI

(define_expand "mulhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (mult:HI (match_operand:HI 1 "register_operand" "+0,0")
                 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("mulhi3", NULL_RTX, operands, 3);
    tms9900_inline_debug ("; mulhi3 alt=%d\n", which_alternative);

    rtx result = gen_reg_rtx (SImode);
    emit_move_insn(gen_highpart (HImode, result), operands[1]);
    emit_insn(gen_mulnative(result, result, operands[2]));
    emit_move_insn (operands[0], gen_lowpart (HImode, result));
    DONE;
   }
)

;;-------------------------------------
; This is the native multiplication on the tms9900.  SI=HIxHI
;  Note it is expected that op1 == op0 so we specify that op1 is SI.
;  All other variants, QIxQI, etc, should expand to this insn.
;  Also, mpy is unsigned so signed variants need to expand differently.
;  Signed vs unsigned makes no difference if operands and results are the same
;  size but will yield wrong results if result is wider than operands.

(define_insn "mulnative"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(mult:SI (match_operand:SI 1 "register_operand" "0,0")
		 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("mulnative", insn, operands, 3);
    return ("mpy  %2, %0");
  }
  [(set_attr "length" "2,4")])

;;-------------------------------------
;; byte mul can only work in registers as we need to expand to HI mode

(define_expand "udivmodqi4"
  [(parallel [
     (set (match_operand:QI 0 "register_operand" "=r")
          (div:QI (match_operand:QI 1 "register_operand" "0")
                  (match_operand:QI 2 "register_operand" "r")))
     (set (match_operand:QI 3 "register_operand" "=r")
          (mod:QI (match_dup 1) 
                  (match_dup 2)))])]
  ""
  {
    tms9900_debug_operands ("udivmodqi4", NULL_RTX, operands, 4);

    /* Move and extend QI dividend to SI */
    rtx dividend = gen_reg_rtx (SImode);
    rtx scratch = gen_reg_rtx (HImode);
    emit_insn(gen_zero_extendqihi2 (scratch, operands[1]));
    emit_insn(gen_zero_extendhisi2 (dividend, scratch));

    /* Extend the divisor */
    rtx divisor = gen_reg_rtx (HImode);
    emit_insn(gen_zero_extendqihi2 (divisor, operands[2]));

    /* Do the division */
    emit_insn(gen_udivmodsihi3(dividend, dividend, divisor));

    /* Convert and store quotient from HI to QI */
    rtx quotient = gen_reg_rtx (HImode);
    emit_move_insn (quotient, gen_highpart (HImode, dividend));
    emit_insn(gen_trunchiqi2 (operands[0], quotient));

    /* Convert and store quotient from HI to QI */
    rtx remainder = gen_reg_rtx (HImode);
    emit_move_insn (remainder, gen_lowpart (HImode, dividend));
    emit_insn(gen_trunchiqi2 (operands[3], remainder));
    DONE;
  })

(define_expand "udivmodhi4"
  [(parallel [
     (set (match_operand:HI 0 "register_operand" "=r,r")
          (div:HI (match_operand:HI 1 "register_operand" "+0,0")
                  (match_operand:HI 2 "nonimmediate_operand" "+rR>,Q")))
     (set (match_operand:HI 3 "register_operand" "=r,r")
          (mod:HI (match_dup 1) 
                  (match_dup 2)))])]
  ""
  {
    tms9900_debug_operands ("udivmodhi4", NULL_RTX, operands, 4);
    tms9900_inline_debug ("; udivmodhi4 alt=%d\n", which_alternative);
    rtx dividend = gen_reg_rtx (SImode);
    rtx tmp = gen_reg_rtx (HImode);
    emit_move_insn(tmp, operands[1]);
    emit_insn(gen_zero_extendhisi2 (dividend, tmp));
    emit_insn(gen_udivmodsihi3(dividend, dividend, operands[2]));
    emit_move_insn (operands[0], gen_highpart (HImode, dividend));
    emit_move_insn (operands[3], gen_lowpart (HImode, dividend));
    DONE;
  })


;;-------------------------------------
;; Signed div/mod.  Native method is unsigned so record the sign of the result
;; by xor'ing operands together to examine highest bit.  Then take abs of operands.
;; Correct the sign of the quotient after the operation
(define_expand "divmodqi4"
  [(parallel [
     (set (match_operand:QI 0 "register_operand" "=r,r")
          (div:QI (match_operand:QI 1 "register_operand" "0,0")
                  (match_operand:QI 2 "nonimmediate_operand" "rR>,Q")))
     (set (match_operand:QI 3 "register_operand" "=r,r")
          (mod:QI (match_dup 1) 
                  (match_dup 2)))])]
  ""
  {
    tms9900_debug_operands ("divmodqi4", NULL_RTX, operands, 4);
    tms9900_inline_debug ("; divmodqi4 alt=%d\n", which_alternative);

    /* Find quotient sign */
    rtx sign = gen_reg_rtx (HImode); // sign of quotient
    emit_insn(gen_extendqihi2 (operands[1], sign));
    // emit_move_insn(sign, operands[1]);
    emit_insn(gen_extendqihi2 (operands[2], operands[2]));
    emit_insn(gen_xorhi3(sign, sign, operands[2]));

    /* Use temp for operand2 and get abs value */
    rtx divisor = gen_reg_rtx (HImode);
    emit_move_insn(divisor, operands[2]);
    emit_insn(gen_abshi2(divisor, divisor));

    /* Use temp for operand1, get absolute value and extend to SI.  We don't
     * have abssi2 so do abs on a tmp before extend  */
    rtx dividend = gen_reg_rtx (SImode);
    rtx tmp = gen_reg_rtx (HImode);
    emit_move_insn(tmp, operands[1]);
    emit_insn(gen_abshi2(tmp, tmp));
    emit_insn(gen_extendhisi2 (dividend, tmp));

    /* Perform division and modulus */
    emit_insn(gen_udivmodsihi3(dividend, dividend, divisor));

    /* Convert and store quotient from HI to QI */
    rtx quotient = gen_reg_rtx (HImode);
    emit_move_insn (quotient, gen_highpart (HImode, dividend));

    /* Correct sign of quotient */
    emit_insn(gen_divfixuphi2(quotient, sign));

    /* Convert and store quotient from HI to QI */
    emit_insn(gen_trunchiqi2 (operands[0], quotient));

    /* Convert and store remainder from HI to QI */
    rtx remainder = gen_reg_rtx (HImode);
    emit_move_insn (remainder, gen_lowpart (HImode, dividend));
    emit_insn(gen_trunchiqi2 (operands[3], remainder));

    DONE;
  }
)


(define_expand "divmodhi4"
  [(parallel [
     (set (match_operand:HI 0 "register_operand" "=r,r")
          (div:HI (match_operand:HI 1 "register_operand" "0,0")
                  (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))
     (set (match_operand:HI 3 "register_operand" "=r,r")
          (mod:HI (match_dup 1) 
                  (match_dup 2)))])]
  ""
  {
    tms9900_debug_operands ("divmodhi4", NULL_RTX, operands, 4);
    tms9900_inline_debug ("; divmodhi4 alt=%d\n", which_alternative);
    // rtx insn, div_equal, mod_equal, equal;

    /* Find quotient sign */
    rtx sign = gen_reg_rtx (HImode); // sign of quotient
    emit_move_insn(sign, operands[1]);
    emit_insn(gen_xorhi3(sign, sign, operands[2]));

    /* Use temp for operand2 and get abs value */
    rtx divisor = gen_reg_rtx (HImode);
    emit_move_insn(divisor, operands[2]);
    emit_insn(gen_abshi2(divisor, divisor));

    /* Use temp for operand1, get absolute value and extend to SI.  We don't
     * have abssi2 so do abs on a tmp before extend  */
    rtx dividend = gen_reg_rtx (SImode);
    rtx tmp = gen_reg_rtx (HImode);
    emit_move_insn(tmp, operands[1]);
    emit_insn(gen_abshi2(tmp, tmp));
    emit_insn(gen_extendhisi2 (dividend, tmp));

    /* Perform division and modulus */
    emit_insn(gen_udivmodsihi3(dividend, dividend, divisor));
    emit_move_insn (operands[0], gen_highpart (HImode, dividend));
    emit_move_insn (operands[3], gen_lowpart (HImode, dividend));

    /* Correct sign of quotient */
    emit_insn(gen_divfixuphi2(operands[0], sign));

    DONE;
  }
)


;;-------------------------------------------------------------------
;; Divide and Modulus
;; native method HI = SI / HI , HI = SI % HI
;;-------------------------------------
(define_insn "udivmodsihi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
        (ior:SI
          (ashift:SI
            (zero_extend:SI
              (div:HI (match_operand:SI 1 "register_operand" "0,0")
                      (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))
            (const_int 16))
          (zero_extend:SI 
            (mod:HI (match_dup 1)
                    (match_dup 2)))))]
  ""
  {
    tms9900_debug_operands ("udivmodsihi3", insn, operands, 3);
    output_asm_insn ("div  %2, %0", operands);
    return("");
  }
  [(set_attr "length" "2,4")])



(define_insn "divfixuphi2"
  [(set (match_operand:HI 1 "register_operand" "=r")
        (not:HI (match_dup 1)))
   (set (match_operand:HI 0 "register_operand" "=r")
        (if_then_else:HI (lt:HI (match_dup 1) (const_int 0))
           (neg:HI (match_dup 0)) (match_dup 0)))]
  ""
  {
    tms9900_debug_operands ("divfixuphi2", insn, operands, 2);
    output_asm_insn("inv  %1", operands);
    output_asm_insn("jlt  $+4", operands);
    output_asm_insn("neg  %0", operands);
    return("");
  }
  [(set_attr "length" "6")])


;;-------------------------------------------------------------------
;; Absolute Value

;;-------------------------------------
(define_insn "abshi2"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
	(abs:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))]
  ""
  {
    tms9900_debug_operands ("abshi2", insn, operands, 2);
    output_asm_insn ("abs  %0", operands);
    return("");
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------
;; register only as abs is 16-bit
(define_insn "absqi2"
  [(set (match_operand:QI 0 "register_operand" "=r")
	(abs:QI (match_operand:QI 1 "register_operand" "0")))]
  ""
  {
    tms9900_debug_operands ("absqi2", insn, operands, 2);
    output_asm_insn ("abs  %0", operands);
    return("");
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Negate

;;-------------------------------------
(define_insn "neghi2"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
	(neg:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))]
  ""
  {
    tms9900_debug_operands ("neghi2", insn, operands, 2);
    output_asm_insn("neg  %0", operands);
    return("");
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------
;; TODO andi only reqiured for strict
(define_insn "negqi2"
  [(set (match_operand:QI 0 "register_operand" "=r")
	(neg:QI (match_operand:QI 1 "register_operand" "0")))]
  ""
  {
    tms9900_debug_operands ("negqi2", insn, operands, 2);
    output_asm_insn("andi %0, 0xFF00", operands);
    output_asm_insn("neg  %0", operands);
    return("");
  }
  [(set_attr "length" "6")])


;;-------------------------------------------------------------------
;; Other Instructions
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; No-op
(define_insn "nop"
  [(const_int 0)]
  ""
  "nop"
  [(set_attr "length" "2")])



;;-------------------------------------------------------------------
;;  Optimizations For Comparisons
;;-------------------------------------------------------------------

;;-------------------------------------------------------------------
;; Optimization for X == {-2,-1,1,2}
(define_peephole2
  [(set (cc0)
	(compare (match_operand:HI 0 "register_operand" "r")
		 (match_operand:HI 1 "immediate_operand" "LMNO")))
   (set (pc) (if_then_else (eq (cc0) (const_int 0))
                           (label_ref (match_operand 2 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(2, operands[0])"
  [(set (match_operand:HI 0 "register_operand" "")
	(plus:HI (match_dup 0) (neg:HI (match_dup 1))))
   (set (cc0) (match_dup 0))
   (set (pc) (if_then_else (eq (cc0) (const_int 0))
                           (label_ref (match_dup 2))
                           (pc)))]
  {
    tms9900_debug_operands ("peep-cmp1221", NULL_RTX, operands, 3);
  }
  )


(define_insn "*sub_const_hi"
  [(set (match_operand:HI 0 "register_operand" "=r,r,r,r")
        (plus:HI (match_operand:HI 1 "register_operand" "0,0,0,0")
                 (neg:HI (match_operand:HI 2 "immediate_operand" "LMN,O, n,i"))))]
  ""
  {
    tms9900_debug_operands ("*sub_const_hi", insn, operands, 3);
    tms9900_inline_debug ("; movqi alt=%d\n", which_alternative);
    if (GET_CODE(operands[2]) == CONST_INT)
    {
      tms9900_inline_debug("; is int, val=0x%x\n", INTVAL(operands[2]));
      operands[2] = GEN_INT(-INTVAL(operands[2]));
      switch(INTVAL(operands[2]))
      {
        case -2: output_asm_insn("dect %0",     operands); break;
        case -1: output_asm_insn("dec  %0",     operands); break;
        case  1: output_asm_insn("inc  %0",     operands); break;
        case  2: output_asm_insn("inct %0",     operands); break;
        default: output_asm_insn("ai   %0, %2", operands); break;
      }
    }
    else
    {
      tms9900_inline_debug("; NOT int, val=0x%x\n", INTVAL(operands[2]));
      output_asm_insn("li   r0, %2", operands);
      output_asm_insn("s    r0, %0", operands);
    }
    return("");
  }
  [(set_attr "length" "2,2,4,6")])


;;-------------------------------------------------------------------
;; Optimization for X != {-2,-1,1,2}
(define_peephole2
  [(set (cc0)
	(compare (match_operand:HI 0 "register_operand" "r")
		 (match_operand:HI 1 "immediate_operand" "LMNO")))
   (set (pc) (if_then_else (ne (cc0) (const_int 0))
                           (label_ref (match_operand 2 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(2, operands[0])"
  [(set (match_operand:HI 0 "register_operand" "")
	(plus:HI (match_dup 0) (neg:HI (match_dup 1))))
   (set (cc0) (match_dup 0))
   (set (pc) (if_then_else (ne (cc0) (const_int 0))
                           (label_ref (match_dup 2))
                           (pc)))]
  {
    tms9900_debug_operands ("peep-cmp-ne1221", NULL_RTX, operands, 3);
  }
  )


;;-------------------------------------------------------------------
;;  Optimizations For Byte Compares
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X > N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (gtu (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 255)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (gtu (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  {
    tms9900_debug_operands ("peep-A", NULL_RTX, operands, 4);
  }
  )

;; TODO assume this can be deleted
(define_insn "*cmpqi_as_hi"
  [(set (cc0)
      (compare (match_operand:QI 0 "register_operand" "r")
         (plus:HI (match_operand:HI 1 "const_int_operand" "i")
            (mult:HI (match_operand:HI 2 "const_int_operand" "i")
               (match_operand:HI 3 "const_int_operand" "i")))))]
  "INTVAL(operands[3]) == 256 && (INTVAL(operands[1]) == 0 || INTVAL(operands[1]) == 255)"
  {
    tms9900_debug_operands ("*cmpqi_as_hi", insn, operands, 3);
    operands[1] = GEN_INT(INTVAL(operands[2]) * 256 + INTVAL(operands[1]));
    return("ci   %0, %1");
  }
  [(set_attr "length" "4")])


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X < N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (ltu (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 0)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (ltu (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  {
    tms9900_debug_operands ("peep-cmpqi_lt_hi", NULL_RTX, operands, 4);
  }
  )


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X >= N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (geu (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 0)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (geu (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  {
    tms9900_debug_operands ("peep-cmpqi_ge_hi", NULL_RTX, operands, 3);
  }
  )


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X <= N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (leu (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 255)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (leu (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  {
    tms9900_debug_operands ("peep-cmpqi_le_hi", NULL_RTX, operands, 3);
  }
  )


;;-------------------------------------------------------------------
;; Optimization for (char)X > N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (gt (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 255)
                          (mult:HI (match_dup 1)
                                  (const_int 256)))))
   (set (pc) (if_then_else (gt (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  {
    tms9900_debug_operands ("peep-cmpqi_gt_hi", NULL_RTX, operands, 3);
  }
  )


;;-------------------------------------------------------------------
;; Optimization for (char)X < N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (lt (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 0)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (lt (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  {
    tms9900_debug_operands ("peep-cmpsqi_lt_hi", NULL_RTX, operands, 3);
  }
  )


;;-------------------------------------------------------------------
;; Optimization for (char)X >= N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (ge (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 0)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (ge (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  {
    tms9900_debug_operands ("peep-cmpsqi_ge_hi", NULL_RTX, operands, 3);
  }
  )


;;-------------------------------------------------------------------
;; Optimization for (char)X <= N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (le (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 255)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (le (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  {
    tms9900_debug_operands ("peep-cmpsqi_le_hi", NULL_RTX, operands, 3);
  }
  )


;;-------------------------------------------------------------------
;;  Optimizations For Bit Shift And Cast
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Optimization for (char)X = (int X) >> N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashiftrt:HI (match_dup 0)
            (match_operand:HI 1 "const_int_operand" "i")))
   (set (match_operand:QI 2 "register_operand" "=r")
        (subreg:QI (match_dup 0) 1))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 0)
        (ashiftrt:HI (match_dup 0)
            (minus:HI (match_dup 1) 
                      (const_int 8))))]
  {
    tms9900_debug_operands ("peep-movqi_hi_sh", NULL_RTX, operands, 3);
  }
  )

(define_insn "*ashiftrt_hi_to_qi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashiftrt:HI (match_dup 0)
            (minus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    tms9900_debug_operands ("*ashiftrt_hi_to_qi", insn, operands, 3);
    int shift = INTVAL (operands[1]);
    if(shift < 8)
    {
      operands[1] = GEN_INT(8 - shift);
      output_asm_insn("sla  %0, %1", operands);
    }
    else if(shift > 8)
    {
      operands[1] = GEN_INT(shift - 8);
      output_asm_insn("sra  %0, %1", operands);
    }
    return "";
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X = (unsigned int X) >> N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (lshiftrt:HI (match_dup 0)
            (match_operand:HI 1 "const_int_operand" "i")))
   (set (match_operand:QI 2 "register_operand" "=r")
        (subreg:QI (match_dup 0) 1))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 0)
        (lshiftrt:HI (match_dup 0)
            (minus:HI (match_dup 1) 
                      (const_int 8))))]
  {
    tms9900_debug_operands ("peep-movqi_uhi_sh", NULL_RTX, operands, 3);
  }
  )


(define_insn "*lshiftrt_hi_to_qi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (lshiftrt:HI (match_dup 0)
            (minus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    tms9900_debug_operands ("*lshiftrt_hi_to_qi", insn, operands, 3);
    int shift = INTVAL (operands[1]);
    if(shift < 8)
    {
      operands[1] = GEN_INT(8 - shift);
      output_asm_insn("sla  %0, %1", operands);
    }
    else if(shift > 8)
    {
      operands[1] = GEN_INT(shift - 8);
      output_asm_insn("srl  %0, %1", operands);
    }
    return "";
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (char)X = (int X) << N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashift:HI (match_dup 0)
            (match_operand:HI 1 "const_int_operand" "i")))
   (set (match_operand:QI 2 "register_operand" "=r")
        (subreg:QI (match_dup 0) 1))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 0)
        (ashift:HI (match_dup 0)
            (plus:HI (match_dup 1) 
                      (const_int 8))))]
  {
    tms9900_debug_operands ("peep-movqi_hi_lsh", NULL_RTX, operands, 3);
  }
  )


(define_insn "*ashift_hi_to_qi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashift:HI (match_dup 0)
            (plus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    tms9900_debug_operands ("*ashift_hi_to_qi", insn, operands, 3);
    operands[1] = GEN_INT(8 + INTVAL (operands[1]));
    output_asm_insn("sla  %0, %1", operands);
    return("");
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (int)X = (char X) >> N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (ashiftrt:QI (match_dup 0)
            (match_operand:HI 1 "const_int_operand" "i")))
   (set (match_operand:HI 2 "register_operand" "=r")
        (sign_extend:HI (match_dup 0)))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 2)
        (ashiftrt:HI (match_dup 2)
            (plus:HI (match_dup 1) 
                      (const_int 8))))]
  {
    tms9900_debug_operands ("peep-movhi_qi_rsh", NULL_RTX, operands, 3);
  }
  )


(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
	(sign_extend:HI (match_operand:QI 1 "register_operand" "0")))
   (set (match_operand:HI 2 "register_operand" "=r")
        (ashiftrt:HI (match_dup 2)
            (match_operand:HI 3 "const_int_operand" "i")))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 2)
        (ashiftrt:HI (match_dup 2)
            (plus:HI (match_dup 3) 
                      (const_int 8))))]
  {
    tms9900_debug_operands ("peep-sign-ext", NULL_RTX, operands, 4);
  }
  )


(define_insn "*ashiftrt_qi_to_hi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashiftrt:HI (match_dup 0)
            (plus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    tms9900_debug_operands ("*ashiftrt_qi_to_hi", insn, operands, 3);
    int shift = INTVAL (operands[1]) + 8;
    if(shift > 15) shift = 15;
    operands[1] = GEN_INT(shift);
    output_asm_insn("sra  %0, %1", operands);
    return("");
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (int)X = (unsigned char X) >> N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (lshiftrt:HI (match_operand:HI 1 "register_operand" "0")
            (match_operand:HI 2 "const_int_operand" "i")))
   (set (match_operand:HI 3 "register_operand" "=r")
        (and:HI (match_operand:HI 4 "const_int_operand" "2")
                (match_operand:HI 5 "const_int_operand" "i")))]
  "(REGNO(operands[0]) == REGNO(operands[3])) && (INTVAL(operands[5]) == (1<<(8-INTVAL(operands[2])))-1)"
  [(set (match_dup 0)
        (lshiftrt:HI (match_dup 0)
            (plus:HI (match_dup 2) 
                      (const_int 8))))]
  {
    tms9900_debug_operands ("peep-lsh-and", NULL_RTX, operands, 6);
  }
  )


(define_insn "*lshiftrt_qi_to_hi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (lshiftrt:HI (match_dup 0)
            (plus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    tms9900_debug_operands ("*lshiftrt_qi_to_hi", insn, operands, 3);
    int shift = INTVAL (operands[1]) + 8;
    if(shift > 15) shift = 15;
    operands[1] = GEN_INT(shift);
    output_asm_insn("srl  %0, %1", operands);
    return("");
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (int)X = ((int)(char X)) << N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (sign_extend:HI (match_operand:QI 1 "register_operand" "0")))
   (set (match_operand:HI 3 "register_operand" "=r")
        (ashift:HI (match_operand:HI 4 "register_operand" "3")
                   (match_operand:HI 5 "const_int_operand" "i")))]
  "(REGNO(operands[0]) == REGNO(operands[3]))"
  [(set (match_dup 0)
        (ashiftrt:HI (const_int 8)
            (ashift:HI (match_dup 0) 
                       (match_dup 5))))]
  {
    tms9900_debug_operands ("peep-sign-ext-ash", NULL_RTX, operands, 6);
  }
  )

(define_insn "*qi_hi_shift"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashiftrt:HI (match_operand:HI 1 "const_int_operand" "i")
            (ashift:HI (match_operand:HI 2 "register_operand" "0") 
                       (match_operand:HI 3 "const_int_operand" "i"))))]
  ""
  {
    tms9900_debug_operands ("*qi_hi_shift", insn, operands, 3);
    int shift = INTVAL(operands[3]);
    if(shift == 0) {
      output_asm_insn("swpb %0", operands);
      }
    else if(shift >= 1 && shift <= 7) { 
      operands[3] = GEN_INT(8-shift);
      output_asm_insn("sra  %0, %3", operands);
      }
    else if(shift >= 9 && shift <= 15) {
      operands[3] = GEN_INT(shift-8);
      output_asm_insn("sla  %0, %3", operands);
      }

    operands[3] = GEN_INT(0x00FF << shift);
    output_asm_insn("andi %0, %3", operands);
   
    return("");
  }
  [(set_attr "length" "6")])


;;-------------------------------------------------------------------
;; Optimization for (unsigned int)X = ((unsigned int)(unsigned char X)) << N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (zero_extend:HI (match_operand:QI 1 "register_operand" "0")))
   (set (match_operand:HI 3 "register_operand" "=r")
        (ashift:HI (match_operand:HI 4 "register_operand" "3")
                   (match_operand:HI 5 "const_int_operand" "i")))]
  "(REGNO(operands[0]) == REGNO(operands[3]))"
  [(set (match_dup 0)
        (lshiftrt:HI (const_int 8)
            (ashift:HI (match_dup 0) 
                       (match_dup 5))))]
  {
    tms9900_debug_operands ("peep-zero-ext-ash", NULL_RTX, operands, 6);
  }
  )


(define_insn "*unsigned_qi_hi_shift"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (lshiftrt:HI (match_operand:HI 1 "const_int_operand" "i")
            (ashift:HI (match_operand:HI 2 "register_operand" "0") 
                       (match_operand:HI 3 "const_int_operand" "i"))))]
  ""
  {
    tms9900_debug_operands ("*unsigned_qi_hi_shift", insn, operands, 3);
    int shift = INTVAL(operands[3]);
    if(shift >= 0 && shift <= 7) { 
      operands[3] = GEN_INT(8-shift);
      output_asm_insn("srl  %0, %3", operands);
      }
    else if(shift >= 9 && shift <= 15) {
      operands[3] = GEN_INT(shift-8);
      output_asm_insn("sla  %0, %3", operands);
      }

    operands[3] = GEN_INT(0xFFFF << shift);
    output_asm_insn("andi %0, %3", operands);
   
    return("");
  }
  [(set_attr "length" "6")])


;;-------------------------------------------------------------------
;; Optimization for (unsigned long)X = (unsigned long Y) >> 16
;;   Original code:
;;     mov  r3, r6
;;     mov  r4, r7
;;     mov  r6, r7
;;     clr  r6
;;
;;   Optimized:
;;     mov r3, r7
;;     clr r6
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (match_operand:HI 1 "register_operand" "r"))
   (set (match_operand:HI 2 "register_operand" "=r")
        (match_operand:HI 3 "register_operand" "r"))
   (parallel[
    (clobber (match_operand:HI 4 "register_operand" "r"))
    (set (match_operand:SI 5 "register_operand" "=r")
         (lshiftrt:SI (match_operand:SI 6 "register_operand" "5")
                      (match_operand:HI 7 "const_int_operand" "i")))
   ])]
  "((REGNO(operands[0]) == REGNO(operands[5])) &&
    (REGNO(operands[2]) == (REGNO(operands[0])+1)) &&
    (INTVAL(operands[7]) == 16)
   )"
  [(set (match_dup 2) (match_dup 1))
   (set (match_dup 0) (const_int 0))]
  {
    tms9900_debug_operands ("peep-mov-squash", NULL_RTX, operands, 8);
  }
)


(define_insn "*set_consthi2"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (match_operand:HI 1 "const_int_operand" "i"))]
  ""
  {
    tms9900_debug_operands ("*set_consthi2", insn, operands, 3);
    if(INTVAL(operands[1]) == 0) {
      output_asm_insn("clr  %0", operands);
    } else if((INTVAL(operands[1]) & 0xFFFF) == 0xFFFF) {
      output_asm_insn("seto  %0", operands);
    } else {
      output_asm_insn("li   %0, %1", operands);
    }
    return("");
  }
  [(set_attr "length" "4")])


;;-------------------------------------------------------------------
;; Optimization for X = Y << 16
;;   Original code:
;;     mov  r4, r6
;;     mov  r5, r7
;;     mov  r7, r6
;;     clr  r7
;;
;;   Optimized:
;;     mov r5, r6
;;     clr r7
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (match_operand:HI 1 "register_operand" "r"))
   (set (match_operand:HI 2 "register_operand" "=r")
        (match_operand:HI 3 "register_operand" "r"))
   (parallel[
    (clobber (match_operand:HI 4 "register_operand" "r"))
    (set (match_operand:SI 5 "register_operand" "=r")
         (ashift:SI (match_operand:SI 6 "register_operand" "5")
                      (match_operand:HI 7 "const_int_operand" "i")))
   ])]
  "((REGNO(operands[0]) == REGNO(operands[5])) &&
    (REGNO(operands[2]) == (REGNO(operands[0])+1)) &&
    (INTVAL(operands[7]) == 16)
   )"
  [(set (match_dup 0) (match_dup 3))
   (set (match_dup 2) (const_int 0))]
  {
    tms9900_debug_operands ("peep-movsi-squash", NULL_RTX, operands, 8);
  }
)


;-------------------------------------------------------------------
;; Optimization for byte array initializations
; This handles sequences like:
;   li   r1, >1200
;   movb r1, *r2
;   li   r1, >3400
;   movb r1, @1(r2)
;
; and converts to:
;   li   r1, >1234
;   movb r1, *r2
;   swpb r1
;   movb r1, @1(r2)
;
; This saves two bytes and is slightly faster
(define_peephole2
  [(match_scratch:HI 6 "r,r")
   (set (match_operand:QI 0 "register_operand" "=r,r")
        (match_operand:QI 1 "const_int_operand" "i,i"))
   (set (match_operand:QI 2 "nonimmediate_operand" "=R>,Q")
        (match_dup 0))
   (set (match_operand:QI 3 "register_operand" "=r,r")
        (match_operand:QI 4 "const_int_operand" "i,i"))
   (set (match_operand:QI 5 "nonimmediate_operand" "=R>,Q")
        (match_dup 3))]
  "peep2_reg_dead_p(4, operands[0]) && peep2_reg_dead_p(4, operands[3])"
  [(set (match_dup 6)
        (ior:HI (ashift:HI (match_dup 1) 
                     (const_int 8))
             (match_dup 4)))
   (set (match_dup 2)
        (subreg:QI (ashiftrt:HI (match_dup 6) (const_int 8)) 1))
   (set (match_dup 5)
        (subreg:QI (ashiftrt:HI (match_dup 6) (const_int 0)) 1))]
  {
    tms9900_debug_operands ("peep-hi-swpb-mov", NULL_RTX, operands, 6);
  }
)


(define_insn "*movhi_combine_consts"
  [(set (match_operand:HI 0 "register_operand" "")
        (ior:HI (ashift:HI (match_operand:QI 1 "const_int_operand" "")
                           (match_operand:QI 2 "const_int_operand" ""))
                (match_operand:QI 3 "const_int_operand" "")))]
  ""
  {
    tms9900_debug_operands ("*movhi_combine_consts", insn, operands, 3);
    operands[1] = GEN_INT(((INTVAL(operands[1]) & 0xFF) << 8) |
                           (INTVAL(operands[3]) & 0xFF));
    return "li   %0, %1";
  }
  [(set_attr "length" "4")])


;; TODO will this help the case where char c = (int) x >> 8; ??

(define_insn "*movqi_for_initializer"
  [(set (match_operand:QI 0 "memory_operand" "=rR>,Q")
        (subreg:QI (ashiftrt:HI (match_operand:HI 1 "register_operand" "r,r")
                              (match_operand:HI 2 "const_int_operand" "i,i")) 1))]
  ""
  {
    tms9900_debug_operands ("*movqi_for_initializer", insn, operands, 3);
    if(INTVAL(operands[2]) == 8)
    {
      output_asm_insn("movb %1, %0", operands);
    }
    else if(INTVAL(operands[2]) == 0)
    {
      output_asm_insn("swpb %1", operands);
      output_asm_insn("movb %1, %0", operands);
    }
   return("");
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------------------------------------
;; Optimization for memory-to-memory copies
;; Combine a mem-reg-mem copy into a mem-mem copy
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
        (match_operand:HI 1 "memory_operand" ""))
   (set (match_operand:HI 2 "memory_operand" "")
        (match_dup 0))]
  "peep2_reg_dead_p(2, operands[0])"
  [(set (match_operand:HI 2 "memory_operand" "")
        (match_operand:HI 1 "memory_operand" ""))]
  {
    tms9900_debug_operands ("peep-mov-mem-mem", NULL_RTX, operands, 3);
  }
)

   
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "memory_operand" ""))
   (set (match_operand:QI 2 "memory_operand" "")
        (match_dup 0))]
  "peep2_reg_dead_p(2, operands[0])"
  [(set (match_operand:QI 2 "memory_operand" "")
        (match_operand:QI 1 "memory_operand" ""))]
  {
    tms9900_debug_operands ("peep-movqi-mem-mem", NULL_RTX, operands, 3);
  }
)


(define_insn "*andi_const"
  [(set (match_operand:HI 0 "register_operand" "")
        (and:HI (match_dup 0)
                (match_operand:HI 1 "const_int_operand" "")))]
  ""
  {
    tms9900_debug_operands ("*andi_const", insn, operands, 3);
    int val = INTVAL(operands[1]) & 0xFFFF;
    if(val == 0)
      return "clr  %0";
    else if(val == 0xFFFF)
      return "";
    else
      return "andi %0, %1";
  }
  [(set_attr "length" "4")])

