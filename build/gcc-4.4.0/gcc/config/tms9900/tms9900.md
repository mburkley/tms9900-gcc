;; This file is part of GCC.

;; GCC is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.

;; GCC is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GCC; see the file COPYING3.  If not see
;; <http://www.gnu.org/licenses/>.

;; SI is 32 bit
;; HI is 16 bit
;; QI is 8 bit 

;; Description of class IDs
;;   'C  is for CRU register
;;   'I' is for 32-bit value xxxx0000
;;   'J' is for 32-bit value 0000xxxx
;;   'K' is for 32-bit value xxxxxxxx
;;   'L' is for 2 or -2
;;   'M' is for -1
;;   'N' is for 1
;;   'O' is for 0
;;   'P' is for 00FF
;;   'Q' is for memory references that need an extra word after the opcode.
;;   'R' is for memory references which are encoded within the opcode.
;;   'S' is for shift register
;;   'T' Class of all registers
;;    U?
;;    W?

;;- See file "rtl.def" for documentation on define_insn, match_*, et. al.

;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code
;;- updates for most instructions.

;;- Operand classes for the register allocator:

;; Compare instructions.


;; define attributes
;; currently type is only fpu or arith or unknown, maybe branch later ?
;; default is arith
(define_attr "type" "unknown,arith,fp" (const_string "arith"))

;; length default is 1 word each
(define_attr "length" "" (const_int 1))

;; a user's asm statement
(define_asm_attributes
  [(set_attr "type" "unknown")
; all bets are off how long it is - make it 256, forces long jumps 
; whenever jumping around it !!!
   (set_attr "length" "256")])

;;-------------------------------------------------------------------
;;  UNSPEC Definitions
;;-------------------------------------------------------------------
(define_constants
  [(UNSPEC_RETURN  0)])


;;-------------------------------------------------------------------
;;  Predicate Definitions
;;-------------------------------------------------------------------

(define_predicate "shift_count_operand"
  (ior (match_code "const_int")
       (match_code "reg")))


;;-------------------------------------------------------------------
;;  Function Calls
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Jump to a subroutine which returns a value
(define_insn "call"
  [(call (match_operand:HI 0 "general_operand" "rR,Q")
         (match_operand:HI 1 "general_operand"  "g,g"))
  ]
  ""
  {
    if(SIBLING_CALL_P(insn))
      output_asm_insn("b    %0", operands);
    else
      output_asm_insn("bl   %0", operands);
    return("");
  }
  [(set_attr "length" "2,4")]
)


;-------------------------------------------------------------------
; Jump to a subroutine which returns a value
(define_insn "call_value"
  [(set (match_operand 0 "" "")
        (call (match_operand:HI 1 "general_operand" "rR,Q")
	      (match_operand:HI 2 "general_operand" "g,g")))
  ]
  ""
  {
    if(SIBLING_CALL_P(insn))
      output_asm_insn("b    %1", operands);
    else
      output_asm_insn("bl   %1", operands);
    return("");
  }
  [(set_attr "length" "2,4")]
)


;;-------------------------------------------------------------------
;; Define function prologue
(define_expand "prologue"
  [(const_int 0)]
  ""
{
  tms9900_expand_prologue();
  DONE;
})


;;-------------------------------------------------------------------
;; Define function epilogue
(define_expand "epilogue"
  [(return)]
  ""
{
  tms9900_expand_epilogue(false);
  DONE;
})

(define_expand "sibcall_epilogue"
  [(return)]
  ""
{
  tms9900_expand_epilogue(true);
  DONE;
})


;;-------------------------------------------------------------------
;; Define function return
(define_insn "*rt"
  [(unspec [(match_operand:HI 0 "general_operand" "")] UNSPEC_RETURN)]
  ""
  "b    *r11"
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;;  Comparison Instructions
;;-------------------------------------------------------------------


;; MGB TODO replace with mov unless immediate
;;-------------------------------------
(define_insn "tsthi"
  [(set (cc0)
	(match_operand:HI 0 "register_operand" "r"))]
  ""
  {
    return("ci   %0, 0");
  }
  [(set_attr "length" "4")])


;;-------------------------------------
;; TODO commented out for now - causes compiler assert
;; MGB TODO replace with mov unless immediate
;;-------------------------------------
; (define_insn "tstqi"
;   [(set (cc0)
; 	(match_operand:QI 0 "nonimmediate_operand" "rR,Q"))]
;   ""
;   {
;     output_asm_insn("jeq  0",       operands);  /* +0: No-op instruction with zero at +1 */
;     output_asm_insn("cb  %0, @$-1", operands);  /* +2: Compare value against the zero at +1 */
;     return("");
;   }
;   [(set_attr "length" "4,6")])
 

;;-------------------------------------
(define_insn "cmphi"
  [(set (cc0)
	(compare (match_operand:HI 0 "nonimmediate_operand" "rR,rR,Q,Q,r")
		 (match_operand:HI 1 "general_operand"      "rR,Q,rR,Q,i")))]
  ""
  {
    if (which_alternative == 4)
    {
       return("ci   %0, %1");
    }
    return("c    %0, %1");
  }
  [(set_attr "length" "2,4,4,6,4")])


;; MGB TODO add option for immediate
;;-------------------------------------
(define_insn "cmpqi"
  [(set (cc0)
	(compare (match_operand:QI 0 "nonimmediate_operand" "rR,rR,Q,Q")
		 (match_operand:QI 1 "nonimmediate_operand" "rR,Q,rR,Q")))]
  ""
  "cb   %0, %1"
  [(set_attr "length" "2,4,4,6")])


;;-------------------------------------------------------------------
;;  Branch Instructions
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Jump if equal
(define_insn "beq"
  [(set (pc)
	(if_then_else (eq (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  {
    return(output_branch("jeq", "jne", get_attr_length(insn)));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if equal, reversed comparison operands
(define_insn "*beq_reversed"
  [(set (pc)
	(if_then_else (eq (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  {
    return(output_branch("jne", "jeq", get_attr_length(insn)));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if not equal
(define_insn "bne"
  [(set (pc)
	(if_then_else (ne (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "* return output_branch(\"jne\", \"jeq\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if not equal, reversed comparison operands
(define_insn "*bne_reversed"
  [(set (pc)
	(if_then_else (ne (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "* return output_branch(\"jeq\", \"jne\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if unsigned less than
(define_insn "bltu"
  [(set (pc)
	(if_then_else (ltu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "* return output_branch(\"jl\", \"jhe\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if unsigned less than, reversed comparison operands
(define_insn "*bltu_reversed"
  [(set (pc)
	(if_then_else (ltu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "* return output_branch(\"jhe\", \"jl\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if unsigned less than or equal
(define_insn "bleu"
  [(set (pc)
	(if_then_else (leu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "* return output_branch(\"jle\", \"jh\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if unsigned less than or equal, reversed comparison operands
(define_insn "*bleu_reversed"
  [(set (pc)
	(if_then_else (leu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "* return output_branch(\"jh\", \"jle\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if unsigned greater than
(define_insn "bgtu"
  [(set (pc)
	(if_then_else (gtu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "* return output_branch(\"jh\", \"jle\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if unsigned greater than, reversed comparison operands
(define_insn "*bgtu_reversed"
  [(set (pc)
	(if_then_else (gtu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "* return output_branch(\"jle\", \"jh\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if unsigned greater than or equal
(define_insn "bgeu"
  [(set (pc)
	(if_then_else (geu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "* return output_branch(\"jhe\", \"jl\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if unsigned greater than or equal, reversed comparison operands
(define_insn "*bgeu_reversed"
  [(set (pc)
	(if_then_else (geu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "* return output_branch(\"jl\", \"jhe\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if less than
(define_insn "blt"
  [(set (pc)
	(if_then_else (lt (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "* return output_branch(\"jlt\", \"GE\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 18)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if less than, reversed comparison operands
; Was commented out
(define_insn "*blt_reversed"
  [(set (pc)
	(if_then_else (lt (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "* return output_branch(\"GE\", \"jlt\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 14)))])


;;-------------------------------------------------------------------
;; Jump if less than or equal
(define_insn "ble"
  [(set (pc)
	(if_then_else (le (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "* return output_branch(\"LE\", \"jgt\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 14)))])


;;-------------------------------------
;; Jump if less than or equal, reversed comparison operands
(define_insn "*ble_reversed"
  [(set (pc)
	(if_then_else (le (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "* return output_branch(\"jgt\", \"LE\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 18)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if greater than
(define_insn "bgt"
  [(set (pc)
	(if_then_else (gt (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "* return output_branch(\"jgt\", \"LE\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 18)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if greater than, reversed comparison operands
; Was commented out
(define_insn "*bgt_reversed"
  [(set (pc)
	(if_then_else (gt (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "* return output_branch(\"LE\", \"jgt\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 14)))])


;;-------------------------------------------------------------------
;; Jump if greater than or equal
; Was commented out
(define_insn "bge"
  [(set (pc)
	(if_then_else (ge (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "* return output_branch(\"GE\", \"jlt\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 14)))])


;;-------------------------------------
;; Jump if greater than or equal, reversed comparison operands
(define_insn "*bge_reversed"
  [(set (pc)
	(if_then_else (ge (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "* return output_branch(\"jlt\", \"GE\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 18)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;;  Jump Operations
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Unconditional jump to label
(define_insn "jump"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  ""
  "*
  return output_jump(get_attr_length(insn));"

  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 14)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Unconditional jump using pointer
(define_insn "indirect_jump"
  [(set (pc) (match_operand:HI 0 "nonimmediate_operand" "r,Q"))]
  ""
  "b    %0"
  [(set_attr "length" "2,4")])


;;-------------------------------------------------------------------
;; Unconditional jump using jump table
(define_insn "tablejump"
  [(clobber (match_scratch:HI 2 "=r,r"))
   (set (pc) (match_operand:HI 0 "nonimmediate_operand" "rR,Q"))
   (use (label_ref (match_operand 1 "" "")))]
  ""
  {
    output_asm_insn("mov  %0, %2", operands);
    output_asm_insn("b    *%2",    operands);
    return(""); 
  }
  [(set_attr "length" "4,6")])


;;-------------------------------------------------------------------
;;  Bit Shift Operations
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Arithmetic shift left


;;-------------------------------------
(define_insn "ashlsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(ashift:SI (match_operand:SI 1 "register_operand" "0,0")
		   (match_operand:HI 2 "shift_count_operand" "S,i")))
   (clobber (match_scratch:HI 3 "=&r,&r"))]
     ""
  {
    rtx ops[7];
    ops[0] = operands[0];  /* Destination */
    ops[1] = operands[1];  /* Source */
    ops[2] = operands[2];  /* Shift count */
    ops[3] = operands[3];  /* Scratch reg */
    ops[4] = gen_rtx_REG (HImode, REGNO (operands[0]) + REGS_PER_WORD);  /* Low word of source */
    if(which_alternative == 0)
    {
      /* Variable shift */
      output_asm_insn("ci   %2, 16",  ops);  /* +0: Compare shift to 16 */
      output_asm_insn("jlt  $+12",    ops);  /* +4: If shift was < 16, goto lt_16 */
      output_asm_insn("jeq  $+4",     ops);  /* +6: If shift was 16, goto eq_16 */
     
      /* Shift count greater than 16 */
      output_asm_insn("sla  %4, %2",  ops);  /* +8: Shift low word */

      /* eq_16: Shift count equals 16 */
      output_asm_insn("mov  %4, %1",  ops);  /* +10: Copy low word to high word */ 
      output_asm_insn("clr  %4",      ops);  /* +12: Clear low word */
      output_asm_insn("jmp  $+20",    ops);  /* +14: Goto end */

      /* lt_16: Shift count less than 16 */
      output_asm_insn("abs  %2",      ops);  /* +16: Test shift count */
      output_asm_insn("jeq  $+16",    ops);  /* +18: If shift==0, goto end */
      output_asm_insn("mov  %4, %3",  ops);  /* +20: Save low word to temp */
      output_asm_insn("sla  %1, %2",  ops);  /* +22: Shift high word */
      output_asm_insn("sla  %4, %2",  ops);  /* +24: Shift low word */
      output_asm_insn("neg  %2",      ops);  /* +26: Get complement of shift count */
      output_asm_insn("srl  %3, %2",  ops);  /* +28: Shift low word bits into high word position */
      output_asm_insn("soc  %3, %1",  ops);  /* +30: Merge shifted low word bits into high word */
      output_asm_insn("neg  %2",      ops);  /* +32: Restore shift count */
      /* +34: End */
    }
    else
    {
      /* Constant shift */
      int offset = INTVAL(operands[2]);
      ops[5] = GEN_INT(16-offset);  /* Complement of shift count */
      ops[6] = GEN_INT(offset%16);  /* Modulo of shift count */
  
      if(offset < 16)
      {
        if(offset == 8)
        {
          output_asm_insn("movb %4, %1",  ops);  /* Move MSB of high word */
          output_asm_insn("sb   %4, %4",  ops);  /* Clear MSB of high word */
          output_asm_insn("swpb %1",      ops);  /* Swap bytes in low word */
          output_asm_insn("swpb %4",      ops);  /* Swap bytes in high word */
        }
        else
        {
          output_asm_insn("mov  %4, %3", ops);  /* Save low word to temp */
          output_asm_insn("sla  %1, %2", ops);  /* Shift high word */
          output_asm_insn("sla  %4, %2", ops);  /* Shift low word */
          output_asm_insn("srl  %3, %5", ops);  /* Shift low word bits into high word position */
          output_asm_insn("soc  %3, %1", ops);  /* Merge low word bits into high word */
        }
      } 
      else
      {
        if(offset > 16)
        {
          output_asm_insn("sla  %4, %6", ops);  /* Shift low word */
        }
        output_asm_insn("mov  %4, %1", ops);  /* Move low word into high word */
        output_asm_insn("clr  %4",     ops);  /* Clear low word */
      }
    }
    return "";
  }
  [(set_attr "length" "34, 10")]
)


;;-------------------------------------
(define_insn "ashlhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(ashift:HI (match_operand:HI 1 "register_operand" "0,0")
		   (match_operand:HI 2 "shift_count_operand" "S,i")))]
  ""
  {
    if(which_alternative == 0)
    {
      output_asm_insn("abs  r0",     operands);
      output_asm_insn("jeq  $+4",    operands);
      output_asm_insn("sla  %0, 0",  operands);
    }
    else if(INTVAL(operands[2]) > 0)
    {
      output_asm_insn("sla  %0, %2", operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,2")])


;;-------------------------------------
(define_insn "ashlqi3"
  [(set (match_operand:QI 0 "register_operand" "=r,r")
	(ashift:QI (match_operand:QI 1 "register_operand" "0,0")
		   (match_operand:HI 2 "shift_count_operand" "S,i")))]
  ""
  {
    if(which_alternative == 0)
    {
      output_asm_insn("abs  r0",        operands);
      output_asm_insn("jeq  $+8",       operands);  /* If shift count is zero, do nothing */
      output_asm_insn("andi %0, >FF00", operands);
      output_asm_insn("sla  %0, 0",     operands);
    }
    else if(INTVAL(operands[2]) > 0)
    {
      output_asm_insn("andi %0, >FF00", operands);
      output_asm_insn("sla  %0, %2",    operands);
    }
    return(""); 
  }
  [(set_attr "length" "10,6")])


;;-------------------------------------------------------------------
;; Arithmetic shift left (for QI mode)

(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(sign_extend:HI(match_operand:QI 1 "register_operand" "r,r")))
   (set (match_operand:HI 2 "register_operand" "=r,r")
	(ashift:HI (match_dup 0)
                   (plus:HI (match_operand:HI 3 "const_int_operand" "i,i")
                            (match_operand:HI 4 "const_int_operand" "i,i"))))]
  ""
  [(set (match_dup 2)
        (match_dup 1))
   (set (match_dup 2)
        (ashift:QI (match_dup 2)
                   (match_dup 3)))]
  "")


;; TODO MGB tidy up
;;-------------------------------------------------------------------
;; Arithmetic shift right

(define_insn "ashrsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(ashiftrt:SI (match_operand:SI 1 "register_operand" "0,0")
		     (match_operand:HI 2 "shift_count_operand" "S,i")))
   (clobber (match_scratch:HI 3 "=&r,&r"))]
     ""
  {
    rtx ops[7];
    ops[0] = operands[0];  /* Destination */
    ops[1] = operands[1];  /* Source */
    ops[2] = operands[2];  /* Shift count */
    ops[3] = operands[3];  /* Scratch reg */
    ops[4] = gen_rtx_REG (HImode, REGNO (operands[0]) + REGS_PER_WORD);  /* Low word of source */
    if(which_alternative == 0)
    {
      /* Variable shift */
      output_asm_insn("ci   %2, 16",  ops);  /* +0: Compare shift to 16 */
      output_asm_insn("jlt  $+16",    ops);  /* +4: If shift was < 16, goto lt_16 */
      output_asm_insn("jeq  $+4",     ops);  /* +6: If shift was 16, goto eq_16 */

      /* Shift count greater than 16 */
      output_asm_insn("sra  %1, %2",  ops);  /* +8: Shift high word */

      /* eq_16: Shift count equals 16 */
      output_asm_insn("mov  %1, %4",  ops);  /* +10: Copy high word to low word */ 
      output_asm_insn("seto %1",      ops);  /* +12: Assume negative value, set high word */
      output_asm_insn("jlt  $+4",     ops);  /* +14: If value was negative, skip next instruction */
      output_asm_insn("clr  %1",      ops);  /* +16: Clear high word */
      output_asm_insn("jmp  $+20",    ops);  /* +18: Goto end */

      /* lt_16: Shift count less than 16 */
      output_asm_insn("abs  %2",      ops);  /* +20: Test shift count */
      output_asm_insn("jeq  $+16",    ops);  /* +22: If shift==0, goto end */
      output_asm_insn("mov  %4, %3",  ops);  /* +24: Save high word to temp */
      output_asm_insn("sra  %1, %2",  ops);  /* +26: Shift high word */
      output_asm_insn("srl  %4, %2",  ops);  /* +28: Shift low word */
      output_asm_insn("neg  %2",      ops);  /* +30: Get complement of shift count */
      output_asm_insn("sla  %3, %2",  ops);  /* +32: Shift high word bits into low word position */
      output_asm_insn("soc  %3, %4",  ops);  /* +34: Merge shifted high word bits into low word */
      output_asm_insn("neg  %2",      ops);  /* +36: Restore shift count */
      /* +38: End */
    }
    else
    {
      /* Constant shift */
      int offset = INTVAL(operands[2]);
      ops[5] = GEN_INT(16-offset);  /* Complement of shift count */
      ops[6] = GEN_INT(offset%16);  /* Modulo of shift count */
  
      if(offset < 16)
      {
        output_asm_insn("mov  %1, %3",  ops);  /* Save high word to temp */
        output_asm_insn("sra  %1, %6",  ops);  /* Shift high word */
        output_asm_insn("srl  %4, %6",  ops);  /* Shift low word */
        output_asm_insn("sla  %3, %5",  ops);  /* Shift high word bits into low word position */
        output_asm_insn("soc  %3, %4",  ops);  /* Merge shifted high word bits into low word */
      } 
      else
      {
        if(offset > 16)
        {
          output_asm_insn("sra  %1, %6", ops);  /* Shift high word */
        }
        output_asm_insn("mov  %1, %4",  ops);  /* Copy high word to low word */ 
        output_asm_insn("seto %1",      ops);  /* Assume negative value, set high word */
        output_asm_insn("jlt  $+4",     ops);  /* If value was negative, skip next instruction */
        output_asm_insn("clr  %1",      ops);  /* Clear high word */
      }
    }
    return "";
  }
  [(set_attr "length" "38, 10")]
)


;;-------------------------------------
(define_insn "ashrhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(ashiftrt:HI (match_operand:HI 1 "register_operand" "0,0")
		     (match_operand:HI 2 "shift_count_operand" "S,i")))]
  ""
  {
    if(which_alternative == 0)
    {
      output_asm_insn("abs  r0",     operands);
      output_asm_insn("jeq  $+4",    operands);
      output_asm_insn("sra  %0, 0",  operands);
    }
    else if(INTVAL(operands[2]) > 0)
    {
      output_asm_insn("sra  %0, %2", operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,2")])


;;-------------------------------------
(define_insn "ashrqi3"
  [(set (match_operand:QI 0 "register_operand" "=r,r")
	(ashiftrt:QI (match_operand:QI 1 "register_operand" "0,0")
		     (match_operand:HI 2 "shift_count_operand" "S,i")))]
  ""
  {
    if(which_alternative == 0)
    {
      output_asm_insn("abs  r0",        operands);
      output_asm_insn("jeq  $+4",       operands);
      output_asm_insn("sra  %0, 0",     operands);
    }
    else if(INTVAL(operands[2]) > 0)
    {
      output_asm_insn("sra  %0, %2",    operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,2")])


;;-------------------------------------
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "r,r")
	(sign_extend:HI(match_operand:QI 1 "register_operand" "r,r")))
   (set (match_operand:HI 3 "register_operand" "r,r")
	(ashiftrt:HI (match_operand:HI 4 "register_operand" "0,0")
		     (match_operand:HI 5 "shift_count_operand" "S,i")))
   (set (match_operand:QI 6 "register_operand" "r,r")
        (subreg:QI (match_operand:HI 7 "register_operand" "3,3") 1))]
  ""
  [(set (match_dup 6)
        (match_dup 1))
   (set (match_dup 6)
        (ashiftrt:QI (match_dup 6)
                     (match_dup 5)))]
  "")


;;-------------------------------------------------------------------
;; Logical shift right


;;-------------------------------------
(define_insn "lshrsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(lshiftrt:SI (match_operand:SI 1 "register_operand" "0,0")
		     (match_operand:HI 2 "shift_count_operand" "S,i")))
   (clobber (match_scratch:HI 3 "=&r,&r"))]
     ""
  {
    rtx ops[7];
    ops[0] = operands[0];  /* Destination */
    ops[1] = operands[1];  /* Source */
    ops[2] = operands[2];  /* Shift count */
    ops[3] = operands[3];  /* Scratch reg */
    ops[4] = gen_rtx_REG (HImode, REGNO (operands[0]) + REGS_PER_WORD);  /* Low word of source */
    if(which_alternative == 0)
    {
      /* Variable shift */
      output_asm_insn("ci   %2, 16",  ops);  /* +0: Compare shift to 16 */
      output_asm_insn("jlt  $+12",    ops);  /* +4: If shift was < 16, goto lt_16 */
      output_asm_insn("jeq  $+4",     ops);  /* +6: If shift was 16, goto eq_16 */

      /* Shift count greater than 16 */
      output_asm_insn("srl  %1, %2",  ops);  /* +8: Shift high word */

      /* eq_16: Shift count equals 16 */
      output_asm_insn("mov  %1, %4",  ops);  /* +10: Copy high word to low word */ 
      output_asm_insn("clr  %1",      ops);  /* +12: Clear high word */
      output_asm_insn("jmp  $+20",    ops);  /* +14: Goto end */

      /* lt_16: Shift count less than 16 */
      output_asm_insn("abs  %2",      ops);  /* +16: Test shift count */
      output_asm_insn("jeq  $+16",    ops);  /* +18: If shift==0, goto end */
      output_asm_insn("mov  %1, %3",  ops);  /* +20: Save high word to temp */
      output_asm_insn("srl  %1, %2",  ops);  /* +22: Shift high word */
      output_asm_insn("srl  %4, %2",  ops);  /* +24: Shift low word */
      output_asm_insn("neg  %2",      ops);  /* +26: Get complement of shift count */
      output_asm_insn("sla  %3, %2",  ops);  /* +28: Shift high word bits into low word position */
      output_asm_insn("soc  %3, %4",  ops);  /* +30: Merge shifted high word bits into low word */
      output_asm_insn("neg  %2",      ops);  /* +32: Restore shift count */
      /* +34: End */
    }
    else
    {
      /* Constant shift */
      int offset = INTVAL(operands[2]);
      ops[5] = GEN_INT(16-offset);  /* Complement of shift count */
      ops[6] = GEN_INT(offset%16);  /* Modulo of shift count */
  
      if(offset < 16)
      {
        if(offset == 8)
        {
          output_asm_insn("swpb %1",      ops);  /* Swap bytes in low word */
          output_asm_insn("swpb %4",      ops);  /* Swap bytes in high word */
          output_asm_insn("movb %1, %4",  ops);  /* Move MSB of high word */
          output_asm_insn("sb   %1, %1",  ops);  /* Clear MSB of high word */
        }
        else
        {
          output_asm_insn("mov  %1, %3",  ops);  /* Save high word to temp */
          output_asm_insn("srl  %1, %6",  ops);  /* Shift high word */
          output_asm_insn("srl  %4, %6",  ops);  /* Shift low word */
          output_asm_insn("sla  %3, %5",  ops);  /* Shift high word bits into low word position */
          output_asm_insn("soc  %3, %4",  ops);  /* Merge shifted high word bits into low word */
        }
      } 
      else
      {
        if(offset > 16)
        {
          output_asm_insn("srl  %1, %6", ops);  /* Shift high word */
        }
        output_asm_insn("mov  %1, %4",  ops);  /* Copy high word to low word */ 
        output_asm_insn("clr  %1",      ops);  /* Clear high word */
      }
    }
    return "";
  }
  [(set_attr "length" "34, 10")]
)


;;-------------------------------------
(define_insn "lshrhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(lshiftrt:HI (match_operand:HI 1 "register_operand" "0,0")
		     (match_operand:HI 2 "shift_count_operand" "S,i")))]
  ""
  {
    if(which_alternative == 0)
    {
      output_asm_insn("abs  r0",     operands);
      output_asm_insn("jeq  $+4",    operands);
      output_asm_insn("srl  %0, 0",  operands);
    }
    else if(INTVAL(operands[2]) > 0)
    {
      output_asm_insn("srl  %0, %2", operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,2")])


;;-------------------------------------
(define_insn "lshrqi3"
  [(set (match_operand:QI 0 "register_operand" "=r,r")
	(lshiftrt:QI (match_operand:QI 1 "register_operand" "0,0")
		     (match_operand:HI 2 "shift_count_operand" "S,i")))]
  ""
  {
    if(which_alternative == 0)
    {
      output_asm_insn("abs  r0",        operands);
      output_asm_insn("jeq  $+4",       operands);
      output_asm_insn("srl  %0, 0",     operands);
    }
    else if(INTVAL(operands[2]) > 0)
    {
      output_asm_insn("srl  %0, %2",    operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,2")])


(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "r,r")
	(sign_extend:HI(match_operand:QI 1 "register_operand" "r,r")))
   (set (match_operand:HI 3 "register_operand" "r,r")
	(lshiftrt:HI (match_operand:HI 4 "register_operand" "0,0")
		     (match_operand:HI 5 "shift_count_operand" "S,i")))
   (set (match_operand:QI 6 "register_operand" "r,r")
        (subreg:QI (match_operand:HI 7 "register_operand" "3,3") 1))]
  ""
  [(set (match_dup 6)
        (match_dup 1))
   (set (match_dup 6)
        (lshiftrt:QI (match_dup 6)
                     (match_dup 5)))]
  "")
      


;;-------------------------------------------------------------------
;; Rotate 


;;-------------------------------------
(define_expand "rotlhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (rotatert:HI (match_operand:HI 1 "register_operand" "0,0")
                     (match_operand:HI 2 "shift_count_operand" "S,i")))]
  ""
  {
    if (GET_CODE (operands[2]) == CONST_INT)
      operands[2] = GEN_INT ((16 - INTVAL (operands[2])) % 16);
    else
      {
        rtx reg = gen_reg_rtx (HImode);
        emit_insn (gen_subhi3 (reg, GEN_INT (16), operands[2]));
        operands[2] = reg;
      }
  })


;;-------------------------------------
(define_insn "rotrhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (rotatert:HI (match_operand:HI 1 "register_operand" "0,0")
                     (match_operand:HI 2 "shift_count_operand" "S,i")))]
  ""
  "@
  src  %0, 0
  src  %0, %2" 
 [(set_attr "length" "2,2")])


;;-------------------------------------------------------------------
;;  Bitwise Operations
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; And


;;-------------------------------------
(define_insn "andhi3"
  [(clobber (match_scratch:HI 3 "=r,r,r,r,r,r,r"))
   (set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q,r,R>,Q")
	(and:HI (match_operand:HI 1 "nonimmediate_operand" "0,0,0,0,0,0,0")
		(match_operand:HI 2 "general_operand" "rR>,Q,rR>,Q,i,i,i")))]
  ""
  {
    if(which_alternative >= 4)
    {
      int val = INTVAL(operands[2]) & 0xFFFF;
      if(val == 0)
      {
        /* Result will be zero */
        output_asm_insn("clr  %0", operands);
      }
      else if(val == 0xFFFF)
      {
        /* No operation required */
        return("");
      }
      else if(which_alternative == 4)
      {
        /* AND const value and register */
        output_asm_insn("andi %0, %2", operands);
      }
      else if(which_alternative >= 5)
      {
        /* AND const value and memory */
        operands[2] = GEN_INT(~val);
        output_asm_insn("li   %3, %2", operands);
        output_asm_insn("szc  %3, %0", operands);
      }
    }
    else
    {
      /* AND against non-const value */
      if(!rtx_equal_p(operands[2], operands[3]))
      {
        output_asm_insn("mov  %2, %3", operands);
      }
      output_asm_insn("inv  %3",     operands);
      output_asm_insn("szc  %3, %0", operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,8,8,10,4,6,8")])


(define_insn "*andnothi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
	(and:HI (match_operand:HI 1 "nonimmediate_operand" "0,0,0,0")
		(not:HI (match_operand:HI 2 "nonimmediate_operand" "rR>,Q,rR>,Q"))))]
  ""
  "szc  %2, %0"
  [(set_attr "length" "2,4,4,6")])


; This handles reverse-order not-and combinations
(define_insn "*not_andhi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
	(and:HI (not:HI (match_operand:HI 1 "nonimmediate_operand" "rR>,Q,rR>,Q"))
                (match_operand:HI 2 "nonimmediate_operand" "0,0,0,0")))]
  ""
  "szc  %1, %0"
  [(set_attr "length" "2,4,4,6")])


;;-------------------------------------
(define_insn "andqi3"
  [(clobber (match_scratch:QI 3 "=r,r,r,r,r,r,r"))
   (set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q,r,R>,Q")
	(and:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0,0,0,0")
		(match_operand:QI 2 "general_operand" "rR>,Q,rR>,Q,i,i,i")))]
  ""
  {
    if(which_alternative >= 4)
    {
      int val = INTVAL(operands[2]) & 0xFF;
      if(which_alternative == 4)
      {
        /* AND const value and register */
        if(val == 0)
          output_asm_insn("clr  %0", operands);
        else if(val == 0xff)
          return("");
        else
        {
          operands[2] = GEN_INT(val*256);
          output_asm_insn("andi %0, %2", operands);
        }
      }
      else if(which_alternative >= 5)
      {
        /* AND const value and memory */
        if(val == 0)
          output_asm_insn("sb %0 %0", operands);
        else if(val == 0xff)
          return("");
        else
        {
          operands[2] = GEN_INT((~val)*256);
          output_asm_insn("li   %3, %2", operands);
          output_asm_insn("szc  %3, %0", operands);
        }
      }
    }
    else
    {
      /* AND against non-const value */
      if(!rtx_equal_p(operands[2], operands[3]))
      {
        output_asm_insn("movb %2, %3", operands);
      }
      output_asm_insn("inv  %3",     operands);
      output_asm_insn("szcb %3, %0", operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,8,8,10,4,6,8")])


(define_insn "*andnotqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
	(and:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0")
		(not:QI (match_operand:QI 2 "nonimmediate_operand" "rR>,Q,rR>,Q"))))]
  ""
  "szcb %2, %0"
  [(set_attr "length" "2,4,4,6")])


; This handles reverse-order not-and combinations
(define_insn "*not_andqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
	(and:QI (not:QI (match_operand:QI 1 "nonimmediate_operand" "rR>,Q,rR>,Q"))
                (match_operand:QI 2 "nonimmediate_operand" "0,0,0,0")))]
  ""
  "szcb %1, %0"
  [(set_attr "length" "2,4,4,6")])


;;-------------------------------------------------------------------
;; Or


;;-------------------------------------
(define_insn "iorhi3"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q,r,r")
	(ior:HI (match_operand:HI 1 "nonimmediate_operand" "%0,0,0,0,0,0")
		(match_operand:HI 2 "general_operand" "rR>,Q,rR>,Q,i,M")))]
  ""
  {
    if (GET_CODE (operands[2]) == CONST_INT)
      {
        int val = INTVAL(operands[2]) & 0xFFFF;
        if(val == 0xFFFF)
          return "seto %0";
        else if(val == 0)
          return "";
        else
          return "ori  %0, %2";
      }
    return "soc  %2, %0";
  }
  [(set_attr "length" "2,4,4,6,4,2")])


;;-------------------------------------
(define_insn "iorqi3"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q,r")
	(ior:QI (match_operand:QI 1 "nonimmediate_operand" "%0,0,0,0,0")
		(match_operand:QI 2 "general_operand" "rR>,Q,rR>,Q,i")))]
  ""
  {
    if (GET_CODE (operands[2]) == CONST_INT)
    {
      int val = INTVAL(operands[2]) & 0xFF;
      operands[2] = GEN_INT(val * 256);
      if(val == 0xFF)
        return "seto %0";
      else if(val == 0)
        return "";
      else
        return("ori  %0, %2");
    }
    return("socb %2, %0");
  }
  [(set_attr "length" "2,4,4,6,4")])


;;-------------------------------------------------------------------
;; Xor


;;-------------------------------------
(define_insn "xorhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(xor:HI (match_operand:HI 1 "register_operand" "%0,0")
		(match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  "xor  %2, %0"
  [(set_attr "length" "2,4")])


;;-------------------------------------
(define_insn "xorqi3"
  [(set (match_operand:QI 0 "register_operand" "=r,r")
	(xor:QI (match_operand:QI 1 "register_operand" "%0,0")
		(match_operand:QI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  "xor  %2, %0"
  [(set_attr "length" "2,4")])


;;-------------------------------------------------------------------
;; Not


;;-------------------------------------
(define_insn "one_cmplhi2"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
        (not:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))]
  ""
  "inv  %0"
  [(set_attr "length" "2,4")])


;;-------------------------------------
(define_insn "one_cmplqi2"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,Q")
        (not:QI (match_operand:QI 1 "nonimmediate_operand" "0,0")))]
  ""
  "inv  %0"
  [(set_attr "length" "2,4")])


;;-------------------------------------------------------------------
;;  Arithmetic Operations
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Add

;;-------------------------------------
(define_insn "addsi3"
  [(set (match_operand:SI 0 "nonimmediate_operand"          "=r,r,r,r,r,r, R,R,R,R,R,R, Q,Q,Q,Q,Q,Q")
	(plus:SI (match_operand:SI 1 "nonimmediate_operand" "%0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0")
		 (match_operand:SI 2 "general_operand"       "r,R,Q,I,J,K, r,R,Q,I,J,K, r,R,Q,I,J,K")))
   (clobber (match_scratch:HI 3                             "=r,r,r,r,r,r, r,r,r,r,r,r, r,r,r,r,r,r"))]
  ""
  { 
    rtx low_words[4];
    rtx offset[3];
    low_words[3] = operands[3];

    if(REG_P (operands[0]))
      low_words[0] = gen_rtx_REG (HImode, REGNO (operands[0]) + REGS_PER_WORD);
    else
      low_words[0] = adjust_address (operands[0], HImode, 2);

    if(which_alternative >= 12)
      offset[0] = GEN_INT(6);
    else
      offset[0] = GEN_INT(4);
  
    if(! CONSTANT_P(operands[2]))
    {
      /* Adding two variables */
      if(REG_P (operands[2]))
        low_words[2] = gen_rtx_REG (HImode, REGNO (operands[2]) + REGS_PER_WORD);
      else
        low_words[2] = adjust_address (operands[2], HImode, 2);

      output_asm_insn("a    %2, %0", operands);
      output_asm_insn("a    %2, %0", low_words);
      output_asm_insn("jnc  $+%0",   offset);
      output_asm_insn("inc  %0",     operands);
      return("");
    }
    else
    {
      /* Adding a constant */
      int low_const  =  INTVAL(operands[2])        & 0xffff;
      int high_const = (INTVAL(operands[2]) >> 16) & 0xffff;
      low_words[2] = GEN_INT(low_const);
      operands[2]  = GEN_INT(high_const);

      if(low_const != 0)
      {
        switch(low_const)
        {
          case 0xFFFE: output_asm_insn("dect %0",     low_words); break;
          case 0xFFFF: output_asm_insn("dec  %0",     low_words); break;
          case      1: output_asm_insn("inc  %0",     low_words); break;
          case      2: output_asm_insn("inct %0",     low_words); break;
          default:
            if(REG_P(operands[0]))
              output_asm_insn("ai   %0, %2", low_words);
            else
            {
              output_asm_insn("li   %3, %2", low_words);              
              output_asm_insn("a    %3, %0", low_words);              
            }
        }
        /* DEC and DECT use inverted carry flags */
        /*
        if(low_const == 0xFFFF || low_const == 0xFFFE)
          output_asm_insn("joc  $+%0",   offset);
        else
        */
          output_asm_insn("jnc  $+%0",   offset);

        /* Handle carry to high word */
        output_asm_insn("inc  %0",     operands);
      }
      if(high_const != 0)
      {
        switch(high_const)
        {
          case 0xFFFE: output_asm_insn("dect %0",     operands); break;
          case 0xFFFF: output_asm_insn("dec  %0",     operands); break;
          case      1: output_asm_insn("inc  %0",     operands); break;
          case      2: output_asm_insn("inct %0",     operands); break;
          default:
            if(REG_P(operands[0]))
              output_asm_insn("ai   %0, %2", operands);
            else
            {
              output_asm_insn("li   %3, %2", operands);              
              output_asm_insn("a    %3, %0", operands);              
            }
        }
      }
    }

    return("");
  }
  [(set_attr "length" "8,10,14,4,8,12, 10,12,16,6,12,16,  14,16,18,8,16,20")])


;;-------------------------------------
(define_insn "addhi3"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q,r,rR>,Q")
	(plus:HI (match_operand:HI 1 "nonimmediate_operand" "%0,0,0,0,0")
		 (match_operand:HI 2 "general_operand" "rR>LMNO,rR>LNMO,i,Q,Q")))]
  ""
  {
    switch(GET_CODE(operands[2]))
    {
      case CONST_INT:
      {
        if (INTVAL(operands[2]) == 1)
	  return("inc  %0");
        else if (INTVAL(operands[2]) == -1)
          return("dec  %0");
        else if (INTVAL(operands[2]) == 2)
          return("inct %0");
        else if (INTVAL(operands[2]) == -2)
          return("dect %0");
        else
          return("ai   %0, %2");
      }

      case MEM:
      case REG:
        return ("a    %2, %0");

      default:
          return("ai   %0, %2");
    }
  }
  [(set_attr "length" "2,4,4,4,6")])


;;-------------------------------------
(define_insn "addqi3"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q,r")
	(plus:QI (match_operand:QI 1 "nonimmediate_operand" "%0,0,0,0,0")
		 (match_operand:QI 2 "general_operand" "rR>,Q,rR>,Q,i")))]
  ""
  {
  if (GET_CODE (operands[2]) == CONST_INT)
    {
      operands[2] = GEN_INT(INTVAL(operands[2]) * 256);
      return("ai   %0, %2");
    }
  return("ab   %2, %0");
  }
  [(set_attr "length" "2,4,4,6,4")])


;;-------------------------------------------------------------------
;; Subtract


;;-------------------------------------
(define_insn "subsi3"
  [(set (match_operand:SI 0 "nonimmediate_operand"          "=r,r,r,r,r,r,R,R,R,R,R,R,Q,Q,Q,Q,Q,Q")
	(minus:SI (match_operand:SI 1 "nonimmediate_operand" "0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0")
		  (match_operand:SI 2 "general_operand"      "r,R,Q,I,J,K,r,R,Q,I,J,K,r,R,Q,I,J,K")))]
  ""
  {
    rtx lateoperands[3];
    rtx offset[3];

    lateoperands[0] = operands[0];
    if(REG_P(operands[0]))
    {
      operands[0] = gen_rtx_REG(HImode, REGNO (operands[0]) + REGS_PER_WORD);
      offset[0] = GEN_INT(4);
    }
    else
    {
      operands[0] = adjust_address(operands[0], HImode, 2);
      offset[0] = GEN_INT(6);
    }
  
    if(! CONSTANT_P(operands[2]))
    {
      lateoperands[2] = operands[2];

      if(REG_P(operands[2]))
        operands[2] = gen_rtx_REG(HImode, REGNO (operands[2]) + REGS_PER_WORD);
      else
        operands[2] = adjust_address(operands[2], HImode, 2);

      output_asm_insn("s    %2, %0", lateoperands);
      output_asm_insn("s    %2, %0", operands);
      output_asm_insn("joc  $+%0", offset);
      output_asm_insn("dec  %0", lateoperands);
      return("");
    }
    /* EMW - This never seems to be called... */
    lateoperands[2] = GEN_INT((INTVAL(operands[2]) >> 16) & 0xffff);
    operands[2] = GEN_INT(INTVAL(operands[2]) & 0xffff);
  
    if(INTVAL(operands[2]))
    { 
      output_asm_insn("ai   %0, %2", operands);
      output_asm_insn("jnc  $+%0", offset);
      output_asm_insn("dec  %0", lateoperands);
    }
    if(INTVAL(lateoperands[2]))
    {
      operands[2] = GEN_INT(-INTVAL(operands[2]));
      output_asm_insn("ai   %0, %2", lateoperands);
    }
    return("");
  }
  [(set_attr "length" "8,10,12,4,8,12, 12,14,16,4,12,16,  16,18,18,6,12,18")])


;;-------------------------------------
(define_insn "subhi3"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q,rR>,Q,rR>,Q,rR>,Q")
	(minus:HI (match_operand:HI 1 "nonimmediate_operand" "0,0,0,0,rR>,rR>,Q,Q")
		  (match_operand:HI 2 "nonimmediate_operand" "rR>,rR>,Q,Q,0,0,0,0")))]
  ""
  {
    if(which_alternative < 4)
    {
      output_asm_insn("s    %2, %0",operands);
    }
    else
    {
      output_asm_insn("s    %1, %0",operands);
      output_asm_insn("neg  %0",operands);
    }
    return("");
  }
  [(set_attr "length" "2,4,4,6, 4,6,8,10")])


;;-------------------------------------
(define_insn "*rsubihi"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(minus:HI (match_operand:HI 1 "immediate_operand" "i")
		  (match_operand:HI 2 "register_operand" "0")))]
  ""
  {
    if (INTVAL(operands[1]) == -1)
      output_asm_insn("inc  %0",operands);
    else if (INTVAL(operands[1]) == 1)
      output_asm_insn("dec  %0",operands);
    else if (INTVAL(operands[1]) == -2)
      output_asm_insn("inct %0",operands);
    else if (INTVAL(operands[1]) == 2)
      output_asm_insn("dect %0",operands);
    else
    {
      operands[1] = GEN_INT(-INTVAL(operands[1]));
      output_asm_insn("ai   %0, %1",operands);
    }
    output_asm_insn("neg  %0",operands);
    return "";
  }
  [(set_attr "length" "6")])


;;-------------------------------------
(define_insn "subqi3"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,Q,rR>,Q,rR>,Q,rR>,Q")
	(minus:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0,rR>,rR>,Q,Q")
		  (match_operand:QI 2 "nonimmediate_operand" "rR>,rR>,Q,Q,0,0,0,0")))]
  ""
  {
    if(which_alternative < 4)
    {
      output_asm_insn("sb   %2, %0",operands);
    }
    else
    {
      output_asm_insn("sb   %1, %0",operands);
      output_asm_insn("neg  %0",operands);
    }
    return("");
  }
  [(set_attr "length" "2,4,4,6, 4,6,8,10")])


;;-------------------------------------------------------------------
;; Multiply


;;-------------------------------------
(define_insn "mulsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r,r")
        (mult:SI (match_operand:SI 1 "register_operand" "0,0,0")
                 (match_operand:SI 2 "nonimmediate_operand"  "r,R,Q")))
   (clobber (match_scratch:HI 3 "=r,r,r"))
   (clobber (match_scratch:HI 4 "=r,r,r"))]
  ""
  {
    rtx args[6];

    args[0] = operands[0];  // Destination R
    args[1] = gen_lowpart_SUBREG(HImode, operands[0]);

    args[2] = operands[2];  // Source G
    if(REG_P(operands[2]))
    {
      args[3] = gen_lowpart_SUBREG(HImode, operands[2]);
    }
    else
    {
      args[3] = adjust_address(operands[2], HImode, 2);
    }

    args[4] = operands[3];  // Temp
    args[5] = operands[4];  // Hold

    /*
    Since we only have a 16-bit multiply, we need to expand
    this math.

    (R0*N+R1)*(G0*N+G1) = R0*G0*N*N + R0*G1*N + R1*G0*N + R1*G1

    We can omit the R0*G0 term since it won't fit into 32 bits
    */

    output_asm_insn("mov  %1, %5",args);  // H = R1
    output_asm_insn("mpy  %3, %0",args);  // [R0,R1] = R0*G1
    output_asm_insn("mov  %1, %4",args);  // T = LSW(R0*G1)
    output_asm_insn("mov  %5, %0",args);  // R0 = H
    output_asm_insn("mpy  %2, %0",args);  // [R0,R1] = R1*G0
    output_asm_insn("a    %1, %4",args);  // T += LSW(R1*G0)
    output_asm_insn("mov  %5, %0",args);  // R0 = H
    output_asm_insn("mpy  %3, %0",args);  // [R0,R1] = R1*G1
    output_asm_insn("a    %4, %0",args);  // R0 += T
    return("");
  }
  [(set_attr "length" "18,22,26")])


;;-------------------------------------
(define_insn "umulhisi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(mult:SI (match_operand:HI 1 "register_operand" "r,r")
		 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  {
    if(REG_P(operands[1]) && (REGNO(operands[1]) == REGNO(operands[0])))
    {
      /* op[1] == op[0], arguments in proper location */
      output_asm_insn("mpy  %2, %0", operands);
    }
    else
    {
      /* Arguments need to move */
      if(!REG_P(operands[2]) || (REGNO(operands[2]) != REGNO(operands[0])))
      {
        /* op[2] != op[0], fix that */
        output_asm_insn("mov  %2, %0", operands);
      }
      output_asm_insn("mpy  %1, %0", operands);
    }
    return("");
  }
  [(set_attr "length" "4,6")])


(define_expand "mulhi3"
  [(set (match_dup 3)
        (mult:SI (match_operand:HI 1 "register_operand" "r,r")
                 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))
   (set (match_operand:HI 0 "register_operand" "=r,r")
        (subreg:HI (match_dup 3) 2))]
   ""
   "operands[3] = force_reg(SImode, GEN_INT(0));"
)


;;-------------------------------------
(define_insn "*mulqisi3"
  [
   (set (match_operand:SI 0 "register_operand" "=r")
        (mult:SI (match_operand:QI 1 "register_operand" "0")
                 (match_operand:QI 2 "register_operand" "r")))
  ]
  ""
  {
    rtx ops[4];
    ops[0] = operands[0];  /* Destination */
    ops[1] = operands[1];  /* Source 1 */
    ops[2] = operands[2];  /* Source 2 */
    ops[3] = gen_rtx_REG (HImode, REGNO (operands[0]) + REGS_PER_WORD);  /* Low word of source */

    // Sometimes the source operands can get swapped, fix that here
    if(REGNO(operands[2]) != REGNO(operands[0]))
    {
      /* ops[2] != ops[0], fix that */
      output_asm_insn("mov  %2, %0", ops);
    }
    output_asm_insn("mpy  %1, %0", ops);
    output_asm_insn("mov  %0, %3", ops);
    return("");
  }
  [(set_attr "length" "6")])


(define_expand "mulqi3"
  [
   (set (match_dup 3)
        (mult:SI (match_operand:QI 1 "register_operand" "3")
                 (match_operand:QI 2 "register_operand" "r")))
   (set (match_operand:QI 0 "register_operand" "=r")
        (subreg:QI (match_dup 3) 3))
  ]
  ""
  "operands[3] = force_reg(SImode, GEN_INT(0));"
)


;;-------------------------------------------------------------------
;; Divide and Modulus


;;-------------------------------------
(define_insn "divmodsihi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
        (ior:SI
          (ashift:SI
            (zero_extend:SI
              (div:HI (match_operand:SI 1 "register_operand" "0,0")
                      (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))
            (const_int 16))
          (zero_extend:SI 
            (mod:HI (match_dup 1)
                    (match_dup 2)))))]
  ""
  "div  %2, %0"
  [(set_attr "length" "2,4")])


(define_expand "udivmodhi4"
  [(parallel [
     (set (match_operand:HI 0 "register_operand" "=r,r")
          (div:HI (match_operand:SI 1 "register_operand" "+0,0")
                  (match_operand:HI 2 "nonimmediate_operand" "+rR>,Q")))
     (set (match_operand:HI 3 "register_operand" "=r,r")
          (mod:HI (match_dup 1) 
                  (match_dup 2)))])]
  ""
  {
    rtx insn, div_equal, mod_equal, equal;
    div_equal = gen_rtx_DIV (HImode, operands[1], operands[2]);
    mod_equal = gen_rtx_MOD (HImode, operands[1], operands[2]);
    equal = gen_rtx_IOR (SImode,
                         gen_rtx_ASHIFT (SImode,
                                         gen_rtx_ZERO_EXTEND (SImode, div_equal),
                                         GEN_INT (16)),
                         gen_rtx_ZERO_EXTEND (SImode, mod_equal));

    insn = emit_insn (gen_divmodsihi3 (operands[1], operands[1], operands[2]));
    set_unique_reg_note (insn, REG_EQUAL, equal);

    insn = emit_move_insn (operands[0], gen_highpart (HImode, operands[1]));
    set_unique_reg_note (insn, REG_EQUAL, mod_equal);

    insn = emit_move_insn (operands[3], gen_lowpart (HImode, operands[1]));
    set_unique_reg_note (insn, REG_EQUAL, div_equal);

    DONE;
  })


;;-------------------------------------
(define_expand "divmodhi4"
  [(parallel [
     (clobber (match_scratch:HI 4 "+r,r"))
     (clobber (match_scratch:HI 5 "+r,r"))
     (clobber (match_scratch:SI 6 "+r,r"))
     (clobber (match_scratch:HI 7 "+r,r"))
     (clobber (match_scratch:HI 8 "+r,r"))
     (set (match_operand:HI 0 "register_operand" "=r,r")
          (div:HI (match_operand:HI 1 "register_operand" "0,0")
                  (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))
     (set (match_operand:HI 3 "register_operand" "=r,r")
          (mod:HI (match_dup 1) 
                  (match_dup 2)))
])]
  ""
  {
    operands[4] = gen_reg_rtx(HImode);
    operands[5] = gen_reg_rtx(HImode);
    operands[6] = gen_reg_rtx(SImode);
    operands[7] = gen_reg_rtx(HImode);
    operands[8] = gen_reg_rtx(HImode);

    /* Use temp for operands */
    emit_move_insn(operands[7], operands[1]);
    emit_move_insn(operands[8], operands[2]);

    /* Find quotient sign */
    emit_move_insn(operands[4], operands[1]);
    emit_insn(gen_xorhi3(operands[4], operands[4], operands[8]));
  
    /* Find modulus sign */
    emit_move_insn(operands[5], operands[1]);

    /* Convert operands to absolute value */
    emit_insn(gen_abshi2(operands[7], operands[7]));
    emit_insn(gen_abshi2(operands[8], operands[8]));

    /* Perform division and modulus */
    emit_move_insn(operands[6],gen_rtx_ZERO_EXTEND(SImode, operands[7]));
    emit_insn(gen_udivmodhi4(operands[0], operands[6], operands[8], operands[3]));

    /* Correct sign of results */
    emit_insn(gen_divfixuphi2(operands[0], operands[4]));  /* Correct quotient sign */
    emit_insn(gen_divfixuphi2(operands[3], operands[5]));  /* Correct modulus sign */

    DONE;
  }
)


(define_insn "divfixuphi2"
  [(set (match_operand:HI 1 "register_operand" "=r")
        (not:HI (match_dup 1)))
   (set (match_operand:HI 0 "register_operand" "=r")
        (if_then_else:HI (lt:HI (match_dup 1) (const_int 0))
           (neg:HI (match_dup 0)) (match_dup 0)))]
  ""
  {
    output_asm_insn("inv  %1", operands);
    output_asm_insn("jlt  $+4", operands);
    output_asm_insn("neg  %0", operands);
    return("");
  }
  [(set_attr "length" "6")])


;;-------------------------------------------------------------------
;; Absolute Value


;;-------------------------------------
(define_insn "abshi2"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
	(abs:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))]
  ""
  "abs  %0"
  [(set_attr "length" "2,4")])


;;-------------------------------------
(define_insn "absqi2"
  [(set (match_operand:QI 0 "register_operand" "=r")
	(abs:QI (match_operand:QI 1 "register_operand" "0")))]
  ""
  "abs  %0"
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Negate


;;-------------------------------------
(define_insn "negsi2"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR,Q")
	(neg:SI (match_operand:SI 1 "nonimmediate_operand" "0,0")))]
  ""
  {
    rtx word[2];
    rtx offset[1];

    /* word 0 is most significant */
    word[0] = operands[0];
    if (REG_P (operands[0]))
    {
      word[1] = gen_rtx_REG(HImode, REGNO(operands[0]) + REGS_PER_WORD);
      offset[0] = GEN_INT(4);
    }
    else
    {
      word[1] = adjust_address(operands[0], HImode, 2);
      offset[0] = GEN_INT(6);
    }
    output_asm_insn("inv  %0", word);
    output_asm_insn("neg  %1", word);
    output_asm_insn("jnc  $+%0", offset);
    output_asm_insn("inc  %0", word);
    return("");
  }
  [(set_attr "length" "8,14")])


;;-------------------------------------
(define_insn "neghi2"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
	(neg:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))]
  ""
  "neg  %0"
  [(set_attr "length" "2,4")])


;;-------------------------------------
(define_insn "negqi2"
  [(set (match_operand:QI 0 "register_operand" "=r")
	(neg:QI (match_operand:QI 1 "register_operand" "0")))]
  ""
  {
    output_asm_insn("andi %0, 0xFF00", operands);
    output_asm_insn("neg  %0", operands);
    return("");
  }
  [(set_attr "length" "6")])


;;-------------------------------------------------------------------
;;  Move Operations
;;-------------------------------------------------------------------


;; MGB TODO don't see any need for SWPB etc
;;-------------------------------------------------------------------
;; Move byte value
(define_insn "movqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,  Q,r, r,W,r")
        (match_operand:QI 1 "general_operand"       "rR>,Q,  rR>,Q,MO,i,r,W"))]
  ""
  {
    if (GET_CODE (operands[1]) == CONST_INT)
    {
      if(GET_CODE (operands[0]) == REG)
      {
        if (INTVAL(operands[1]) == 0)
          return("clr  %0");
        else if (INTVAL(operands[1]) == -1)
          return("seto %0");
        else
        {
          operands[1] = GEN_INT(INTVAL(operands[1]) * 256);
          return("li   %0, %1");
        }
      }
    }
    else if(GET_CODE (operands[1]) == SUBREG ||
            GET_CODE (operands[1]) == TRUNCATE)
    {
      /* Mode change required, HI to QI */
      rtx suboperands[2];
      suboperands[0] = operands[0];
      suboperands[1] = SUBREG_REG(operands[1]);
      if(GET_CODE(operands[0]) == REG)
      {
        /* Reg-to-reg copy */ 
        if(REGNO(suboperands[0]) == REGNO(suboperands[1]))
        {
          /* Convert within the register */
          output_asm_insn ("swpb %0", suboperands);
        }
        else
        {
          /* Copy to other register, then convert */
          output_asm_insn ("mov  %1, %0", suboperands);
          output_asm_insn ("swpb %0", suboperands);            
        }
      }
      else
      {
        /* Reg-to-mem copy */
        if(find_regno_note(insn, REG_DEAD, REGNO(suboperands[1])))
        {
          output_asm_insn ("swpb %1", suboperands);                       
          output_asm_insn ("movb %1, %0", suboperands);
          /* Operand 1 dies here, no need to restore it */
        }
        else
        {
          output_asm_insn ("swpb %1", suboperands);                       
          output_asm_insn ("movb %1, %0", suboperands);
          output_asm_insn ("swpb %1", suboperands);                       
        }
      }
      return("");
    }
    return("movb %1, %0");
  }
  [(set_attr "length" "4,8,4,6,2,4,4,4")])



;; MGB TODO use which_alt for consistency
;;-------------------------------------------------------------------
;; Move two-byte value
(define_insn "movhi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=UrR>,rR>,Q,Q,r,W,r")
	(match_operand:HI 1 "general_operand" "rROM>,Q,rROM>,Q,i,r,W"))]
  ""
  {
    switch(GET_CODE(operands[1]))
    {
      case CONST_INT:
        if (INTVAL(operands[1]) == 0)
          return("clr  %0");
        else if (INTVAL(operands[1]) == -1)
          return("seto %0");
        else
          return("li   %0, %1");

      case REG:
      case MEM:
        return("mov  %1, %0");

      default:
        return("li   %0, %1");
    }
  }
  [(set_attr "length" "2,4,4,6,4,2,2")])


;;-------------------------------------------------------------------
;; Type Conversions
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Zero Extend


;;-------------------------------------
(define_insn "zero_extendqihi2"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(zero_extend:HI (match_operand:QI 1 "register_operand" "0")))]
  ""
  "srl  %0, 8"
  [(set_attr "length" "2")])


;;-------------------------------------
(define_insn "zero_extendhisi2"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=r,R,Q")
	(zero_extend:SI (match_operand:HI 1 "general_operand" "g,g,g")))]
  ""
  {
    rtx lateoperands[2];

    lateoperands[0] = operands[0];
    if (REG_P (operands[0]))
      operands[0] = gen_rtx_REG(HImode, REGNO(operands[0]) + REGS_PER_WORD);
    else
      operands[0] = adjust_address(operands[0], HImode, 2);

    output_asm_insn("mov  %1, %0", operands);
    output_asm_insn("clr  %0", lateoperands);
    return("");
  }
  [(set_attr "length" "4,8,10")])


;;-------------------------------------------------------------------
;; Sign Extend
(define_insn "extendqihi2"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(sign_extend:HI (match_operand:QI 1 "register_operand" "0")))]
  ""
  "sra  %0, 8"
  [(set_attr "length" "2")])
			 

;;-------------------------------------
(define_insn "extendhisi2"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=r,R,Q")
	(sign_extend:SI (match_operand:HI 1 "general_operand" "g,g,g")))]
  ""
  {
    rtx latehalf[2];
    rtx offset[2];

    latehalf[0] = operands[0];
    if (REG_P (operands[0]))
      operands[0] = gen_rtx_REG(HImode, REGNO(operands[0]) + REGS_PER_WORD);
    else
      operands[0] = adjust_address(operands[0], HImode, 2);

    if(which_alternative == 2)
      offset[0] = GEN_INT(6);
    else
      offset[0] = GEN_INT(4);

    output_asm_insn("mov  %1, %0", operands);
    output_asm_insn("seto %0", latehalf);
    output_asm_insn("jlt  $+%0", offset);
    output_asm_insn("clr  %0", latehalf);
    return("");
  }
  [(set_attr "length" "8,12,14")])


;;-------------------------------------------------------------------
;; Other Instructions
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; No-op
(define_insn "nop"
  [(const_int 0)]
  ""
  "nop"
  [(set_attr "length" "2")])



;;-------------------------------------------------------------------
;;  Optimizations For Comparisons
;;-------------------------------------------------------------------

;;-------------------------------------------------------------------
;; Optimization for X == {-2,-1,1,2}
(define_peephole2
  [(set (cc0)
	(compare (match_operand:HI 0 "register_operand" "r")
		 (match_operand:HI 1 "immediate_operand" "LMNO")))
   (set (pc) (if_then_else (eq (cc0) (const_int 0))
                           (label_ref (match_operand 2 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(2, operands[0])"
  [(set (match_operand:HI 0 "register_operand" "")
	(plus:HI (match_dup 0) (neg:HI (match_dup 1))))
   (set (cc0) (match_dup 0))
   (set (pc) (if_then_else (eq (cc0) (const_int 0))
                           (label_ref (match_dup 2))
                           (pc)))]
  )


(define_insn "*sub_const_hi"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (plus:HI (match_operand:HI 1 "register_operand" "0,0")
                 (neg:HI (match_operand:HI 2 "immediate_operand" "LMNO, i"))))]
  ""
  {
    operands[2] = GEN_INT(-INTVAL(operands[2]));
    switch(INTVAL(operands[2]))
    {
      case -2: output_asm_insn("dect %0",     operands); break;
      case -1: output_asm_insn("dec  %0",     operands); break;
      case  1: output_asm_insn("inc  %0",     operands); break;
      case  2: output_asm_insn("inct %0",     operands); break;
      default: output_asm_insn("ai   %0, %2", operands); break;
    }
    return("");
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------------------------------------
;; Optimization for X != {-2,-1,1,2}
(define_peephole2
  [(set (cc0)
	(compare (match_operand:HI 0 "register_operand" "r")
		 (match_operand:HI 1 "immediate_operand" "LMNO")))
   (set (pc) (if_then_else (ne (cc0) (const_int 0))
                           (label_ref (match_operand 2 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(2, operands[0])"
  [(set (match_operand:HI 0 "register_operand" "")
	(plus:HI (match_dup 0) (neg:HI (match_dup 1))))
   (set (cc0) (match_dup 0))
   (set (pc) (if_then_else (ne (cc0) (const_int 0))
                           (label_ref (match_dup 2))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;;  Optimizations For Byte Compares
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X > N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (gtu (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 255)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (gtu (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


(define_insn "*cmpqi_as_hi"
  [(set (cc0)
      (compare (match_operand:QI 0 "register_operand" "r")
         (plus:HI (match_operand:HI 1 "const_int_operand" "i")
            (mult:HI (match_operand:HI 2 "const_int_operand" "i")
               (match_operand:HI 3 "const_int_operand" "i")))))]
  "INTVAL(operands[3]) == 256 && (INTVAL(operands[1]) == 0 || INTVAL(operands[1]) == 255)"
  {
    operands[1] = GEN_INT(INTVAL(operands[2]) * 256 + INTVAL(operands[1]));
    return("ci   %0, %1");
  }
  [(set_attr "length" "4")])


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X < N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (ltu (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 0)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (ltu (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X >= N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (geu (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 0)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (geu (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X <= N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (leu (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 255)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (leu (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;; Optimization for (char)X > N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (gt (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 255)
                          (mult:HI (match_dup 1)
                                  (const_int 256)))))
   (set (pc) (if_then_else (gt (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;; Optimization for (char)X < N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (lt (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 0)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (lt (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;; Optimization for (char)X >= N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (ge (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 0)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (ge (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;; Optimization for (char)X <= N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (le (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 255)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (le (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;;  Optimizations For Bit Shift And Cast
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Optimization for (char)X = (int X) >> N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashiftrt:HI (match_dup 0)
            (match_operand:HI 1 "const_int_operand" "i")))
   (set (match_operand:QI 2 "register_operand" "=r")
        (subreg:QI (match_dup 0) 1))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 0)
        (ashiftrt:HI (match_dup 0)
            (minus:HI (match_dup 1) 
                      (const_int 8))))]
  )

(define_insn "*ashiftrt_hi_to_qi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashiftrt:HI (match_dup 0)
            (minus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    int shift = INTVAL (operands[1]);
    if(shift < 8)
    {
      operands[1] = GEN_INT(8 - shift);
      output_asm_insn("sla  %0, %1", operands);
    }
    else if(shift > 8)
    {
      operands[1] = GEN_INT(shift - 8);
      output_asm_insn("sra  %0, %1", operands);
    }
    return "";
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X = (unsigned int X) >> N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (lshiftrt:HI (match_dup 0)
            (match_operand:HI 1 "const_int_operand" "i")))
   (set (match_operand:QI 2 "register_operand" "=r")
        (subreg:QI (match_dup 0) 1))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 0)
        (lshiftrt:HI (match_dup 0)
            (minus:HI (match_dup 1) 
                      (const_int 8))))]
  )


(define_insn "*lshiftrt_hi_to_qi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (lshiftrt:HI (match_dup 0)
            (minus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    int shift = INTVAL (operands[1]);
    if(shift < 8)
    {
      operands[1] = GEN_INT(8 - shift);
      output_asm_insn("sla  %0, %1", operands);
    }
    else if(shift > 8)
    {
      operands[1] = GEN_INT(shift - 8);
      output_asm_insn("srl  %0, %1", operands);
    }
    return "";
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (char)X = (int X) << N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashift:HI (match_dup 0)
            (match_operand:HI 1 "const_int_operand" "i")))
   (set (match_operand:QI 2 "register_operand" "=r")
        (subreg:QI (match_dup 0) 1))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 0)
        (ashift:HI (match_dup 0)
            (plus:HI (match_dup 1) 
                      (const_int 8))))]
  )


(define_insn "*ashift_hi_to_qi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashift:HI (match_dup 0)
            (plus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    operands[1] = GEN_INT(8 + INTVAL (operands[1]));
    output_asm_insn("sla  %0, %1", operands);
    return("");
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (int)X = (char X) >> N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (ashiftrt:QI (match_dup 0)
            (match_operand:HI 1 "const_int_operand" "i")))
   (set (match_operand:HI 2 "register_operand" "=r")
        (sign_extend:HI (match_dup 0)))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 2)
        (ashiftrt:HI (match_dup 2)
            (plus:HI (match_dup 1) 
                      (const_int 8))))]
  )


(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
	(sign_extend:HI (match_operand:QI 1 "register_operand" "0")))
   (set (match_operand:HI 2 "register_operand" "=r")
        (ashiftrt:HI (match_dup 2)
            (match_operand:HI 3 "const_int_operand" "i")))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 2)
        (ashiftrt:HI (match_dup 2)
            (plus:HI (match_dup 3) 
                      (const_int 8))))]
  )


(define_insn "*ashiftrt_qi_to_hi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashiftrt:HI (match_dup 0)
            (plus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    int shift = INTVAL (operands[1]) + 8;
    if(shift > 15) shift = 15;
    operands[1] = GEN_INT(shift);
    output_asm_insn("sra  %0, %1", operands);
    return("");
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (int)X = (unsigned char X) >> N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (lshiftrt:HI (match_operand:HI 1 "register_operand" "0")
            (match_operand:HI 2 "const_int_operand" "i")))
   (set (match_operand:HI 3 "register_operand" "=r")
        (and:HI (match_operand:HI 4 "const_int_operand" "2")
                (match_operand:HI 5 "const_int_operand" "i")))]
  "(REGNO(operands[0]) == REGNO(operands[3])) && (INTVAL(operands[5]) == (1<<(8-INTVAL(operands[2])))-1)"
  [(set (match_dup 0)
        (lshiftrt:HI (match_dup 0)
            (plus:HI (match_dup 2) 
                      (const_int 8))))]
  )


(define_insn "*lshiftrt_qi_to_hi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (lshiftrt:HI (match_dup 0)
            (plus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    int shift = INTVAL (operands[1]) + 8;
    if(shift > 15) shift = 15;
    operands[1] = GEN_INT(shift);
    output_asm_insn("srl  %0, %1", operands);
    return("");
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (int)X = ((int)(char X)) << N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (sign_extend:HI (match_operand:QI 1 "register_operand" "0")))
   (set (match_operand:HI 3 "register_operand" "=r")
        (ashift:HI (match_operand:HI 4 "register_operand" "3")
                   (match_operand:HI 5 "const_int_operand" "i")))]
  "(REGNO(operands[0]) == REGNO(operands[3]))"
  [(set (match_dup 0)
        (ashiftrt:HI (const_int 8)
            (ashift:HI (match_dup 0) 
                       (match_dup 5))))]
  )

(define_insn "*qi_hi_shift"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashiftrt:HI (match_operand:HI 1 "const_int_operand" "i")
            (ashift:HI (match_operand:HI 2 "register_operand" "0") 
                       (match_operand:HI 3 "const_int_operand" "i"))))]
  ""
  {
    int shift = INTVAL(operands[3]);
    if(shift == 0) {
      output_asm_insn("swpb %0", operands);
      }
    else if(shift >= 1 && shift <= 7) { 
      operands[3] = GEN_INT(8-shift);
      output_asm_insn("sra  %0, %3", operands);
      }
    else if(shift >= 9 && shift <= 15) {
      operands[3] = GEN_INT(shift-8);
      output_asm_insn("sla  %0, %3", operands);
      }

    operands[3] = GEN_INT(0x00FF << shift);
    output_asm_insn("andi %0, %3", operands);
   
    return("");
  }
  [(set_attr "length" "6")])


;;-------------------------------------------------------------------
;; Optimization for (unsigned int)X = ((unsigned int)(unsigned char X)) << N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (zero_extend:HI (match_operand:QI 1 "register_operand" "0")))
   (set (match_operand:HI 3 "register_operand" "=r")
        (ashift:HI (match_operand:HI 4 "register_operand" "3")
                   (match_operand:HI 5 "const_int_operand" "i")))]
  "(REGNO(operands[0]) == REGNO(operands[3]))"
  [(set (match_dup 0)
        (lshiftrt:HI (const_int 8)
            (ashift:HI (match_dup 0) 
                       (match_dup 5))))]
  )


(define_insn "*unsigned_qi_hi_shift"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (lshiftrt:HI (match_operand:HI 1 "const_int_operand" "i")
            (ashift:HI (match_operand:HI 2 "register_operand" "0") 
                       (match_operand:HI 3 "const_int_operand" "i"))))]
  ""
  {
    int shift = INTVAL(operands[3]);
    if(shift >= 0 && shift <= 7) { 
      operands[3] = GEN_INT(8-shift);
      output_asm_insn("srl  %0, %3", operands);
      }
    else if(shift >= 9 && shift <= 15) {
      operands[3] = GEN_INT(shift-8);
      output_asm_insn("sla  %0, %3", operands);
      }

    operands[3] = GEN_INT(0xFFFF << shift);
    output_asm_insn("andi %0, %3", operands);
   
    return("");
  }
  [(set_attr "length" "6")])


;;-------------------------------------------------------------------
;; Optimization for (unsigned long)X = (unsigned long Y) >> 16
;;   Original code:
;;     mov  r3, r6
;;     mov  r4, r7
;;     mov  r6, r7
;;     clr  r6
;;
;;   Optimized:
;;     mov r3, r7
;;     clr r6
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (match_operand:HI 1 "register_operand" "r"))
   (set (match_operand:HI 2 "register_operand" "=r")
        (match_operand:HI 3 "register_operand" "r"))
   (parallel[
    (clobber (match_operand:HI 4 "register_operand" "r"))
    (set (match_operand:SI 5 "register_operand" "=r")
         (lshiftrt:SI (match_operand:SI 6 "register_operand" "5")
                      (match_operand:HI 7 "const_int_operand" "i")))
   ])]
  "((REGNO(operands[0]) == REGNO(operands[5])) &&
    (REGNO(operands[2]) == (REGNO(operands[0])+1)) &&
    (INTVAL(operands[7]) == 16)
   )"
  [(set (match_dup 2) (match_dup 1))
   (set (match_dup 0) (const_int 0))]
)


(define_insn "*set_consthi2"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (match_operand:HI 1 "const_int_operand" "i"))]
  ""
  {
    if(INTVAL(operands[1]) == 0) {
      output_asm_insn("clr  %0", operands);
    } else if((INTVAL(operands[1]) & 0xFFFF) == 0xFFFF) {
      output_asm_insn("seto  %0", operands);
    } else {
      output_asm_insn("li   %0, %1", operands);
    }
    return("");
  }
  [(set_attr "length" "4")])


;;-------------------------------------------------------------------
;; Optimization for X = Y << 16
;;   Original code:
;;     mov  r4, r6
;;     mov  r5, r7
;;     mov  r7, r6
;;     clr  r7
;;
;;   Optimized:
;;     mov r5, r6
;;     clr r7
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (match_operand:HI 1 "register_operand" "r"))
   (set (match_operand:HI 2 "register_operand" "=r")
        (match_operand:HI 3 "register_operand" "r"))
   (parallel[
    (clobber (match_operand:HI 4 "register_operand" "r"))
    (set (match_operand:SI 5 "register_operand" "=r")
         (ashift:SI (match_operand:SI 6 "register_operand" "5")
                      (match_operand:HI 7 "const_int_operand" "i")))
   ])]
  "((REGNO(operands[0]) == REGNO(operands[5])) &&
    (REGNO(operands[2]) == (REGNO(operands[0])+1)) &&
    (INTVAL(operands[7]) == 16)
   )"
  [(set (match_dup 0) (match_dup 3))
   (set (match_dup 2) (const_int 0))]
)


;-------------------------------------------------------------------
;; Optimization for byte array initializations
; This handles sequences like:
;   li   r1, >1200
;   movb r1, *r2
;   li   r1, >3400
;   movb r1, @1(r2)
;
; and converts to:
;   li   r1, >1234
;   movb r1, *r2
;   swpb r1
;   movb r1, @1(r2)
;
; This saves two bytes and is slightly faster
(define_peephole2
  [(match_scratch:HI 6 "r,r")
   (set (match_operand:QI 0 "register_operand" "=r,r")
        (match_operand:QI 1 "const_int_operand" "i,i"))
   (set (match_operand:QI 2 "nonimmediate_operand" "=R>,Q")
        (match_dup 0))
   (set (match_operand:QI 3 "register_operand" "=r,r")
        (match_operand:QI 4 "const_int_operand" "i,i"))
   (set (match_operand:QI 5 "nonimmediate_operand" "=R>,Q")
        (match_dup 3))]
  "peep2_reg_dead_p(4, operands[0]) && peep2_reg_dead_p(4, operands[3])"
  [(set (match_dup 6)
        (ior:HI (ashift:HI (match_dup 1) 
                     (const_int 8))
             (match_dup 4)))
   (set (match_dup 2)
        (subreg:QI (ashiftrt:HI (match_dup 6) (const_int 8)) 1))
   (set (match_dup 5)
        (subreg:QI (ashiftrt:HI (match_dup 6) (const_int 0)) 1))]
)


(define_insn "*movhi_combine_consts"
  [(set (match_operand:HI 0 "register_operand" "")
        (ior:HI (ashift:HI (match_operand:QI 1 "const_int_operand" "")
                           (match_operand:QI 2 "const_int_operand" ""))
                (match_operand:QI 3 "const_int_operand" "")))]
  ""
  {
    operands[1] = GEN_INT(((INTVAL(operands[1]) & 0xFF) << 8) |
                           (INTVAL(operands[3]) & 0xFF));
    return "li   %0, %1";
  }
  [(set_attr "length" "4")])


(define_insn "*movqi_for_initializer"
  [(set (match_operand:QI 0 "memory_operand" "=rR>,Q")
        (subreg:QI (ashiftrt:HI (match_operand:HI 1 "register_operand" "r,r")
                              (match_operand:HI 2 "const_int_operand" "i,i")) 1))]
  ""
  {
    if(INTVAL(operands[2]) == 8)
    {
      output_asm_insn("movb %1, %0", operands);
    }
    else if(INTVAL(operands[2]) == 0)
    {
      output_asm_insn("swpb %1", operands);
      output_asm_insn("movb %1, %0", operands);
    }
   return("");
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------------------------------------
;; Optimization for memory-to-memory copies
;; Combine a mem-reg-mem copy into a mem-mem copy
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
        (match_operand:HI 1 "memory_operand" ""))
   (set (match_operand:HI 2 "memory_operand" "")
        (match_dup 0))]
  "peep2_reg_dead_p(2, operands[0])"
  [(set (match_operand:HI 2 "memory_operand" "")
        (match_operand:HI 1 "memory_operand" ""))]
)

   
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "memory_operand" ""))
   (set (match_operand:QI 2 "memory_operand" "")
        (match_dup 0))]
  "peep2_reg_dead_p(2, operands[0])"
  [(set (match_operand:QI 2 "memory_operand" "")
        (match_operand:QI 1 "memory_operand" ""))]
)


;;-------------------------------------------------------------------
;; Optimization for (int)X = (unsigned char)((int)X)
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (subreg:QI (match_operand:HI 1 "register_operand") 1))
   (set (match_operand:HI 2 "register_operand" "")
        (zero_extend:HI (match_dup 0)))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 2)
        (match_dup 1))
   (set (match_dup 2)
        (and:HI (match_dup 2) (const_int 255)))]
)

(define_insn "*andi_const"
  [(set (match_operand:HI 0 "register_operand" "")
        (and:HI (match_dup 0)
                (match_operand:HI 1 "const_int_operand" "")))]
  ""
  {
    int val = INTVAL(operands[1]) & 0xFFFF;
    if(val == 0)
      return "clr  %0";
    else if(val == 0xFFFF)
      return "";
    else
      return "andi %0, %1";
  }
  [(set_attr "length" "4")])

