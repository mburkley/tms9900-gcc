;; This file is part of GCC.

;; GCC is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.

;; GCC is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GCC; see the file COPYING3.  If not see
;; <http://www.gnu.org/licenses/>.

;; SI is 32 bit
;; HI is 16 bit
;; QI is 8 bit 

;; NOTES
;;    - rtx notation is insn(dst,src) but tms asm notation is <op> src,dst so
;;      beware of operand ordering
;;    - optimiser doesn't understand opcodes, just insns.  So keep insns as
;;      short as possible.  One opcode preferable, two max.  Any more, use an expand instead
;;    - I'm avoiding clobbers and declaring temp rtx regs inside code instead

;; Description of class IDs
;;   'C  is for CRU register
;;   'I' is for 32-bit value xxxx0000
;;   'J' is for 32-bit value 0000xxxx
;;   'K' is for 32-bit value xxxxxxxx
;;   'L' is for 2 or -2
;;   'M' is for -1
;;   'N' is for 1
;;   'O' is for 0
;;   'P' is for 00FF
;;   'Q' is for memory references that need an extra word after the opcode.
;;   'R' is for memory references which are encoded within the opcode.
;;   'S' is for shift register
;;   'T' Class of all registers
;;    U?
;;    W?

;;- See file "rtl.def" for documentation on define_insn, match_*, et. al.

;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code
;;- updates for most instructions.

;;- Operand classes for the register allocator:

;; Compare instructions.


;; define attributes
;; currently type is only fpu or arith or unknown, maybe branch later ?
;; default is arith
(define_attr "type" "unknown,arith,fp" (const_string "arith"))

;; length default is 1 word each
;; MGB TODO is length bytes or words?
(define_attr "length" "" (const_int 1))

;; a user's asm statement
(define_asm_attributes
  [(set_attr "type" "unknown")
; all bets are off how long it is - make it 256, forces long jumps 
; whenever jumping around it !!!
   (set_attr "length" "256")])

;; MGB To address the issue where tms9900 stores bytes in the MSB position, all
;; QI loads to registers are right-shifted 8 bits before storage as a HI value

;;-------------------------------------------------------------------
;;  UNSPEC Definitions
;;-------------------------------------------------------------------
(define_constants
  [(UNSPEC_RETURN  0)])


;;-------------------------------------------------------------------
;;  Predicate Definitions
;;-------------------------------------------------------------------

(define_predicate "shift_count_operand"
  (ior (match_code "const_int")
       (match_code "reg")))


;;-------------------------------------------------------------------
;;  Function Calls
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Jump to a subroutine which returns a value
(define_insn "call"
  [(call (match_operand:HI 0 "general_operand" "rR,Q")
         (match_operand:HI 1 "general_operand"  "g,g"))
  ]
  ""
  {
    if(SIBLING_CALL_P(insn))
      output_asm_insn("b    %0", operands);
    else
      output_asm_insn("bl   %0", operands);
    return("");
  }
  [(set_attr "length" "2,4")]
)


;-------------------------------------------------------------------
; Jump to a subroutine which returns a value
(define_insn "call_value"
  [(set (match_operand 0 "" "")
        (call (match_operand:HI 1 "general_operand" "rR,Q")
	      (match_operand:HI 2 "general_operand" "g,g")))
  ]
  ""
  {
    if(SIBLING_CALL_P(insn))
      output_asm_insn("b    %1", operands);
    else
      output_asm_insn("bl   %1", operands);
    return("");
  }
  [(set_attr "length" "2,4")]
)


;;-------------------------------------------------------------------
;; Define function prologue
(define_expand "prologue"
  [(const_int 0)]
  ""
{
  tms9900_expand_prologue();
  DONE;
})


;;-------------------------------------------------------------------
;; Define function epilogue
(define_expand "epilogue"
  [(return)]
  ""
{
  tms9900_expand_epilogue(false);
  DONE;
})

(define_expand "sibcall_epilogue"
  [(return)]
  ""
{
  tms9900_expand_epilogue(true);
  DONE;
})


;;-------------------------------------------------------------------
;; Define function return
(define_insn "*rt"
  [(unspec [(match_operand:HI 0 "general_operand" "")] UNSPEC_RETURN)]
  ""
  "b    *r11"
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;;  Comparison Instructions
;;-------------------------------------------------------------------


;;-------------------------------------
(define_insn "tsthi"
  [(set (cc0)
	(match_operand:HI 0 "nonimmediate_operand" "rR,Q"))]
  ""
  {
    tms9900_debug_operands ("tsthi", operands, 1);
    return("mov  %0, %0");
  }
  [(set_attr "length" "2,6")])


;;-------------------------------------
(define_insn "tstqi"
  [(set (cc0)
	(match_operand:QI 0 "nonimmediate_operand" "rR,Q"))]
  ""
  {
    tms9900_debug_operands ("tstqi", operands, 1);
    return("movb %0, %0");
  }
  [(set_attr "length" "2,6")])
 

;;-------------------------------------
(define_insn "cmphi"
  [(set (cc0)
	(compare (match_operand:HI 0 "nonimmediate_operand" "rR,rR,Q,Q,r")
		 (match_operand:HI 1 "general_operand"      "rR,Q,rR,Q,i")))]
  ""
  {
    tms9900_debug_operands ("cmphi", operands, 2);
    if (which_alternative == 4)
    {
       return("ci   %0, %1");
    }
    else
    {
      return("c    %0, %1");
    }
  }
  [(set_attr "length" "2,4,4,6,4")])


;;-------------------------------------
(define_insn "cmpqi"
  [(set (cc0)
	(compare (match_operand:QI 0 "register_operand" "rR>,Q,  rR>,Q,r")
		 (match_operand:QI 1 "general_operand"  "rR>,rR>,Q,  Q,i")))]
  ""
  {
    tms9900_debug_operands ("cmpqi", operands, 2);
    if (which_alternative == 4)
    {
      int val = INTVAL(operands[1]);
      operands[1] = GEN_INT(val*256);
      output_asm_insn("andi %0, >ff00",  operands);
      output_asm_insn("ci   %0, %1",  operands);
    }
    else
      output_asm_insn("cb   %1, %0",  operands);

    return("");
  }
  [(set_attr "length" "2,4,4,6,8")])

;;-------------------------------------------------------------------
;;  Move Operations
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Move byte value
(define_insn "movqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,Q,  rR>,Q,r,r")
        (match_operand:QI 1 "general_operand"      "rR>, rR>,Q,  Q,i,OM"))]
  ""
  {
    tms9900_debug_operands ("movqi", operands, 2);
    int val;
    switch (which_alternative)
    {
    case 4:
        val = INTVAL(operands[1]);
        tms9900_inline_debug ("; movqi imm MUL const %d * 256\n", val);
        operands[1] = GEN_INT(val*256);
        return("li   %0, %1");
    case 5:
        val = INTVAL(operands[1]);

        if (val == 0)
            return("clr  %0");
        else
            return("seto %0");
    default:
      return ("movb %1, %0");
    }
  }
  [(set_attr "length" "2,4,4,6,4,2")])

;; MGB TODO use which_alt for consistency
;;-------------------------------------------------------------------
;; Move two-byte value
(define_insn "movhi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=UrR>,rR>,Q,Q,r,W,r")
	(match_operand:HI 1 "general_operand" "rROM>,Q,rROM>,Q,i,r,W"))]
  ""
  {
    tms9900_debug_operands ("movhi", operands, 2);
    switch(GET_CODE(operands[1]))
    {
      case CONST_INT:
        if (INTVAL(operands[1]) == 0)
          return("clr  %0");
        else if (INTVAL(operands[1]) == -1)
          return("seto %0");
        else
          return("li   %0, %1");

      case REG:
        return ("mov  %1, %0");

      case MEM:
        return("mov  %1, %0");

      default:
        return("li   %0, %1");
    }
  }
  [(set_attr "length" "2,4,4,6,4,2,2")])

;;-------------------------------------------------------------------
;; Move four-byte value as two 2-byte regs
;; TODO change this into an expand with two movhi insns
(define_insn "movsi"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=UrR>,rR>,Q,Q,r,W,r")
	(match_operand:SI 1 "general_operand" "rROM>,Q,rROM>,Q,i,r,W"))]
  ""
  {
    tms9900_debug_operands ("movsi", operands, 2);
    rtx args[4];
    int val;
    args[0] = gen_highpart (HImode, operands[0]);
    args[1] = gen_lowpart (HImode, operands[0]);
    // args[2] = operands[1];
    //     operands[1] = GEN_INT(val*256);
    // args[2] = operands[1];
    //     operands[1] = GEN_INT(val*256);
    switch(GET_CODE(operands[1]))
    {
      case CONST_INT:
        val = INTVAL(operands[1]);
        if (INTVAL(operands[1]) == 0)
        {
          output_asm_insn("clr  %0", args);
          output_asm_insn("clr  %1", args);
        }
        else if (INTVAL(operands[1]) == -1)
        {
          output_asm_insn("seto %0", args);
          output_asm_insn("seto %1", args);
        }
        else
        {
          args[2] = GEN_INT(val / 65536);
          args[3] = GEN_INT(val % 65536);
          output_asm_insn("li   %0, %2", args);
          output_asm_insn("li   %1, %3", args);
        }
        break;

      case REG:
      case MEM:
        args[2] = gen_highpart (HImode, operands[1]);
        args[3] = gen_lowpart (HImode, operands[1]);
        output_asm_insn("mov  %2, %0", args);
        output_asm_insn("mov  %3, %1", args);
        break;

    }
    return("");
  }
  [(set_attr "length" "2,4,4,6,4,2,2")])


;;-------------------------------------------------------------------
;; Type Conversions
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Zero Extend
;; TODO create strict (srl) and non strict (swpb) variants as swpb is faster
;;-------------------------------------

(define_insn "zero_extendqihi2"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(zero_extend:HI (match_operand:QI 1 "register_operand" "0")))]
  ""
  {
    tms9900_debug_operands ("zero_extendqihi2", operands, 2);
    output_asm_insn ("srl  %0, 8", operands);
    return("");
  }
  [(set_attr "length" "2")])


;;-------------------------------------
(define_expand "zero_extendqisi2"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=r,R,Q")
	(zero_extend:SI (match_operand:QI 1 "general_operand" "g,g,g")))]
  ""
  {
    tms9900_debug_operands ("zero_extendqisi2", operands, 2);
    rtx tmp = gen_reg_rtx (HImode);
    emit_insn (gen_zero_extendqihi2 (tmp, operands[1]));
    emit_insn (gen_zero_extendhisi2 (operands[0], tmp));
    DONE;
  }
)

(define_insn "zero_extendhisi2"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=r,R,Q")
	(zero_extend:SI (match_operand:HI 1 "general_operand" "g,g,g")))]
  ""
  {
    tms9900_debug_operands ("zero_extendhisi2", operands, 2);
    rtx args[3];
    args[0] = gen_highpart (HImode, operands[0]);
    args[1] = gen_lowpart (HImode, operands[0]);
    args[2] = operands[1];

    output_asm_insn("mov  %2, %1", args);
    output_asm_insn("clr  %0", args);
    return("");
  }
  [(set_attr "length" "4,8,10")])


;;-------------------------------------------------------------------
;; Sign Extend
;;-------------------------------------------------------------------

(define_insn "extendqihi2"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(sign_extend:HI (match_operand:QI 1 "register_operand" "0")))]
  ""
  {
    tms9900_debug_operands ("extendqihi2", operands, 2);
    output_asm_insn("sra  %0, 8", operands);
    return("");
  }
  [(set_attr "length" "2")])
			 

(define_expand "extendqisi2"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(sign_extend:SI (match_operand:QI 1 "register_operand" "0")))]
  ""
  {
    tms9900_debug_operands ("extendqisi2", operands, 2);
    rtx tmp = gen_reg_rtx (HImode);
    emit_insn (gen_extendqihi2 (tmp, operands[1]));
    emit_insn (gen_extendhisi2 (operands[0], tmp));
    DONE;
  }
)

;;-------------------------------------
(define_insn "extendhisi2"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR,Q")
	(sign_extend:SI (match_operand:HI 1 "general_operand" "g,g")))]
  ""
  {
    tms9900_debug_operands ("extendhisi2", operands, 2);
    rtx args[3];
    rtx offset[1];
    args[0] = gen_highpart (HImode, operands[0]);
    args[1] = gen_lowpart (HImode, operands[0]);
    args[2] = operands[1];

    if(which_alternative == 1)
      offset[0] = GEN_INT(6);
    else
      offset[0] = GEN_INT(4);

    output_asm_insn("mov  %2, %1", args);
    /* sign extend.  If highpart is negative, seto, else clr.  This is slightly
     * cheaper (either 20 or 30 cycles) than doing sra 16 (44 cycles) */
    output_asm_insn("seto %0", args);
    output_asm_insn("jlt  $+%0", offset);
    output_asm_insn("clr  %0", args);
    return("");
  }
  [(set_attr "length" "8,12")])

;;-------------------------------------------------------------------
;; Truncate
; TODO swpb will suffice for non-strict truncation
;;-------------------------------------

(define_insn "trunchiqi2"
  [(set (match_operand:QI 0 "register_operand" "=r")
	(truncate:QI (match_operand:HI 1 "register_operand" "0")))]
  ""
  {
    tms9900_debug_operands ("trunchiqi2", operands, 2);
    output_asm_insn ("sla  %0, 8", operands);
    return("");
  }
  [(set_attr "length" "2")])

(define_insn "truncsiqi2"
  [(set (match_operand:QI 0 "register_operand" "=r")
	(truncate:QI (match_operand:SI 1 "register_operand" "0")))]
  ""
  {
    tms9900_debug_operands ("truncsiqi2", operands, 2);
    output_asm_insn ("sla  %0, 8", operands);
    // TODO any action needed to discard high word?
    return("");
  }
  [(set_attr "length" "2")])

(define_insn "truncsihi2"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(truncate:HI (match_operand:SI 1 "register_operand" "0")))]
  ""
  {
    tms9900_debug_operands ("truncsihi2", operands, 2);
    // TODO any action needed to discard high word?
    return("");
  }
  [(set_attr "length" "2")])

;;-------------------------------------------------------------------
;;  Branch Instructions
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Jump if equal
(define_insn "beq"
  [(set (pc)
	(if_then_else (eq (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  {
    return(output_branch("jeq", "jne", get_attr_length(insn)));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if equal, reversed comparison operands
(define_insn "*beq_reversed"
  [(set (pc)
	(if_then_else (eq (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  {
    return(output_branch("jne", "jeq", get_attr_length(insn)));
  }
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if not equal
(define_insn "bne"
  [(set (pc)
	(if_then_else (ne (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "* return output_branch(\"jne\", \"jeq\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if not equal, reversed comparison operands
(define_insn "*bne_reversed"
  [(set (pc)
	(if_then_else (ne (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "* return output_branch(\"jeq\", \"jne\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if unsigned less than
(define_insn "bltu"
  [(set (pc)
	(if_then_else (ltu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "* return output_branch(\"jl\", \"jhe\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if unsigned less than, reversed comparison operands
(define_insn "*bltu_reversed"
  [(set (pc)
	(if_then_else (ltu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "* return output_branch(\"jhe\", \"jl\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if unsigned less than or equal
(define_insn "bleu"
  [(set (pc)
	(if_then_else (leu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "* return output_branch(\"jle\", \"jh\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if unsigned less than or equal, reversed comparison operands
(define_insn "*bleu_reversed"
  [(set (pc)
	(if_then_else (leu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "* return output_branch(\"jh\", \"jle\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if unsigned greater than
(define_insn "bgtu"
  [(set (pc)
	(if_then_else (gtu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "* return output_branch(\"jh\", \"jle\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if unsigned greater than, reversed comparison operands
(define_insn "*bgtu_reversed"
  [(set (pc)
	(if_then_else (gtu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "* return output_branch(\"jle\", \"jh\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if unsigned greater than or equal
(define_insn "bgeu"
  [(set (pc)
	(if_then_else (geu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "* return output_branch(\"jhe\", \"jl\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if unsigned greater than or equal, reversed comparison operands
(define_insn "*bgeu_reversed"
  [(set (pc)
	(if_then_else (geu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "* return output_branch(\"jl\", \"jhe\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if less than
(define_insn "blt"
  [(set (pc)
	(if_then_else (lt (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "* return output_branch(\"jlt\", \"GE\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 18)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if less than, reversed comparison operands
; Was commented out
(define_insn "*blt_reversed"
  [(set (pc)
	(if_then_else (lt (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "* return output_branch(\"GE\", \"jlt\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 14)))])


;;-------------------------------------------------------------------
;; Jump if less than or equal
(define_insn "ble"
  [(set (pc)
	(if_then_else (le (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "* return output_branch(\"LE\", \"jgt\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 14)))])


;;-------------------------------------
;; Jump if less than or equal, reversed comparison operands
(define_insn "*ble_reversed"
  [(set (pc)
	(if_then_else (le (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "* return output_branch(\"jgt\", \"LE\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 18)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Jump if greater than
(define_insn "bgt"
  [(set (pc)
	(if_then_else (gt (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "* return output_branch(\"jgt\", \"LE\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 18)
				      (const_int 12)))])


;;-------------------------------------
;; Jump if greater than, reversed comparison operands
; Was commented out
(define_insn "*bgt_reversed"
  [(set (pc)
	(if_then_else (gt (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "* return output_branch(\"LE\", \"jgt\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 14)))])


;;-------------------------------------------------------------------
;; Jump if greater than or equal
; Was commented out
(define_insn "bge"
  [(set (pc)
	(if_then_else (ge (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "* return output_branch(\"GE\", \"jlt\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 16)
				      (const_int 14)))])


;;-------------------------------------
;; Jump if greater than or equal, reversed comparison operands
(define_insn "*bge_reversed"
  [(set (pc)
	(if_then_else (ge (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "* return output_branch(\"jlt\", \"GE\", get_attr_length(insn));"
  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 18)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;;  Jump Operations
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Unconditional jump to label
(define_insn "jump"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  ""
  "*
  return output_jump(get_attr_length(insn));"

  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
						      (pc))
					       (const_int -252))
					   (ge (minus (match_dup 0)
						      (pc))
					       (const_int 256)))
				      (const_int 14)
				      (const_int 12)))])


;;-------------------------------------------------------------------
;; Unconditional jump using pointer
(define_insn "indirect_jump"
  [(set (pc) (match_operand:HI 0 "nonimmediate_operand" "r,Q"))]
  ""
  "b    %0"
  [(set_attr "length" "2,4")])


;;-------------------------------------------------------------------
;; Unconditional jump using jump table
(define_insn "tablejump"
  [(clobber (match_scratch:HI 2 "=r,r"))
   (set (pc) (match_operand:HI 0 "nonimmediate_operand" "rR,Q"))
   (use (label_ref (match_operand 1 "" "")))]
  ""
  {
    output_asm_insn("mov  %0, %2", operands);
    output_asm_insn("b    *%2",    operands);
    return(""); 
  }
  [(set_attr "length" "4,6")])


;;-------------------------------------------------------------------
;;  Bit Shift Operations
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Arithmetic shift left


;;-------------------------------------
(define_insn "ashlsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(ashift:SI (match_operand:SI 1 "register_operand" "0,0")
		   (match_operand:HI 2 "shift_count_operand" "S,i")))
   (clobber (match_scratch:HI 3 "=&r,&r"))]
     ""
  {
    tms9900_debug_operands ("ashlsi3", operands, 3);
    rtx ops[7];
    ops[0] = operands[0];  /* Destination */
    ops[1] = operands[1];  /* Source */
    ops[2] = operands[2];  /* Shift count */
    ops[3] = operands[3];  /* Scratch reg */
    ops[4] = gen_rtx_REG (HImode, REGNO (operands[0]) + REGS_PER_WORD);  /* Low word of source */
    if(which_alternative == 0)
    {
      /* Variable shift */
      output_asm_insn("ci   %2, 16",  ops);  /* +0: Compare shift to 16 */
      output_asm_insn("jlt  $+12",    ops);  /* +4: If shift was < 16, goto lt_16 */
      output_asm_insn("jeq  $+4",     ops);  /* +6: If shift was 16, goto eq_16 */
     
      /* Shift count greater than 16 */
      output_asm_insn("sla  %4, %2",  ops);  /* +8: Shift low word */

      /* eq_16: Shift count equals 16 */
      output_asm_insn("mov  %4, %1",  ops);  /* +10: Copy low word to high word */ 
      output_asm_insn("clr  %4",      ops);  /* +12: Clear low word */
      output_asm_insn("jmp  $+20",    ops);  /* +14: Goto end */

      /* lt_16: Shift count less than 16 */
      output_asm_insn("abs  %2",      ops);  /* +16: Test shift count */
      output_asm_insn("jeq  $+16",    ops);  /* +18: If shift==0, goto end */
      output_asm_insn("mov  %4, %3",  ops);  /* +20: Save low word to temp */
      output_asm_insn("sla  %1, %2",  ops);  /* +22: Shift high word */
      output_asm_insn("sla  %4, %2",  ops);  /* +24: Shift low word */
      output_asm_insn("neg  %2",      ops);  /* +26: Get complement of shift count */
      output_asm_insn("srl  %3, %2",  ops);  /* +28: Shift low word bits into high word position */
      output_asm_insn("soc  %3, %1",  ops);  /* +30: Merge shifted low word bits into high word */
      output_asm_insn("neg  %2",      ops);  /* +32: Restore shift count */
      /* +34: End */
    }
    else
    {
      /* Constant shift */
      int offset = INTVAL(operands[2]);
      ops[5] = GEN_INT(16-offset);  /* Complement of shift count */
      ops[6] = GEN_INT(offset%16);  /* Modulo of shift count */
  
      if(offset < 16)
      {
        if(offset == 8)
        {
          output_asm_insn("movb %4, %1",  ops);  /* Move MSB of high word */
          output_asm_insn("sb   %4, %4",  ops);  /* Clear MSB of high word */
          output_asm_insn("swpb %1",      ops);  /* Swap bytes in low word */
          output_asm_insn("swpb %4",      ops);  /* Swap bytes in high word */
        }
        else
        {
          output_asm_insn("mov  %4, %3", ops);  /* Save low word to temp */
          output_asm_insn("sla  %1, %2", ops);  /* Shift high word */
          output_asm_insn("sla  %4, %2", ops);  /* Shift low word */
          output_asm_insn("srl  %3, %5", ops);  /* Shift low word bits into high word position */
          output_asm_insn("soc  %3, %1", ops);  /* Merge low word bits into high word */
        }
      } 
      else
      {
        if(offset > 16)
        {
          output_asm_insn("sla  %4, %6", ops);  /* Shift low word */
        }
        output_asm_insn("mov  %4, %1", ops);  /* Move low word into high word */
        output_asm_insn("clr  %4",     ops);  /* Clear low word */
      }
    }
    return "";
  }
  [(set_attr "length" "34, 10")]
)


;;-------------------------------------
(define_insn "ashlhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(ashift:HI (match_operand:HI 1 "register_operand" "0,0")
		   (match_operand:HI 2 "shift_count_operand" "S,i")))]
  ""
  {
    tms9900_debug_operands ("ashlhi3", operands, 3);
    if(which_alternative == 0)
    {
      output_asm_insn("abs  r0",     operands);
      output_asm_insn("jeq  $+4",    operands);
      output_asm_insn("sla  %0, 0",  operands);
    }
    else if(INTVAL(operands[2]) > 0)
    {
      output_asm_insn("sla  %0, %2", operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,2")])


;;-------------------------------------
(define_insn "ashlqi3"
  [(set (match_operand:QI 0 "register_operand" "=r,r")
	(ashift:QI (match_operand:QI 1 "register_operand" "0,0")
		   (match_operand:HI 2 "shift_count_operand" "S,i")))]
  ""
  {
    tms9900_debug_operands ("ashlqi3", operands, 3);
    if(which_alternative == 0)
    {
      output_asm_insn("abs  r0",        operands);
      output_asm_insn("jeq  $+8",       operands);  /* If shift count is zero, do nothing */
      output_asm_insn("andi %0, >FF00", operands);
      output_asm_insn("sla  %0, 0",     operands);
    }
    else if(INTVAL(operands[2]) > 0)
    {
      output_asm_insn("andi %0, >FF00", operands);
      output_asm_insn("sla  %0, %2",    operands);
    }
    return(""); 
  }
  [(set_attr "length" "10,6")])


;;-------------------------------------------------------------------
;; Arithmetic shift left (for QI mode)

(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(sign_extend:HI(match_operand:QI 1 "register_operand" "r,r")))
   (set (match_operand:HI 2 "register_operand" "=r,r")
	(ashift:HI (match_dup 0)
                   (plus:HI (match_operand:HI 3 "const_int_operand" "i,i")
                            (match_operand:HI 4 "const_int_operand" "i,i"))))]
  ""
  [(set (match_dup 2)
        (match_dup 1))
   (set (match_dup 2)
        (ashift:QI (match_dup 2)
                   (match_dup 3)))]
  "")


;; TODO MGB tidy up - looks a bit convoluted
;;-------------------------------------------------------------------
;; Arithmetic shift right

(define_insn "ashrsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(ashiftrt:SI (match_operand:SI 1 "register_operand" "0,0")
		     (match_operand:HI 2 "shift_count_operand" "S,i")))
   (clobber (match_scratch:HI 3 "=&r,&r"))]
     ""
  {
    tms9900_debug_operands ("ashrsi3", operands, 3);
    rtx ops[7];
    ops[0] = operands[0];  /* Destination */
    ops[1] = operands[1];  /* Source */
    ops[2] = operands[2];  /* Shift count */
    ops[3] = operands[3];  /* Scratch reg */
    ops[4] = gen_rtx_REG (HImode, REGNO (operands[0]) + REGS_PER_WORD);  /* Low word of source */
    if(which_alternative == 0)
    {
      /* Variable shift */
      output_asm_insn("ci   %2, 16",  ops);  /* +0: Compare shift to 16 */
      output_asm_insn("jlt  $+16",    ops);  /* +4: If shift was < 16, goto lt_16 */
      output_asm_insn("jeq  $+4",     ops);  /* +6: If shift was 16, goto eq_16 */

      /* Shift count greater than 16 */
      output_asm_insn("sra  %1, %2",  ops);  /* +8: Shift high word */

      /* eq_16: Shift count equals 16 */
      output_asm_insn("mov  %1, %4",  ops);  /* +10: Copy high word to low word */ 
      output_asm_insn("seto %1",      ops);  /* +12: Assume negative value, set high word */
      output_asm_insn("jlt  $+4",     ops);  /* +14: If value was negative, skip next instruction */
      output_asm_insn("clr  %1",      ops);  /* +16: Clear high word */
      output_asm_insn("jmp  $+20",    ops);  /* +18: Goto end */

      /* lt_16: Shift count less than 16 */
      output_asm_insn("abs  %2",      ops);  /* +20: Test shift count */
      output_asm_insn("jeq  $+16",    ops);  /* +22: If shift==0, goto end */
      output_asm_insn("mov  %4, %3",  ops);  /* +24: Save high word to temp */
      output_asm_insn("sra  %1, %2",  ops);  /* +26: Shift high word */
      output_asm_insn("srl  %4, %2",  ops);  /* +28: Shift low word */
      output_asm_insn("neg  %2",      ops);  /* +30: Get complement of shift count */
      output_asm_insn("sla  %3, %2",  ops);  /* +32: Shift high word bits into low word position */
      output_asm_insn("soc  %3, %4",  ops);  /* +34: Merge shifted high word bits into low word */
      output_asm_insn("neg  %2",      ops);  /* +36: Restore shift count */
      /* +38: End */
    }
    else
    {
      /* Constant shift */
      int offset = INTVAL(operands[2]);
      ops[5] = GEN_INT(16-offset);  /* Complement of shift count */
      ops[6] = GEN_INT(offset%16);  /* Modulo of shift count */
  
      if(offset < 16)
      {
        output_asm_insn("mov  %1, %3",  ops);  /* Save high word to temp */
        output_asm_insn("sra  %1, %6",  ops);  /* Shift high word */
        output_asm_insn("srl  %4, %6",  ops);  /* Shift low word */
        output_asm_insn("sla  %3, %5",  ops);  /* Shift high word bits into low word position */
        output_asm_insn("soc  %3, %4",  ops);  /* Merge shifted high word bits into low word */
      } 
      else
      {
        if(offset > 16)
        {
          output_asm_insn("sra  %1, %6", ops);  /* Shift high word */
        }
        output_asm_insn("mov  %1, %4",  ops);  /* Copy high word to low word */ 
        output_asm_insn("seto %1",      ops);  /* Assume negative value, set high word */
        output_asm_insn("jlt  $+4",     ops);  /* If value was negative, skip next instruction */
        output_asm_insn("clr  %1",      ops);  /* Clear high word */
      }
    }
    return "";
  }
  [(set_attr "length" "38, 10")]
)


;;-------------------------------------
(define_insn "ashrhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(ashiftrt:HI (match_operand:HI 1 "register_operand" "0,0")
		     (match_operand:HI 2 "shift_count_operand" "S,i")))]
  ""
  {
    tms9900_debug_operands ("ashrhi3", operands, 3);
    if(which_alternative == 0)
    {
      output_asm_insn("abs  r0",     operands);
      output_asm_insn("jeq  $+4",    operands);
      output_asm_insn("sra  %0, 0",  operands);
    }
    else if(INTVAL(operands[2]) > 0)
    {
      output_asm_insn("sra  %0, %2", operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,2")])


;;-------------------------------------
(define_insn "ashrqi3"
  [(set (match_operand:QI 0 "register_operand" "=r,r")
	(ashiftrt:QI (match_operand:QI 1 "register_operand" "0,0")
		     (match_operand:HI 2 "shift_count_operand" "S,i")))]
  ""
  {
    tms9900_debug_operands ("ashrqi3", operands, 3);
    if(which_alternative == 0)
    {
      output_asm_insn("abs  r0",        operands);
      output_asm_insn("jeq  $+4",       operands);
      output_asm_insn("sra  %0, 0",     operands);
    }
    else if(INTVAL(operands[2]) > 0)
    {
      output_asm_insn("sra  %0, %2",    operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,2")])


;;-------------------------------------
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "r,r")
	(sign_extend:HI(match_operand:QI 1 "register_operand" "r,r")))
   (set (match_operand:HI 3 "register_operand" "r,r")
	(ashiftrt:HI (match_operand:HI 4 "register_operand" "0,0")
		     (match_operand:HI 5 "shift_count_operand" "S,i")))
   (set (match_operand:QI 6 "register_operand" "r,r")
        (subreg:QI (match_operand:HI 7 "register_operand" "3,3") 1))]
  ""
  [(set (match_dup 6)
        (match_dup 1))
   (set (match_dup 6)
        (ashiftrt:QI (match_dup 6)
                     (match_dup 5)))]
  "")


;;-------------------------------------------------------------------
;; Logical shift right


;;-------------------------------------
(define_insn "lshrsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(lshiftrt:SI (match_operand:SI 1 "register_operand" "0,0")
		     (match_operand:HI 2 "shift_count_operand" "S,i")))
   (clobber (match_scratch:HI 3 "=&r,&r"))]
     ""
  {
    tms9900_debug_operands ("lshrsi3", operands, 3);
    rtx ops[7];
    ops[0] = operands[0];  /* Destination */
    ops[1] = operands[1];  /* Source */
    ops[2] = operands[2];  /* Shift count */
    ops[3] = operands[3];  /* Scratch reg */
    ops[4] = gen_rtx_REG (HImode, REGNO (operands[0]) + REGS_PER_WORD);  /* Low word of source */
    if(which_alternative == 0)
    {
      /* Variable shift */
      output_asm_insn("ci   %2, 16",  ops);  /* +0: Compare shift to 16 */
      output_asm_insn("jlt  $+12",    ops);  /* +4: If shift was < 16, goto lt_16 */
      output_asm_insn("jeq  $+4",     ops);  /* +6: If shift was 16, goto eq_16 */

      /* Shift count greater than 16 */
      output_asm_insn("srl  %1, %2",  ops);  /* +8: Shift high word */

      /* eq_16: Shift count equals 16 */
      output_asm_insn("mov  %1, %4",  ops);  /* +10: Copy high word to low word */ 
      output_asm_insn("clr  %1",      ops);  /* +12: Clear high word */
      output_asm_insn("jmp  $+20",    ops);  /* +14: Goto end */

      /* lt_16: Shift count less than 16 */
      output_asm_insn("abs  %2",      ops);  /* +16: Test shift count */
      output_asm_insn("jeq  $+16",    ops);  /* +18: If shift==0, goto end */
      output_asm_insn("mov  %1, %3",  ops);  /* +20: Save high word to temp */
      output_asm_insn("srl  %1, %2",  ops);  /* +22: Shift high word */
      output_asm_insn("srl  %4, %2",  ops);  /* +24: Shift low word */
      output_asm_insn("neg  %2",      ops);  /* +26: Get complement of shift count */
      output_asm_insn("sla  %3, %2",  ops);  /* +28: Shift high word bits into low word position */
      output_asm_insn("soc  %3, %4",  ops);  /* +30: Merge shifted high word bits into low word */
      output_asm_insn("neg  %2",      ops);  /* +32: Restore shift count */
      /* +34: End */
    }
    else
    {
      /* Constant shift */
      int offset = INTVAL(operands[2]);
      ops[5] = GEN_INT(16-offset);  /* Complement of shift count */
      ops[6] = GEN_INT(offset%16);  /* Modulo of shift count */
  
      if(offset < 16)
      {
        if(offset == 8)
        {
          output_asm_insn("swpb %1",      ops);  /* Swap bytes in low word */
          output_asm_insn("swpb %4",      ops);  /* Swap bytes in high word */
          output_asm_insn("movb %1, %4",  ops);  /* Move MSB of high word */
          output_asm_insn("sb   %1, %1",  ops);  /* Clear MSB of high word */
        }
        else
        {
          output_asm_insn("mov  %1, %3",  ops);  /* Save high word to temp */
          output_asm_insn("srl  %1, %6",  ops);  /* Shift high word */
          output_asm_insn("srl  %4, %6",  ops);  /* Shift low word */
          output_asm_insn("sla  %3, %5",  ops);  /* Shift high word bits into low word position */
          output_asm_insn("soc  %3, %4",  ops);  /* Merge shifted high word bits into low word */
        }
      } 
      else
      {
        if(offset > 16)
        {
          output_asm_insn("srl  %1, %6", ops);  /* Shift high word */
        }
        output_asm_insn("mov  %1, %4",  ops);  /* Copy high word to low word */ 
        output_asm_insn("clr  %1",      ops);  /* Clear high word */
      }
    }
    return "";
  }
  [(set_attr "length" "34, 10")]
)


;;-------------------------------------
(define_insn "lshrhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(lshiftrt:HI (match_operand:HI 1 "register_operand" "0,0")
		     (match_operand:HI 2 "shift_count_operand" "S,i")))]
  ""
  {
    tms9900_debug_operands ("lshrhi3", operands, 3);
    if(which_alternative == 0)
    {
      output_asm_insn("abs  r0",     operands);
      output_asm_insn("jeq  $+4",    operands);
      output_asm_insn("srl  %0, 0",  operands);
    }
    else if(INTVAL(operands[2]) > 0)
    {
      output_asm_insn("srl  %0, %2", operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,2")])


;;-------------------------------------
(define_insn "lshrqi3"
  [(set (match_operand:QI 0 "register_operand" "=r,r")
	(lshiftrt:QI (match_operand:QI 1 "register_operand" "0,0")
		     (match_operand:HI 2 "shift_count_operand" "S,i")))]
  ""
  {
    tms9900_debug_operands ("lshrqi3", operands, 3);
    if(which_alternative == 0)
    {
      output_asm_insn("abs  r0",        operands);
      output_asm_insn("jeq  $+4",       operands);
      output_asm_insn("srl  %0, 0",     operands);
    }
    else if(INTVAL(operands[2]) > 0)
    {
      output_asm_insn("srl  %0, %2",    operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,2")])


(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "r,r")
	(sign_extend:HI(match_operand:QI 1 "register_operand" "r,r")))
   (set (match_operand:HI 3 "register_operand" "r,r")
	(lshiftrt:HI (match_operand:HI 4 "register_operand" "0,0")
		     (match_operand:HI 5 "shift_count_operand" "S,i")))
   (set (match_operand:QI 6 "register_operand" "r,r")
        (subreg:QI (match_operand:HI 7 "register_operand" "3,3") 1))]
  ""
  [(set (match_dup 6)
        (match_dup 1))
   (set (match_dup 6)
        (lshiftrt:QI (match_dup 6)
                     (match_dup 5)))]
  "")
      


;;-------------------------------------------------------------------
;; Rotate 


;;-------------------------------------
(define_expand "rotlhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (rotatert:HI (match_operand:HI 1 "register_operand" "0,0")
                     (match_operand:HI 2 "shift_count_operand" "S,i")))]
  ""
  {
    tms9900_debug_operands ("rotlhi3", operands, 3);
    if (GET_CODE (operands[2]) == CONST_INT)
      operands[2] = GEN_INT ((16 - INTVAL (operands[2])) % 16);
    else
      {
        rtx reg = gen_reg_rtx (HImode);
        emit_insn (gen_subhi3 (reg, GEN_INT (16), operands[2]));
        operands[2] = reg;
      }
  })


;;-------------------------------------
(define_insn "rotrhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (rotatert:HI (match_operand:HI 1 "register_operand" "0,0")
                     (match_operand:HI 2 "shift_count_operand" "S,i")))]
  ""
  "@
  src  %0, 0
  src  %0, %2" 
 [(set_attr "length" "2,2")])


;;-------------------------------------------------------------------
;;  Bitwise Operations
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; And


;;-------------------------------------
(define_insn "andhi3"
  [(clobber (match_scratch:HI 3 "=r,r,r,r,r,r,r"))
   (set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q,r,R>,Q")
	(and:HI (match_operand:HI 1 "nonimmediate_operand" "0,0,0,0,0,0,0")
		(match_operand:HI 2 "general_operand" "rR>,Q,rR>,Q,i,i,i")))]
  ""
  {
    tms9900_debug_operands ("andhi3", operands, 3);
    if(which_alternative >= 4)
    {
      int val = INTVAL(operands[2]) & 0xFFFF;
      if(val == 0)
      {
        /* Result will be zero */
        output_asm_insn("clr  %0", operands);
      }
      else if(val == 0xFFFF)
      {
        /* No operation required */
        return("");
      }
      else if(which_alternative == 4)
      {
        /* AND const value and register */
        output_asm_insn("andi %0, %2", operands);
      }
      else if(which_alternative >= 5)
      {
        /* AND const value and memory */
        operands[2] = GEN_INT(~val);
        output_asm_insn("li   %3, %2", operands);
        output_asm_insn("szc  %3, %0", operands);
      }
    }
    else
    {
      /* AND against non-const value */
      if(!rtx_equal_p(operands[2], operands[3]))
      {
        output_asm_insn("mov  %2, %3", operands);
      }
      output_asm_insn("inv  %3",     operands);
      output_asm_insn("szc  %3, %0", operands);
    }
    return(""); 
  }
  [(set_attr "length" "6,8,8,10,4,6,8")])


(define_insn "*andnothi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
	(and:HI (match_operand:HI 1 "nonimmediate_operand" "0,0,0,0")
		(not:HI (match_operand:HI 2 "nonimmediate_operand" "rR>,Q,rR>,Q"))))]
  ""
  "szc  %2, %0"
  [(set_attr "length" "2,4,4,6")])


; This handles reverse-order not-and combinations
(define_insn "*not_andhi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
	(and:HI (not:HI (match_operand:HI 1 "nonimmediate_operand" "rR>,Q,rR>,Q"))
                (match_operand:HI 2 "nonimmediate_operand" "0,0,0,0")))]
  ""
  "szc  %1, %0"
  [(set_attr "length" "2,4,4,6")])


;;-------------------------------------
; TODO condense the constraints
(define_insn "andqi3"
  [(clobber (match_scratch:QI 3 "=r,r,r,r,r,r,r,r,r,r,r,r"))
   (set (match_operand:QI 0 "nonimmediate_operand" "=r,R>,Q,r,R>,Q,r,R>,Q,r,R>,Q")
	(and:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0,0,0,0,0,0,0,0,0")
		(match_operand:QI 2 "general_operand" "r,r,r,R>,R>,R>,Q,Q,Q,i,i,i")))]
  ""
  {
    tms9900_debug_operands ("andqi3", operands, 3);
    int val;
    switch(which_alternative)
    {
    case 0:
      // output_asm_insn("mov  %2, %3", operands);
      // output_asm_insn("inv  %3", operands);
      // output_asm_insn("szc  %3, %0", operands);
      // break;
    case 1:
    case 2:
      // output_asm_insn("mov  %2, %3", operands);
      // output_asm_insn("inv  %3", operands);
      // output_asm_insn("swpb %3", operands);
      // output_asm_insn("szcb %3, %0", operands);
      // break;
    case 3:
    case 6:
      // output_asm_insn("movb %2, %3", operands);
      // output_asm_insn("srl  %3, 8", operands);
      // output_asm_insn("inv  %3", operands);
      // output_asm_insn("szc  %3, %0", operands);
      // break;
    case 4:
    case 5:
    case 7:
    case 8:
      output_asm_insn("movb %2, %3", operands);
      output_asm_insn("inv  %3", operands);
      output_asm_insn("szcb %3, %0", operands);
    case 9:
      val = INTVAL(operands[2]) & 0xFF00;
      /* AND const value and register */
      if(val == 0)
        output_asm_insn("clr  %0", operands);
      else if(val == 0xff00)
        return("");
      else
      {
        operands[2] = GEN_INT(val);
        output_asm_insn("andi %0, %2", operands);
      }
      break;
    case 10:
    case 11:
      val = INTVAL(operands[2]) & 0xFF00;
      /* AND const value and memory */
      if(val == 0)
        output_asm_insn("clr %0", operands);
      else if(val == 0xff00)
        return("");
      else
      {
        /*  In this case, we are putting a byte value to a memory location (R or
         *  Q) so we need the and mask to be in the MSB or register %3 */
        operands[2] = GEN_INT((~val)); // *256);
        output_asm_insn("li   %3, %2", operands);
        output_asm_insn("szcb %3, %0", operands);
      }
      break;
    }
    return("");
  }
  [(set_attr "length" "6,8,10,8,6,8,10,8,10,4,4,6")])


(define_insn "*andnotqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
	(and:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0")
		(not:QI (match_operand:QI 2 "nonimmediate_operand" "rR>,Q,rR>,Q"))))]
  ""
  "szcb %2, %0"
  [(set_attr "length" "2,4,4,6")])


; This handles reverse-order not-and combinations
(define_insn "*not_andqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q")
	(and:QI (not:QI (match_operand:QI 1 "nonimmediate_operand" "rR>,Q,rR>,Q"))
                (match_operand:QI 2 "nonimmediate_operand" "0,0,0,0")))]
  ""
  "szcb %1, %0"
  [(set_attr "length" "2,4,4,6")])


;;-------------------------------------------------------------------
;; Or


;;-------------------------------------
(define_insn "iorhi3"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q,r,r")
	(ior:HI (match_operand:HI 1 "nonimmediate_operand" "%0,0,0,0,0,0")
		(match_operand:HI 2 "general_operand" "rR>,Q,rR>,Q,i,M")))]
  ""
  {
    tms9900_debug_operands ("iorhi3", operands, 3);
    if (GET_CODE (operands[2]) == CONST_INT)
      {
        int val = INTVAL(operands[2]) & 0xFFFF;
        if(val == 0xFFFF)
          return "seto %0";
        else if(val == 0)
          return "";
        else
          return "ori  %0, %2";
      }
    return "soc  %2, %0";
  }
  [(set_attr "length" "2,4,4,6,4,2")])


;;-------------------------------------
(define_insn "iorqi3"
   [(set (match_operand:QI 0 "nonimmediate_operand" "=r,R>,Q,r,R>,Q,r,R>,Q,r")
	(ior:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0,0,0,0,0,0,0")
		(match_operand:QI 2 "general_operand" "r,r,r,R>,R>,R>,Q,Q,Q,i")))]
  ""
  {
    tms9900_debug_operands ("iorqi3", operands, 3);
    int val;
    switch(which_alternative)
    {
    case 0:
      // output_asm_insn("soc  %2, %0", operands);
      // break;
    case 1:
    case 2:
      // output_asm_insn("swpb %2", operands);
      // output_asm_insn("socb %2, %0", operands);
      // output_asm_insn("swpb %2", operands);
      // break;
    case 3:
    case 6:
      // output_asm_insn("swpb %0", operands);
      // output_asm_insn("socb %3, %0", operands);
      // output_asm_insn("swpb %0", operands);
      // break;
    case 4:
    case 5:
    case 7:
    case 8:
      output_asm_insn("socb %3, %0", operands);
    case 9:
      val = INTVAL(operands[2]) & 0xFF00;
      /* AND const value and register */
      if(val == 0)
        return("");
      else if(val == 0xff00)
        // TODO this isn't valid if dest is a byte mem loc
        output_asm_insn("seto %0", operands);
      else
      {
        operands[2] = GEN_INT(val);
        output_asm_insn("ori  %0, %2", operands);
      }
      break;
    }
    return("");
  }
  [(set_attr "length" "2,6,8,6,2,4,6,2,4,4")])


;;-------------------------------------------------------------------
;; Xor


;;-------------------------------------
(define_insn "xorhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(xor:HI (match_operand:HI 1 "register_operand" "%0,0")
		(match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  "xor  %2, %0"
  [(set_attr "length" "2,4")])


;;-------------------------------------
;; This works for regs only as xor is 16-bit only and should not be used on
;; memory locations as it will affect the neighbouring byte
(define_insn "xorqi3"
  [(set (match_operand:QI 0 "register_operand" "=r")
	(xor:QI (match_operand:QI 1 "register_operand" "%0")
		(match_operand:QI 2 "nonimmediate_operand" "r")))]
  ""
  "xor  %2, %0"
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Not
;;-------------------------------------
(define_insn "one_cmplhi2"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
        (not:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))]
  ""
  "inv  %0"
  [(set_attr "length" "2,4")])


;;-------------------------------------
;; This works for regs only as inv is 16-bit only and should not be used on
;; memory locations as it will affect the neighbouring byte
(define_insn "one_cmplqi2"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=r")
        (not:QI (match_operand:QI 1 "nonimmediate_operand" "0")))]
  ""
  "inv  %0"
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;;  Arithmetic Operations
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Add
;; TODO convert to expand
;;-------------------------------------
(define_insn "addsi3"
  [(set (match_operand:SI 0 "nonimmediate_operand"          "=r,r,r,r,r,r, R,R,R,R,R,R, Q,Q,Q,Q,Q,Q")
	(plus:SI (match_operand:SI 1 "nonimmediate_operand" "%0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0")
		 (match_operand:SI 2 "general_operand"       "r,R,Q,I,J,K, r,R,Q,I,J,K, r,R,Q,I,J,K")))
   (clobber (match_scratch:HI 3                             "=r,r,r,r,r,r, r,r,r,r,r,r, r,r,r,r,r,r"))]
  ""
  { 
    tms9900_debug_operands ("addsi3", operands, 3);
    rtx low_words[4];
    rtx offset[3];
    low_words[3] = operands[3];

    if(REG_P (operands[0]))
      low_words[0] = gen_rtx_REG (HImode, REGNO (operands[0]) + REGS_PER_WORD);
    else
      low_words[0] = adjust_address (operands[0], HImode, 2);

    if(which_alternative >= 12)
      offset[0] = GEN_INT(6);
    else
      offset[0] = GEN_INT(4);
  
    if(! CONSTANT_P(operands[2]))
    {
      /* Adding two variables */
      if(REG_P (operands[2]))
        low_words[2] = gen_rtx_REG (HImode, REGNO (operands[2]) + REGS_PER_WORD);
      else
        low_words[2] = adjust_address (operands[2], HImode, 2);

      output_asm_insn("a    %2, %0", operands);
      output_asm_insn("a    %2, %0", low_words);
      output_asm_insn("jnc  $+%0",   offset);
      output_asm_insn("inc  %0",     operands);
      return("");
    }
    else
    {
      /* Adding a constant */
      int low_const  =  INTVAL(operands[2])        & 0xffff;
      int high_const = (INTVAL(operands[2]) >> 16) & 0xffff;
      low_words[2] = GEN_INT(low_const);
      operands[2]  = GEN_INT(high_const);

      if(low_const != 0)
      {
        switch(low_const)
        {
          case 0xFFFE: output_asm_insn("dect %0",     low_words); break;
          case 0xFFFF: output_asm_insn("dec  %0",     low_words); break;
          case      1: output_asm_insn("inc  %0",     low_words); break;
          case      2: output_asm_insn("inct %0",     low_words); break;
          default:
            if(REG_P(operands[0]))
              output_asm_insn("ai   %0, %2", low_words);
            else
            {
              output_asm_insn("li   %3, %2", low_words);              
              output_asm_insn("a    %3, %0", low_words);              
            }
        }
        /* DEC and DECT use inverted carry flags */
        /*
        if(low_const == 0xFFFF || low_const == 0xFFFE)
          output_asm_insn("joc  $+%0",   offset);
        else
        */
          output_asm_insn("jnc  $+%0",   offset);

        /* Handle carry to high word */
        output_asm_insn("inc  %0",     operands);
      }
      if(high_const != 0)
      {
        switch(high_const)
        {
          case 0xFFFE: output_asm_insn("dect %0",     operands); break;
          case 0xFFFF: output_asm_insn("dec  %0",     operands); break;
          case      1: output_asm_insn("inc  %0",     operands); break;
          case      2: output_asm_insn("inct %0",     operands); break;
          default:
            if(REG_P(operands[0]))
              output_asm_insn("ai   %0, %2", operands);
            else
            {
              output_asm_insn("li   %3, %2", operands);              
              output_asm_insn("a    %3, %0", operands);              
            }
        }
      }
    }

    return("");
  }
  [(set_attr "length" "8,10,14,4,8,12, 10,12,16,6,12,16,  14,16,18,8,16,20")])


;;-------------------------------------
(define_insn "addhi3"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q,r,rR>,Q")
	(plus:HI (match_operand:HI 1 "nonimmediate_operand" "%0,0,0,0,0")
		 (match_operand:HI 2 "general_operand" "rR>LMNO,rR>LNMO,i,Q,Q")))]
  ""
  {
    tms9900_debug_operands ("addhi3", operands, 3);
    switch(GET_CODE(operands[2]))
    {
      case CONST_INT:
      {
        if (INTVAL(operands[2]) == 1)
	  return("inc  %0");
        else if (INTVAL(operands[2]) == -1)
          return("dec  %0");
        else if (INTVAL(operands[2]) == 2)
          return("inct %0");
        else if (INTVAL(operands[2]) == -2)
          return("dect %0");
        else
          return("ai   %0, %2");
      }

      case MEM:
      case REG:
        return ("a    %2, %0");

      default:
          return("ai   %0, %2");
    }
  }
  [(set_attr "length" "2,4,4,4,6")])


;;-------------------------------------
(define_insn "addqi3"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,rR>,Q,Q,r")
	(plus:QI (match_operand:QI 1 "nonimmediate_operand" "%0,0,0,0,0")
		 (match_operand:QI 2 "general_operand" "rR>,Q,rR>,Q,i")))]
  ""
  {
    tms9900_debug_operands ("addqi3", operands, 3);
  if (GET_CODE (operands[2]) == CONST_INT)
    {
      operands[2] = GEN_INT(INTVAL(operands[2]) * 256);
      return("ai   %0, %2");
    }
  return("ab   %2, %0");
  }
  [(set_attr "length" "2,4,4,6,4")])


;;-------------------------------------------------------------------
;; Subtract


;;-------------------------------------
(define_insn "subsi3"
  [(set (match_operand:SI 0 "nonimmediate_operand"          "=r,r,r,r,r,r,R,R,R,R,R,R,Q,Q,Q,Q,Q,Q")
	(minus:SI (match_operand:SI 1 "nonimmediate_operand" "0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0")
		  (match_operand:SI 2 "general_operand"      "r,R,Q,I,J,K,r,R,Q,I,J,K,r,R,Q,I,J,K")))]
  ""
  {
    tms9900_debug_operands ("subsi3", operands, 3);
    rtx lateoperands[3];
    rtx offset[3];

    lateoperands[0] = operands[0];
    if(REG_P(operands[0]))
    {
      operands[0] = gen_rtx_REG(HImode, REGNO (operands[0]) + REGS_PER_WORD);
      offset[0] = GEN_INT(4);
    }
    else
    {
      operands[0] = adjust_address(operands[0], HImode, 2);
      offset[0] = GEN_INT(6);
    }
  
    if(! CONSTANT_P(operands[2]))
    {
      lateoperands[2] = operands[2];

      if(REG_P(operands[2]))
        operands[2] = gen_rtx_REG(HImode, REGNO (operands[2]) + REGS_PER_WORD);
      else
        operands[2] = adjust_address(operands[2], HImode, 2);

      output_asm_insn("s    %2, %0", lateoperands);
      output_asm_insn("s    %2, %0", operands);
      output_asm_insn("joc  $+%0", offset);
      output_asm_insn("dec  %0", lateoperands);
      return("");
    }
    /* EMW - This never seems to be called... */
    lateoperands[2] = GEN_INT((INTVAL(operands[2]) >> 16) & 0xffff);
    operands[2] = GEN_INT(INTVAL(operands[2]) & 0xffff);
  
    if(INTVAL(operands[2]))
    { 
      output_asm_insn("ai   %0, %2", operands);
      output_asm_insn("jnc  $+%0", offset);
      output_asm_insn("dec  %0", lateoperands);
    }
    if(INTVAL(lateoperands[2]))
    {
      operands[2] = GEN_INT(-INTVAL(operands[2]));
      output_asm_insn("ai   %0, %2", lateoperands);
    }
    return("");
  }
  [(set_attr "length" "8,10,12,4,8,12, 12,14,16,4,12,16,  16,18,18,6,12,18")])


;;-------------------------------------
(define_insn "subhi3"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q,rR>,Q,rR>,Q,rR>,Q")
	(minus:HI (match_operand:HI 1 "nonimmediate_operand" "0,0,0,0,rR>,rR>,Q,Q")
		  (match_operand:HI 2 "nonimmediate_operand" "rR>,rR>,Q,Q,0,0,0,0")))]
  ""
  {
    tms9900_debug_operands ("subhi3", operands, 3);
    if(which_alternative < 4)
    {
      output_asm_insn("s    %2, %0",operands);
    }
    else
    {
      output_asm_insn("s    %1, %0",operands);
      output_asm_insn("neg  %0",operands);
    }
    return("");
  }
  [(set_attr "length" "2,4,4,6, 4,6,8,10")])


;;-------------------------------------
(define_insn "*rsubihi"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(minus:HI (match_operand:HI 1 "immediate_operand" "i")
		  (match_operand:HI 2 "register_operand" "0")))]
  ""
  {
    if (INTVAL(operands[1]) == -1)
      output_asm_insn("inc  %0",operands);
    else if (INTVAL(operands[1]) == 1)
      output_asm_insn("dec  %0",operands);
    else if (INTVAL(operands[1]) == -2)
      output_asm_insn("inct %0",operands);
    else if (INTVAL(operands[1]) == 2)
      output_asm_insn("dect %0",operands);
    else
    {
      operands[1] = GEN_INT(-INTVAL(operands[1]));
      output_asm_insn("ai   %0, %1",operands);
    }
    output_asm_insn("neg  %0",operands);
    return "";
  }
  [(set_attr "length" "6")])


;;-------------------------------------
;; MGB TODO why negate?  In case operands are swapped. Why not just constrain
;; the compiler?
(define_insn "subqi3"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=rR>,Q,rR>,Q,rR>,Q,rR>,Q")
	(minus:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0,rR>,rR>,Q,Q")
		  (match_operand:QI 2 "nonimmediate_operand" "rR>,rR>,Q,Q,0,0,0,0")))]
  ""
  {
    tms9900_debug_operands ("subqi3", operands, 3);
    if(which_alternative < 4)
    {
      output_asm_insn("sb   %2, %0",operands);
    }
    else
    {
      output_asm_insn("sb   %1, %0",operands);
      output_asm_insn("neg  %0",operands);
    }
    return("");
  }
  [(set_attr "length" "2,4,4,6, 4,6,8,10")])


;;-------------------------------------------------------------------
;; Multiply
;;
;; TODO change this to be an expand
;;-------------------------------------
(define_insn "mulsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r,r")
        (mult:SI (match_operand:SI 1 "register_operand" "0,0,0")
                 (match_operand:SI 2 "nonimmediate_operand"  "r,R,Q")))
   (clobber (match_scratch:HI 3 "=r,r,r"))
   (clobber (match_scratch:HI 4 "=r,r,r"))]
  ""
  {
    tms9900_debug_operands ("mulsi3", operands, 3);
    rtx args[6];

    args[0] = operands[0];  // Destination R
    args[1] = gen_lowpart_SUBREG(HImode, operands[0]);

    args[2] = operands[2];  // Source G
    if(REG_P(operands[2]))
    {
      args[3] = gen_lowpart_SUBREG(HImode, operands[2]);
    }
    else
    {
      args[3] = adjust_address(operands[2], HImode, 2);
    }

    args[4] = operands[3];  // Temp
    args[5] = operands[4];  // Hold

    /*
    Since we only have a 16-bit multiply, we need to expand
    this math.

    (R0*N+R1)*(G0*N+G1) = R0*G0*N*N + R0*G1*N + R1*G0*N + R1*G1

    We can omit the R0*G0 term since it won't fit into 32 bits
    */

    output_asm_insn("mov  %1, %5",args);  // H = R1
    output_asm_insn("mpy  %3, %0",args);  // [R0,R1] = R0*G1
    output_asm_insn("mov  %1, %4",args);  // T = LSW(R0*G1)
    output_asm_insn("mov  %5, %0",args);  // R0 = H
    output_asm_insn("mpy  %2, %0",args);  // [R0,R1] = R1*G0
    output_asm_insn("a    %1, %4",args);  // T += LSW(R1*G0)
    output_asm_insn("mov  %5, %0",args);  // R0 = H
    output_asm_insn("mpy  %3, %0",args);  // [R0,R1] = R1*G1
    output_asm_insn("a    %4, %0",args);  // R0 += T
    return("");
  }
  [(set_attr "length" "18,22,26")])

;;-------------------------------------
; Expand for signed HI = QI x QI
; TODO check sign of highpart of HI
(define_expand "mulqihi3"
   [(set (match_operand:HI 0 "register_operand" "=r")
        (mult:HI (match_operand:QI 1 "register_operand" "r")
                 (match_operand:QI 2 "register_operand" "rRQ>")))]
  ""
  {
    tms9900_debug_operands ("mulqihi3", operands, 3);

    rtx result = gen_reg_rtx (SImode);
    rtx op1 = gen_reg_rtx (HImode);
    rtx op2 = gen_reg_rtx (HImode);
    emit_insn (gen_extendqihi2 (op1, operands[1]));
    emit_insn (gen_extendqihi2 (op2, operands[2]));
    emit_move_insn(gen_highpart (HImode, result), op1);
    emit_insn(gen_mulnative(result, result, op2));
    emit_move_insn (operands[0], gen_lowpart (HImode, result));
    DONE;
  }
)

;;-------------------------------------
; Expand for unsigned HI = QI x QI
;
(define_expand "umulqihi3"
   [(set (match_operand:HI 0 "register_operand" "=r")
        (mult:HI (match_operand:QI 1 "register_operand" "r")
                 (match_operand:QI 2 "register_operand" "rRQ>")))]
  ""
  {
    tms9900_debug_operands ("umulqihi3", operands, 3);

    rtx result = gen_reg_rtx (SImode);
    rtx op1 = gen_reg_rtx (HImode);
    rtx op2 = gen_reg_rtx (HImode);
    // TODO is this allowed?  extend expects both regs to be the same
    emit_insn (gen_zero_extendqihi2 (op1, operands[1]));
    emit_insn (gen_zero_extendqihi2 (op2, operands[2]));
    emit_move_insn(gen_highpart (HImode, result), op1);
    emit_insn(gen_mulnative(result, result, op2));
    emit_move_insn (operands[0], gen_lowpart (HImode, result));
    DONE;
  }
)

;;-------------------------------------
; Expand for signed SI = HI x HI
;
(define_expand "mulhisi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(mult:SI (zero_extend (match_operand:HI 1 "register_operand" "=r,r"))
		 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("mulqihi3", operands, 3);

    rtx result = gen_reg_rtx (SImode);
    emit_move_insn(gen_highpart (HImode, result), operands[1]);
    emit_insn(gen_mulnative(result, result, operands[2]));
    emit_move_insn (operands[0], result);
    DONE;
  }
)

;;-------------------------------------
; Expand for unsigned SI = HI x HI
;
(define_expand "umulhisi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(mult:SI (zero_extend (match_operand:HI 1 "register_operand" "=r,r"))
		 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("umulhisi3", operands, 3);

    rtx result = gen_reg_rtx (SImode);
    emit_move_insn(gen_highpart (HImode, result), operands[1]);
    emit_insn(gen_mulnative(result, result, operands[2]));
    emit_move_insn (operands[0], result);
    DONE;
  }
)

;;-------------------------------------
; expand HI=HIxHI to native SI=SIxHI

(define_expand "mulhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (mult:HI (match_operand:HI 1 "register_operand" "+0,0")
                 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("mulhi3", operands, 3);

    rtx result = gen_reg_rtx (SImode);
    emit_move_insn(gen_highpart (HImode, result), operands[1]);
    emit_insn(gen_mulnative(result, result, operands[2]));
    emit_move_insn (operands[0], gen_lowpart (HImode, result));
    DONE;
   }
)

;;-------------------------------------
; This is the native multiplication on the tms9900.  SI=HIxHI
;  Note it is expected that op1 == op0 so we specify that op1 is SI.
;  All other variants, QIxQI, etc, should expand to this insn.
;  Also, mpy is unsigned so signed variants need to expand differently.
;  Signed vs unsigned makes no difference if operands and results are the same
;  size but will yield wrong results if result is wider than operands.

(define_insn "mulnative"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(mult:SI (match_operand:SI 1 "register_operand" "0,0")
		 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
  ""
  {
    tms9900_debug_operands ("mulnative", operands, 3);
    return ("mpy  %2, %0");
  }
  [(set_attr "length" "2,4")])

;;-------------------------------------
;; byte mul can only work in registers as we need to expand to HI mode

(define_expand "udivmodqi4"
  [(parallel [
     (set (match_operand:QI 0 "register_operand" "=r")
          (div:QI (match_operand:QI 1 "register_operand" "0")
                  (match_operand:QI 2 "register_operand" "r")))
     (set (match_operand:QI 3 "register_operand" "=r")
          (mod:QI (match_dup 1) 
                  (match_dup 2)))])]
  ""
  {
    tms9900_debug_operands ("udivmodqi4", operands, 4);

    /* Move and extend QI dividend to SI */
    rtx dividend = gen_reg_rtx (SImode);
    rtx scratch = gen_reg_rtx (HImode);
    emit_insn(gen_zero_extendqihi2 (scratch, operands[1]));
    emit_insn(gen_zero_extendhisi2 (dividend, scratch));

    /* Extend the divisor */
    rtx divisor = gen_reg_rtx (HImode);
    emit_insn(gen_zero_extendqihi2 (divisor, operands[2]));

    /* Do the division */
    emit_insn(gen_udivmodsihi3(dividend, dividend, divisor));

    /* Convert and store quotient from HI to QI */
    rtx quotient = gen_reg_rtx (HImode);
    emit_move_insn (quotient, gen_highpart (HImode, dividend));
    emit_insn(gen_trunchiqi2 (operands[0], quotient));

    /* Convert and store quotient from HI to QI */
    rtx remainder = gen_reg_rtx (HImode);
    emit_move_insn (remainder, gen_lowpart (HImode, dividend));
    emit_insn(gen_trunchiqi2 (operands[3], remainder));
    DONE;
  })

(define_expand "udivmodhi4"
  [(parallel [
     (set (match_operand:HI 0 "register_operand" "=r,r")
          (div:HI (match_operand:HI 1 "register_operand" "+0,0")
                  (match_operand:HI 2 "nonimmediate_operand" "+rR>,Q")))
     (set (match_operand:HI 3 "register_operand" "=r,r")
          (mod:HI (match_dup 1) 
                  (match_dup 2)))])]
  ""
  {
    tms9900_debug_operands ("udivmodhi4", operands, 4);
    rtx dividend = gen_reg_rtx (SImode);
    rtx tmp = gen_reg_rtx (HImode);
    emit_move_insn(tmp, operands[1]);
    emit_insn(gen_zero_extendhisi2 (dividend, tmp));
    emit_insn(gen_udivmodsihi3(dividend, dividend, operands[2]));
    emit_move_insn (operands[0], gen_highpart (HImode, dividend));
    emit_move_insn (operands[3], gen_lowpart (HImode, dividend));
    DONE;
  })



;;-------------------------------------
;; Signed div/mod.  Native method is unsigned so record the sign of the result
;; by xor'ing operands together to examine highest bit.  Then take abs of operands.
;; Correct the sign of the quotient after the operation
(define_expand "divmodqi4"
  [(parallel [
     (set (match_operand:QI 0 "register_operand" "=r,r")
          (div:QI (match_operand:QI 1 "register_operand" "0,0")
                  (match_operand:QI 2 "nonimmediate_operand" "rR>,Q")))
     (set (match_operand:QI 3 "register_operand" "=r,r")
          (mod:QI (match_dup 1) 
                  (match_dup 2)))])]
  ""
  {
    tms9900_debug_operands ("divmodqi4", operands, 4);

    /* Find quotient sign */
    rtx sign = gen_reg_rtx (HImode); // sign of quotient
    emit_insn(gen_extendqihi2 (operands[1], sign));
    // emit_move_insn(sign, operands[1]);
    emit_insn(gen_extendqihi2 (operands[2], operands[2]));
    emit_insn(gen_xorhi3(sign, sign, operands[2]));

    /* Use temp for operand2 and get abs value */
    rtx divisor = gen_reg_rtx (HImode);
    emit_move_insn(divisor, operands[2]);
    emit_insn(gen_abshi2(divisor, divisor));

    /* Use temp for operand1, get absolute value and extend to SI.  We don't
     * have abssi2 so do abs on a tmp before extend  */
    rtx dividend = gen_reg_rtx (SImode);
    rtx tmp = gen_reg_rtx (HImode);
    emit_move_insn(tmp, operands[1]);
    emit_insn(gen_abshi2(tmp, tmp));
    emit_insn(gen_extendhisi2 (dividend, tmp));

    /* Perform division and modulus */
    emit_insn(gen_udivmodsihi3(dividend, dividend, divisor));

    /* Convert and store quotient from HI to QI */
    rtx quotient = gen_reg_rtx (HImode);
    emit_move_insn (quotient, gen_highpart (HImode, dividend));

    /* Correct sign of quotient */
    emit_insn(gen_divfixuphi2(quotient, sign));

    /* Convert and store quotient from HI to QI */
    emit_insn(gen_trunchiqi2 (operands[0], quotient));

    /* Convert and store remainder from HI to QI */
    rtx remainder = gen_reg_rtx (HImode);
    emit_move_insn (remainder, gen_lowpart (HImode, dividend));
    emit_insn(gen_trunchiqi2 (operands[3], remainder));

    DONE;
  }
)


(define_expand "divmodhi4"
  [(parallel [
     (set (match_operand:HI 0 "register_operand" "=r,r")
          (div:HI (match_operand:HI 1 "register_operand" "0,0")
                  (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))
     (set (match_operand:HI 3 "register_operand" "=r,r")
          (mod:HI (match_dup 1) 
                  (match_dup 2)))])]
  ""
  {
    tms9900_debug_operands ("divmodhi4", operands, 4);
    // rtx insn, div_equal, mod_equal, equal;

    /* Find quotient sign */
    rtx sign = gen_reg_rtx (HImode); // sign of quotient
    emit_move_insn(sign, operands[1]);
    emit_insn(gen_xorhi3(sign, sign, operands[2]));

    /* Use temp for operand2 and get abs value */
    rtx divisor = gen_reg_rtx (HImode);
    emit_move_insn(divisor, operands[2]);
    emit_insn(gen_abshi2(divisor, divisor));

    /* Use temp for operand1, get absolute value and extend to SI.  We don't
     * have abssi2 so do abs on a tmp before extend  */
    rtx dividend = gen_reg_rtx (SImode);
    rtx tmp = gen_reg_rtx (HImode);
    emit_move_insn(tmp, operands[1]);
    emit_insn(gen_abshi2(tmp, tmp));
    emit_insn(gen_extendhisi2 (dividend, tmp));

    /* Perform division and modulus */
    emit_insn(gen_udivmodsihi3(dividend, dividend, divisor));
    emit_move_insn (operands[0], gen_highpart (HImode, dividend));
    emit_move_insn (operands[3], gen_lowpart (HImode, dividend));

    /* Correct sign of quotient */
    emit_insn(gen_divfixuphi2(operands[0], sign));

    DONE;
  }
)


;;-------------------------------------------------------------------
;; Divide and Modulus
;; native method HI = SI / HI , HI = SI % HI
;;-------------------------------------
(define_insn "udivmodsihi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
        (ior:SI
          (ashift:SI
            (zero_extend:SI
              (div:HI (match_operand:SI 1 "register_operand" "0,0")
                      (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))
            (const_int 16))
          (zero_extend:SI 
            (mod:HI (match_dup 1)
                    (match_dup 2)))))]
  ""
  {
    tms9900_debug_operands ("udivmodsihi3", operands, 3);
    output_asm_insn ("div  %2, %0", operands);
    return("");
  }
  [(set_attr "length" "2,4")])



(define_insn "divfixuphi2"
  [(set (match_operand:HI 1 "register_operand" "=r")
        (not:HI (match_dup 1)))
   (set (match_operand:HI 0 "register_operand" "=r")
        (if_then_else:HI (lt:HI (match_dup 1) (const_int 0))
           (neg:HI (match_dup 0)) (match_dup 0)))]
  ""
  {
    tms9900_debug_operands ("divfixuphi2", operands, 2);
    output_asm_insn("inv  %1", operands);
    output_asm_insn("jlt  $+4", operands);
    output_asm_insn("neg  %0", operands);
    return("");
  }
  [(set_attr "length" "6")])


;;-------------------------------------------------------------------
;; Absolute Value

;;-------------------------------------
(define_insn "abshi2"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
	(abs:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))]
  ""
  {
    tms9900_debug_operands ("abshi2", operands, 2);
    output_asm_insn ("abs  %0", operands);
    return("");
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------
;; register only as abs is 16-bit
(define_insn "absqi2"
  [(set (match_operand:QI 0 "register_operand" "=r")
	(abs:QI (match_operand:QI 1 "register_operand" "0")))]
  ""
  {
    tms9900_debug_operands ("absqi2", operands, 2);
    output_asm_insn ("abs  %0", operands);
    return("");
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Negate
; TODO expand into 2 x neghi2
;;-------------------------------------

(define_insn "negsi2"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR,Q")
	(neg:SI (match_operand:SI 1 "nonimmediate_operand" "0,0")))]
  ""
  {
    tms9900_debug_operands ("negsi2", operands, 2);
    rtx word[2];
    rtx offset[1];

    /* word 0 is most significant */
    word[0] = operands[0];
    if (REG_P (operands[0]))
    {
      word[1] = gen_rtx_REG(HImode, REGNO(operands[0]) + REGS_PER_WORD);
      offset[0] = GEN_INT(4);
    }
    else
    {
      word[1] = adjust_address(operands[0], HImode, 2);
      offset[0] = GEN_INT(6);
    }
    output_asm_insn("inv  %0", word);
    output_asm_insn("neg  %1", word);
    output_asm_insn("jnc  $+%0", offset);
    output_asm_insn("inc  %0", word);
    return("");
  }
  [(set_attr "length" "8,14")])


;;-------------------------------------
(define_insn "neghi2"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
	(neg:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))]
  ""
  {
    tms9900_debug_operands ("neghi2", operands, 2);
    output_asm_insn("neg  %0", operands);
    return("");
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------
;; TODO andi only reqiured for strict
(define_insn "negqi2"
  [(set (match_operand:QI 0 "register_operand" "=r")
	(neg:QI (match_operand:QI 1 "register_operand" "0")))]
  ""
  {
    tms9900_debug_operands ("negqi2", operands, 2);
    output_asm_insn("andi %0, 0xFF00", operands);
    output_asm_insn("neg  %0", operands);
    return("");
  }
  [(set_attr "length" "6")])


;;-------------------------------------------------------------------
;; Other Instructions
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; No-op
(define_insn "nop"
  [(const_int 0)]
  ""
  "nop"
  [(set_attr "length" "2")])



;;-------------------------------------------------------------------
;;  Optimizations For Comparisons
;;-------------------------------------------------------------------

;;-------------------------------------------------------------------
;; Optimization for X == {-2,-1,1,2}
(define_peephole2
  [(set (cc0)
	(compare (match_operand:HI 0 "register_operand" "r")
		 (match_operand:HI 1 "immediate_operand" "LMNO")))
   (set (pc) (if_then_else (eq (cc0) (const_int 0))
                           (label_ref (match_operand 2 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(2, operands[0])"
  [(set (match_operand:HI 0 "register_operand" "")
	(plus:HI (match_dup 0) (neg:HI (match_dup 1))))
   (set (cc0) (match_dup 0))
   (set (pc) (if_then_else (eq (cc0) (const_int 0))
                           (label_ref (match_dup 2))
                           (pc)))]
  )


(define_insn "*sub_const_hi"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
        (plus:HI (match_operand:HI 1 "register_operand" "0,0")
                 (neg:HI (match_operand:HI 2 "immediate_operand" "LMNO, i"))))]
  ""
  {
    operands[2] = GEN_INT(-INTVAL(operands[2]));
    switch(INTVAL(operands[2]))
    {
      case -2: output_asm_insn("dect %0",     operands); break;
      case -1: output_asm_insn("dec  %0",     operands); break;
      case  1: output_asm_insn("inc  %0",     operands); break;
      case  2: output_asm_insn("inct %0",     operands); break;
      default: output_asm_insn("ai   %0, %2", operands); break;
    }
    return("");
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------------------------------------
;; Optimization for X != {-2,-1,1,2}
(define_peephole2
  [(set (cc0)
	(compare (match_operand:HI 0 "register_operand" "r")
		 (match_operand:HI 1 "immediate_operand" "LMNO")))
   (set (pc) (if_then_else (ne (cc0) (const_int 0))
                           (label_ref (match_operand 2 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(2, operands[0])"
  [(set (match_operand:HI 0 "register_operand" "")
	(plus:HI (match_dup 0) (neg:HI (match_dup 1))))
   (set (cc0) (match_dup 0))
   (set (pc) (if_then_else (ne (cc0) (const_int 0))
                           (label_ref (match_dup 2))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;;  Optimizations For Byte Compares
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X > N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (gtu (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 255)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (gtu (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )

;; TODO assume this can be deleted
(define_insn "*cmpqi_as_hi"
  [(set (cc0)
      (compare (match_operand:QI 0 "register_operand" "r")
         (plus:HI (match_operand:HI 1 "const_int_operand" "i")
            (mult:HI (match_operand:HI 2 "const_int_operand" "i")
               (match_operand:HI 3 "const_int_operand" "i")))))]
  "INTVAL(operands[3]) == 256 && (INTVAL(operands[1]) == 0 || INTVAL(operands[1]) == 255)"
  {
    operands[1] = GEN_INT(INTVAL(operands[2]) * 256 + INTVAL(operands[1]));
    return("ci   %0, %1");
  }
  [(set_attr "length" "4")])


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X < N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (ltu (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 0)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (ltu (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X >= N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (geu (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 0)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (geu (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X <= N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (leu (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 255)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (leu (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;; Optimization for (char)X > N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (gt (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 255)
                          (mult:HI (match_dup 1)
                                  (const_int 256)))))
   (set (pc) (if_then_else (gt (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;; Optimization for (char)X < N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (lt (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 0)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (lt (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;; Optimization for (char)X >= N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (ge (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 0)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (ge (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;; Optimization for (char)X <= N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (match_operand:QI 1 "const_int_operand" "i"))
   (set (cc0)
        (compare (match_operand:QI 2 "register_operand" "r")
                 (match_dup 0)))
   (set (pc) (if_then_else (le (cc0) (const_int 0))
                           (label_ref (match_operand 3 "" ""))
                           (pc)))]
  "peep2_reg_dead_p(3, operands[0])"
  [(set (cc0)
        (compare (match_dup 2)
                 (plus:HI (const_int 255)
                          (mult:HI (match_dup 1)
                                   (const_int 256)))))
   (set (pc) (if_then_else (le (cc0) (const_int 0))
                           (label_ref (match_dup 3))
                           (pc)))]
  )


;;-------------------------------------------------------------------
;;  Optimizations For Bit Shift And Cast
;;-------------------------------------------------------------------


;;-------------------------------------------------------------------
;; Optimization for (char)X = (int X) >> N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashiftrt:HI (match_dup 0)
            (match_operand:HI 1 "const_int_operand" "i")))
   (set (match_operand:QI 2 "register_operand" "=r")
        (subreg:QI (match_dup 0) 1))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 0)
        (ashiftrt:HI (match_dup 0)
            (minus:HI (match_dup 1) 
                      (const_int 8))))]
  )

(define_insn "*ashiftrt_hi_to_qi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashiftrt:HI (match_dup 0)
            (minus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    int shift = INTVAL (operands[1]);
    if(shift < 8)
    {
      operands[1] = GEN_INT(8 - shift);
      output_asm_insn("sla  %0, %1", operands);
    }
    else if(shift > 8)
    {
      operands[1] = GEN_INT(shift - 8);
      output_asm_insn("sra  %0, %1", operands);
    }
    return "";
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (unsigned char)X = (unsigned int X) >> N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (lshiftrt:HI (match_dup 0)
            (match_operand:HI 1 "const_int_operand" "i")))
   (set (match_operand:QI 2 "register_operand" "=r")
        (subreg:QI (match_dup 0) 1))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 0)
        (lshiftrt:HI (match_dup 0)
            (minus:HI (match_dup 1) 
                      (const_int 8))))]
  )


(define_insn "*lshiftrt_hi_to_qi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (lshiftrt:HI (match_dup 0)
            (minus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    int shift = INTVAL (operands[1]);
    if(shift < 8)
    {
      operands[1] = GEN_INT(8 - shift);
      output_asm_insn("sla  %0, %1", operands);
    }
    else if(shift > 8)
    {
      operands[1] = GEN_INT(shift - 8);
      output_asm_insn("srl  %0, %1", operands);
    }
    return "";
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (char)X = (int X) << N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashift:HI (match_dup 0)
            (match_operand:HI 1 "const_int_operand" "i")))
   (set (match_operand:QI 2 "register_operand" "=r")
        (subreg:QI (match_dup 0) 1))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 0)
        (ashift:HI (match_dup 0)
            (plus:HI (match_dup 1) 
                      (const_int 8))))]
  )


(define_insn "*ashift_hi_to_qi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashift:HI (match_dup 0)
            (plus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    operands[1] = GEN_INT(8 + INTVAL (operands[1]));
    output_asm_insn("sla  %0, %1", operands);
    return("");
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (int)X = (char X) >> N
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "=r")
        (ashiftrt:QI (match_dup 0)
            (match_operand:HI 1 "const_int_operand" "i")))
   (set (match_operand:HI 2 "register_operand" "=r")
        (sign_extend:HI (match_dup 0)))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 2)
        (ashiftrt:HI (match_dup 2)
            (plus:HI (match_dup 1) 
                      (const_int 8))))]
  )


(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
	(sign_extend:HI (match_operand:QI 1 "register_operand" "0")))
   (set (match_operand:HI 2 "register_operand" "=r")
        (ashiftrt:HI (match_dup 2)
            (match_operand:HI 3 "const_int_operand" "i")))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 2)
        (ashiftrt:HI (match_dup 2)
            (plus:HI (match_dup 3) 
                      (const_int 8))))]
  )


(define_insn "*ashiftrt_qi_to_hi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashiftrt:HI (match_dup 0)
            (plus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    int shift = INTVAL (operands[1]) + 8;
    if(shift > 15) shift = 15;
    operands[1] = GEN_INT(shift);
    output_asm_insn("sra  %0, %1", operands);
    return("");
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (int)X = (unsigned char X) >> N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (lshiftrt:HI (match_operand:HI 1 "register_operand" "0")
            (match_operand:HI 2 "const_int_operand" "i")))
   (set (match_operand:HI 3 "register_operand" "=r")
        (and:HI (match_operand:HI 4 "const_int_operand" "2")
                (match_operand:HI 5 "const_int_operand" "i")))]
  "(REGNO(operands[0]) == REGNO(operands[3])) && (INTVAL(operands[5]) == (1<<(8-INTVAL(operands[2])))-1)"
  [(set (match_dup 0)
        (lshiftrt:HI (match_dup 0)
            (plus:HI (match_dup 2) 
                      (const_int 8))))]
  )


(define_insn "*lshiftrt_qi_to_hi"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (lshiftrt:HI (match_dup 0)
            (plus:HI (match_operand:HI 1 "const_int_operand" "i") 
                      (match_operand:HI 2 "const_int_operand" "i"))))]
  ""
  {
    int shift = INTVAL (operands[1]) + 8;
    if(shift > 15) shift = 15;
    operands[1] = GEN_INT(shift);
    output_asm_insn("srl  %0, %1", operands);
    return("");
  }
  [(set_attr "length" "2")])


;;-------------------------------------------------------------------
;; Optimization for (int)X = ((int)(char X)) << N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (sign_extend:HI (match_operand:QI 1 "register_operand" "0")))
   (set (match_operand:HI 3 "register_operand" "=r")
        (ashift:HI (match_operand:HI 4 "register_operand" "3")
                   (match_operand:HI 5 "const_int_operand" "i")))]
  "(REGNO(operands[0]) == REGNO(operands[3]))"
  [(set (match_dup 0)
        (ashiftrt:HI (const_int 8)
            (ashift:HI (match_dup 0) 
                       (match_dup 5))))]
  )

(define_insn "*qi_hi_shift"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (ashiftrt:HI (match_operand:HI 1 "const_int_operand" "i")
            (ashift:HI (match_operand:HI 2 "register_operand" "0") 
                       (match_operand:HI 3 "const_int_operand" "i"))))]
  ""
  {
    int shift = INTVAL(operands[3]);
    if(shift == 0) {
      output_asm_insn("swpb %0", operands);
      }
    else if(shift >= 1 && shift <= 7) { 
      operands[3] = GEN_INT(8-shift);
      output_asm_insn("sra  %0, %3", operands);
      }
    else if(shift >= 9 && shift <= 15) {
      operands[3] = GEN_INT(shift-8);
      output_asm_insn("sla  %0, %3", operands);
      }

    operands[3] = GEN_INT(0x00FF << shift);
    output_asm_insn("andi %0, %3", operands);
   
    return("");
  }
  [(set_attr "length" "6")])


;;-------------------------------------------------------------------
;; Optimization for (unsigned int)X = ((unsigned int)(unsigned char X)) << N
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (zero_extend:HI (match_operand:QI 1 "register_operand" "0")))
   (set (match_operand:HI 3 "register_operand" "=r")
        (ashift:HI (match_operand:HI 4 "register_operand" "3")
                   (match_operand:HI 5 "const_int_operand" "i")))]
  "(REGNO(operands[0]) == REGNO(operands[3]))"
  [(set (match_dup 0)
        (lshiftrt:HI (const_int 8)
            (ashift:HI (match_dup 0) 
                       (match_dup 5))))]
  )


(define_insn "*unsigned_qi_hi_shift"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (lshiftrt:HI (match_operand:HI 1 "const_int_operand" "i")
            (ashift:HI (match_operand:HI 2 "register_operand" "0") 
                       (match_operand:HI 3 "const_int_operand" "i"))))]
  ""
  {
    int shift = INTVAL(operands[3]);
    if(shift >= 0 && shift <= 7) { 
      operands[3] = GEN_INT(8-shift);
      output_asm_insn("srl  %0, %3", operands);
      }
    else if(shift >= 9 && shift <= 15) {
      operands[3] = GEN_INT(shift-8);
      output_asm_insn("sla  %0, %3", operands);
      }

    operands[3] = GEN_INT(0xFFFF << shift);
    output_asm_insn("andi %0, %3", operands);
   
    return("");
  }
  [(set_attr "length" "6")])


;;-------------------------------------------------------------------
;; Optimization for (unsigned long)X = (unsigned long Y) >> 16
;;   Original code:
;;     mov  r3, r6
;;     mov  r4, r7
;;     mov  r6, r7
;;     clr  r6
;;
;;   Optimized:
;;     mov r3, r7
;;     clr r6
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (match_operand:HI 1 "register_operand" "r"))
   (set (match_operand:HI 2 "register_operand" "=r")
        (match_operand:HI 3 "register_operand" "r"))
   (parallel[
    (clobber (match_operand:HI 4 "register_operand" "r"))
    (set (match_operand:SI 5 "register_operand" "=r")
         (lshiftrt:SI (match_operand:SI 6 "register_operand" "5")
                      (match_operand:HI 7 "const_int_operand" "i")))
   ])]
  "((REGNO(operands[0]) == REGNO(operands[5])) &&
    (REGNO(operands[2]) == (REGNO(operands[0])+1)) &&
    (INTVAL(operands[7]) == 16)
   )"
  [(set (match_dup 2) (match_dup 1))
   (set (match_dup 0) (const_int 0))]
)


(define_insn "*set_consthi2"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (match_operand:HI 1 "const_int_operand" "i"))]
  ""
  {
    if(INTVAL(operands[1]) == 0) {
      output_asm_insn("clr  %0", operands);
    } else if((INTVAL(operands[1]) & 0xFFFF) == 0xFFFF) {
      output_asm_insn("seto  %0", operands);
    } else {
      output_asm_insn("li   %0, %1", operands);
    }
    return("");
  }
  [(set_attr "length" "4")])


;;-------------------------------------------------------------------
;; Optimization for X = Y << 16
;;   Original code:
;;     mov  r4, r6
;;     mov  r5, r7
;;     mov  r7, r6
;;     clr  r7
;;
;;   Optimized:
;;     mov r5, r6
;;     clr r7
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
        (match_operand:HI 1 "register_operand" "r"))
   (set (match_operand:HI 2 "register_operand" "=r")
        (match_operand:HI 3 "register_operand" "r"))
   (parallel[
    (clobber (match_operand:HI 4 "register_operand" "r"))
    (set (match_operand:SI 5 "register_operand" "=r")
         (ashift:SI (match_operand:SI 6 "register_operand" "5")
                      (match_operand:HI 7 "const_int_operand" "i")))
   ])]
  "((REGNO(operands[0]) == REGNO(operands[5])) &&
    (REGNO(operands[2]) == (REGNO(operands[0])+1)) &&
    (INTVAL(operands[7]) == 16)
   )"
  [(set (match_dup 0) (match_dup 3))
   (set (match_dup 2) (const_int 0))]
)


;-------------------------------------------------------------------
;; Optimization for byte array initializations
; This handles sequences like:
;   li   r1, >1200
;   movb r1, *r2
;   li   r1, >3400
;   movb r1, @1(r2)
;
; and converts to:
;   li   r1, >1234
;   movb r1, *r2
;   swpb r1
;   movb r1, @1(r2)
;
; This saves two bytes and is slightly faster
(define_peephole2
  [(match_scratch:HI 6 "r,r")
   (set (match_operand:QI 0 "register_operand" "=r,r")
        (match_operand:QI 1 "const_int_operand" "i,i"))
   (set (match_operand:QI 2 "nonimmediate_operand" "=R>,Q")
        (match_dup 0))
   (set (match_operand:QI 3 "register_operand" "=r,r")
        (match_operand:QI 4 "const_int_operand" "i,i"))
   (set (match_operand:QI 5 "nonimmediate_operand" "=R>,Q")
        (match_dup 3))]
  "peep2_reg_dead_p(4, operands[0]) && peep2_reg_dead_p(4, operands[3])"
  [(set (match_dup 6)
        (ior:HI (ashift:HI (match_dup 1) 
                     (const_int 8))
             (match_dup 4)))
   (set (match_dup 2)
        (subreg:QI (ashiftrt:HI (match_dup 6) (const_int 8)) 1))
   (set (match_dup 5)
        (subreg:QI (ashiftrt:HI (match_dup 6) (const_int 0)) 1))]
)


(define_insn "*movhi_combine_consts"
  [(set (match_operand:HI 0 "register_operand" "")
        (ior:HI (ashift:HI (match_operand:QI 1 "const_int_operand" "")
                           (match_operand:QI 2 "const_int_operand" ""))
                (match_operand:QI 3 "const_int_operand" "")))]
  ""
  {
    operands[1] = GEN_INT(((INTVAL(operands[1]) & 0xFF) << 8) |
                           (INTVAL(operands[3]) & 0xFF));
    return "li   %0, %1";
  }
  [(set_attr "length" "4")])


(define_insn "*movqi_for_initializer"
  [(set (match_operand:QI 0 "memory_operand" "=rR>,Q")
        (subreg:QI (ashiftrt:HI (match_operand:HI 1 "register_operand" "r,r")
                              (match_operand:HI 2 "const_int_operand" "i,i")) 1))]
  ""
  {
    if(INTVAL(operands[2]) == 8)
    {
      output_asm_insn("movb %1, %0", operands);
    }
    else if(INTVAL(operands[2]) == 0)
    {
      output_asm_insn("swpb %1", operands);
      output_asm_insn("movb %1, %0", operands);
    }
   return("");
  }
  [(set_attr "length" "2,4")])


;;-------------------------------------------------------------------
;; Optimization for memory-to-memory copies
;; Combine a mem-reg-mem copy into a mem-mem copy
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
        (match_operand:HI 1 "memory_operand" ""))
   (set (match_operand:HI 2 "memory_operand" "")
        (match_dup 0))]
  "peep2_reg_dead_p(2, operands[0])"
  [(set (match_operand:HI 2 "memory_operand" "")
        (match_operand:HI 1 "memory_operand" ""))]
)

   
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "memory_operand" ""))
   (set (match_operand:QI 2 "memory_operand" "")
        (match_dup 0))]
  "peep2_reg_dead_p(2, operands[0])"
  [(set (match_operand:QI 2 "memory_operand" "")
        (match_operand:QI 1 "memory_operand" ""))]
)


;;-------------------------------------------------------------------
;; Optimization for (int)X = (unsigned char)((int)X)
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (subreg:QI (match_operand:HI 1 "register_operand") 1))
   (set (match_operand:HI 2 "register_operand" "")
        (zero_extend:HI (match_dup 0)))]
  "REGNO(operands[0]) == REGNO(operands[2])"
  [(set (match_dup 2)
        (match_dup 1))
   (set (match_dup 2)
        (and:HI (match_dup 2) (const_int 255)))]
)

(define_insn "*andi_const"
  [(set (match_operand:HI 0 "register_operand" "")
        (and:HI (match_dup 0)
                (match_operand:HI 1 "const_int_operand" "")))]
  ""
  {
    int val = INTVAL(operands[1]) & 0xFFFF;
    if(val == 0)
      return "clr  %0";
    else if(val == 0xFFFF)
      return "";
    else
      return "andi %0, %1";
  }
  [(set_attr "length" "4")])

